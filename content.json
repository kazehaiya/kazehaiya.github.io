{"meta":{"title":"沐光","subtitle":"记录在前端之路的点点滴滴","description":"Just do IT!","author":"Caiyin","url":"https://monocy.site","root":"/"},"pages":[{"title":"所有分类","date":"2019-03-30T08:46:29.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"categories/index.html","permalink":"https://monocy.site/categories/index.html","excerpt":"","text":""},{"title":"僕のこと","date":"2019-03-30T08:45:38.000Z","updated":"2020-08-29T15:21:30.355Z","comments":true,"path":"about/index.html","permalink":"https://monocy.site/about/index.html","excerpt":"","text":"科中科技大学から卒業した僕は、今ウェーブ開発についての仕事をしています。ちょっと静かな性格なので、常に外で友たちと遊んではなく、部屋に掃除や料理などがもっと好きです。 ほとんどの男性と同じ、ゲームや、アニメ、スポーツ、ギターなどが好きです。そして探偵小説、家事、技術文章、日本語も僕の好物です。 会得した知識をメモして、他人と分かち合い、共に成長することがこのブログ書く目的です。だから、何か問題があったとしたら、コメントすることか、僕にメールすることもオーケーです。 (´▽｀)友たちも大歓迎ですよ～"},{"title":"所有标签","date":"2019-03-30T08:56:17.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"tags/index.html","permalink":"https://monocy.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Node 简单脚手架构建","slug":"Node-简单脚手架构建","date":"2021-06-30T15:13:15.000Z","updated":"2021-06-30T15:27:15.740Z","comments":true,"path":"2021/06/30/Node-简单脚手架构建/","link":"","permalink":"https://monocy.site/2021/06/30/Node-简单脚手架构建/","excerpt":"前言近期组内有脚手架相关项目的开发搭建，因为先前用过 vue-cli、create-react-app 等相关脚手架工具，对其实现的方式还是挺感兴趣的，因此趁此机会学习了解一番组内的脚手架工具的搭建，写篇文章小记一下～。","text":"前言近期组内有脚手架相关项目的开发搭建，因为先前用过 vue-cli、create-react-app 等相关脚手架工具，对其实现的方式还是挺感兴趣的，因此趁此机会学习了解一番组内的脚手架工具的搭建，写篇文章小记一下～。 搭建前的准备脚手架运作原理我们时常会在 ~/.bashrc 内注册自己的 alias 命令，如： 1alias goCode=\"cd ~/Code\" 然后 source ~/.bashrc 生效后，直接在控制台输入 goCode 就能够跳转至对应文件夹内了。这个指令就相当于是一个软链，告诉系统我调用它时，触发的就是其记录的代码。 Node 脚手架的运行其实也很类似，首先需要了解的一点就是 package.json 的 bin 字段，在安装对应的 npm 包时，它会告诉系统 bin 内注册的指令就是调用我这个包的指令（相当于软链），在命令行使用对应字段时就能够调用此包内的命令了。 开发需要的包交互包 commander：可以自动的解析命令和参数，用于处理用户输入的命令； inquirer：通用的命令行用户界面集合，用于和用户进行交互； 样式包 chalk：可以给终端的字体加上颜色； cfonts：可以添加炫酷的标题； ora：下载过程久的话，可以用于显示下载中的动画效果； 模板包 download-git-repo：下载并提取 git 仓库，用于下载项目模板； ejs：模板引擎，将用户提交的信息动态填充到文件中； 项目搭建初始化仓库结构在准备步骤已经说过，此需要配合使用到 package.json 的 bin 字段，参考 @vue/cli 的项目结构，初始化项目的结构如下： 然后在该项目内执行 npm link 挂载在系统全局的 npm 包列表内，就能够调用 myInit 指令了（控制台会打印出 “init” 内容）。 取消挂在命令为： npm unlink（仍然是项目内使用） 添加交互现在能够调用自己创建的指令了，接下来就需要添加一些交互信息，比如最为基础的 myInit --help 指令，获取全量指令列表，那么我们先需要安装 commander 包来处理用户提示。 此包的使用方式很简单，按照一下模板开发即可： 1234567891011121314151617181920212223242526272829303132/** 初始化实例 */const &#123; Command &#125; = require('commander');const program = new Command();/** 修改通用配置 */// Head Line Tipsprogram.name('myInit').usage('&lt;command&gt; [options]');// Version Optionsconst currentVersion = require('../package.json').version;program.version(currentVersion, '-v, --version', 'output the current version');// Help Optionsprogram.helpOption('-h, --help', 'output usage information');/** 添加自定义 Command 指令 */program .command('create &lt;projectName&gt; [opts]') .description('Create a program use remote git model') .option('-i, --inhert', 'create an existed project') .action((name, opts) =&gt; &#123; console.log(`The project name is \"$&#123;name&#125;\", and the option is $&#123;opts&#125;`); &#125;);/** 触发调用和默认信息提示 */// Default value is \"process.argv\"program.parse();// None Matchif (!program.args.length) &#123; program.help();&#125; 将通用配置部分按照自己所需配置好后，后面只需要扩充 Command 指令就能够实现控制台交互的效果了。 添加选项交互如果需要像 @vue/cli 创建项目的交互那样，添加可选择的内容，仅仅依靠 commander 是实现不了的，这时候需要配合使用 inquirer 来做到页面交互。 inquirer 的示例也很清晰明了，可以直接看 github 文档，各种类型均有所介绍，常用的类型包括：list、checkbox、input、list 等。写法如下： 12345678910111213141516171819202122232425const inquirer = require('inquirer');inquirer .prompt([ &#123; type: 'input', name: 'first_name', message: \"What's your first name\", &#125;, &#123; type: 'input', name: 'last_name', message: \"And what's your last name\", &#125;, &#123; type: 'list', name: 'sex', message: 'Are you a girl or boy', choices: ['boy', 'girl'], &#125;, ]) .then(answers =&gt; &#123; // 结果： &#123; first_name: '', last_name: '', sex: '' &#125; console.log(answers); &#125;); inqurer 部分的内容一般放在 Commander 的 action 的结果会调部分，用于更精确的处理。 添加模板下载方法在交互完成后，可以像 @vue/cli 那样直接从远程将对应模板给下载下来，当然，下载下来的模板如果能配合先前的 inquirer 做自定义配置则会更好，简单弄的话直接拷贝一个模板仓库就差不多完事了，最多再调用一下 bash 指令做一下包的安装，简化一下用户操作，示例如下： 1234567891011121314// download-vue.jsconst download = require('download-git-repo');module.exports = () =&gt; &#123; return new Promise((res, rej) =&gt; &#123; download( 'kazehaiya/vue-typescript-components', 'repo/demo', function (err) &#123; err ? rej('下载失败') : res('下载成功'); &#125;, ); &#125;);&#125;; 之后在 commander 的 actions 操作中调用该文件即可。 优化样式基本的控制台交互按照上述两步走基本就 OK 了，剩下的如：控制台颜色配置、标题配置、加载中状态处理 等样式部分可以慢慢优化，代码内用的比较全的例子如下： 123456789101112131415program .command('download') .description('Download Vue Template') .action(async () =&gt; &#123; const spinner = ora(); try &#123; spinner.start(chalk.blue('模板下载中……')); await require('../lib/download-vue')(); &#125; catch &#123; spinner.fail(chalk.red('下载失败')); &#125; finally &#123; spinner.succeed(chalk.green('下载完成')); &#125; &#125;); 适当的时候使用 chalk 调一下控制台颜色，让输出的内容更加鲜明，然后增加一下加载效果，整体的用户体验就一下子上来了。最后如果需要的话，可以用 cfonts 弄一个炫酷的标题，可能会有不一样的感受： 参考文章 Package.json Commander.js Inquirer.js @vue/cli 前端如何搭建一个简单的脚手架 从 0 搭建一个自己的前端脚手架 前端如何搭建一个成熟的脚手架","categories":[{"name":"Node","slug":"Node","permalink":"https://monocy.site/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://monocy.site/tags/Node/"}]},{"title":"Typora 主题改造","slug":"Typora-主题改造","date":"2021-06-05T07:06:36.000Z","updated":"2021-06-06T13:54:10.512Z","comments":true,"path":"2021/06/05/Typora-主题改造/","link":"","permalink":"https://monocy.site/2021/06/05/Typora-主题改造/","excerpt":"前言最近在配置 Typora 的主题时，发现了一个挺不错的主题，但是稍微有一点点瑕疵（对个人来说），因此基于该主题，我更新了部分样式的配置，优化了一些内容。","text":"前言最近在配置 Typora 的主题时，发现了一个挺不错的主题，但是稍微有一点点瑕疵（对个人来说），因此基于该主题，我更新了部分样式的配置，优化了一些内容。 Markdown 样式样式大致呈现如下，代码参考可点击此传送门。 提示：想要自己定义样式，可先导出为 html 文件，然后再调整配置即可。 参考文章 Typora Documents Theme “OrangeHeart”","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://monocy.site/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://monocy.site/tags/Markdown/"}]},{"title":"React 通用开发模式小记","slug":"React-通用开发模式小记","date":"2021-05-07T14:25:37.000Z","updated":"2021-05-07T14:30:49.111Z","comments":true,"path":"2021/05/07/React-通用开发模式小记/","link":"","permalink":"https://monocy.site/2021/05/07/React-通用开发模式小记/","excerpt":"前言近期花了差不多 1 个月的时间开发项目，包含看板、列表两种类型，从早期磕磕绊绊的页面设计，中间的反复改版，到最终的完成开发，也体会到了很多不一样的点，感受特别深的是与 Vue 开发时的区别，这里简单记一下我的心得体会。","text":"前言近期花了差不多 1 个月的时间开发项目，包含看板、列表两种类型，从早期磕磕绊绊的页面设计，中间的反复改版，到最终的完成开发，也体会到了很多不一样的点，感受特别深的是与 Vue 开发时的区别，这里简单记一下我的心得体会。 开发方式的改变对于 Vue 来说，因为有双向绑定，因此习惯将大多数逻辑写在一个组件里，通过 computed 钩子监听多个依赖项的变动，双向数据流通拿到需要的参数值，必要时再配合上 Vuex，便能很好的解决大多数通用表单的问题。 但这个在 React 中是不太吃香的，因为 React 是单向数据流，先不论比较麻烦的值传递问题，仅看 Hook 对参数的依赖，也会造成一些比较麻烦的问题，比如： ​折线图列表，每个列表有自己的查询条件，同时也依赖外部传入的查询条件，为它们封装一个组件的话则会有死循环问题，必须拆成俩组件才能较好的处理此情况，而 Vue 则因为不用担心函数刷新触发查询，因此写在一个组件内也没问题。 因此对于 React 来说，组件拆的越细，耦合程度越低，那么使用 Hook 或者 HOC 来拼凑起来会更为方便，而且对于组件优化、逻辑梳理也会更为容易一些。 页面开发模式对于顶部 Form 表单，底部多个 折线图、表格 这样常见的表单页面（底部图表可能自带子表单项），我总结了一点开发心得，按照这种方式开发，能减少很多写代码时的心智负担，同时也能便捷的解决很多表单场景。 类比 Vue 的 Vuex + Components 的模式，在 React 开发时使用的模式为 CreateContext + Components ，Store 存储的基础内容如下： 1234567// CreateContext 的对象内容&#123; form: &#123;&#125;, // form 表单项 formLoading: true, // form 表单是否查询中（初始化&amp;查询状态控制）&#125;// 组件中直接使用 Context 来更新存储，还能根据情况依赖 Context 或 Context.value ，来控制函数的更新频次 此外，还可以使用 CreateContext + useReducer 的模式来做一些复杂的控制逻辑，当然这也是 React 官网推崇的方式。 组件部分的内容可分为以下三步来看： Form 表单的初始化顶部 Form 表单部分推荐单独使用一个组件封装，仅向外暴露最终的 form.getFieldsValue 的内容（无需做任何参数处理），这样的好处是给外部留下预查询的一些处理、以及表单内容的处理和缓存。内部初始化可考虑如下步骤： 表单设置初始化 loading 状态（Context 中获取），通过 useRef 创建一个空的表单初始化值 initValue； 根据项目需要，使用 useEffect 获取表单的异步依赖项（如下拉菜单） 待所有异步依赖获取完后更新 ref.current 的初始化值，然后使用 form.resetFields 更新默认选中项目； 最后关闭 loading 状态，并根据情况设置是否默认查询（向外触发 onChange）； 查询处于 loading 状态时可以考虑使用一些动画来让页面不显得那么突兀。 表单查询&amp;缓存Form 表单查询得分为两部：预查询&amp;表单查询。 预查询 的目的其一是为了查询前的表单校验，此外则是部分条件的初始化和格式化（如 table 的初始分页信息、表单查询条件格式化），这和分页查询等的逻辑是分开的，最后就是查询条件的缓存了；后续的 表单查询 则使用传入的查询条件即可，因为如其它的分页查询、重置查询等都需要依赖缓存内容进行查询，这样整体的逻辑也就拆开了。 查询的逻辑列举如下： 点击表单的查询按钮，触发表单查询函数，向外部 emit 出来的参数，并调用 beforeSearch 函数； 处理 form 表单参数，初始化 分页、排序 等参数信息，缓存格式化后的查询条件，设置 loading 状态； 根据情况触发对应的查询函数（调用查询 或 监听缓存条件查询）； 接口参数还依赖自身组件的情况除了表单查询外，部分接口可能还有自身的查询条件（如：自带日期筛选的图表组件），这种情况其接口触发查询的情况有两种：Form 表单查询 以及 自身筛选条件变更查询。如果直接监听两者则会出现“初始化查询两次”的问题，因此需要做一些优化，这里我总结了一些方法： 使用 Ref 设置初始化状态，初始化时不做处理，待后续变更时再做调用。 123456789101112131415import React, &#123; useRef, useEffect &#125; from 'react';const demo = () =&gt; &#123; const initRef = useRef(true); // 初始化时阻碍触发 useEffect(() =&gt; &#123; if (initRef.current) &#123; initRef.current = false; return; &#125; // 其它操作 &#125;, [initRef]);&#125;; 将俩情况拆分为两种处理方式，并通过 useRef 来存储子查询条件： Form 表单项变更，通过触发 useEffect 来触发接口函数；（副作用函数） 子查询条件变更，触发 onChange 事件，并更新 ref 的自身查询依赖，手动调用接口函数；（仅事件变动触发） 注意：子查询条件仅根据 onChange 事件触发，初始化参数均在子组件设置的时候初始化即可。 参考文章 Hooks FAQ","categories":[{"name":"React","slug":"React","permalink":"https://monocy.site/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://monocy.site/tags/React/"}]},{"title":"React.memo、useMemo 和 useCallback 的区别","slug":"React-memo、useMemo和useCallback的区别","date":"2021-02-28T03:39:39.000Z","updated":"2021-02-28T03:52:53.783Z","comments":true,"path":"2021/02/28/React-memo、useMemo和useCallback的区别/","link":"","permalink":"https://monocy.site/2021/02/28/React-memo、useMemo和useCallback的区别/","excerpt":"前言在看完了一遍 React 的基础内容后，现在又回过头来看 React 组件更新与优化相关的知识了，在使用 Hook 之后，与这个话题脱不开关系的便有 useMemo、useCallback 和 React.memo 了，正好项目优化时碰到了这么些知识，刚好总结一番。","text":"前言在看完了一遍 React 的基础内容后，现在又回过头来看 React 组件更新与优化相关的知识了，在使用 Hook 之后，与这个话题脱不开关系的便有 useMemo、useCallback 和 React.memo 了，正好项目优化时碰到了这么些知识，刚好总结一番。 三者区别首先从使用位置来看可以划分为两种： 作用于组件： React.memo 作用于组件内：useMemo 和 useCallback 那么分别来看有什么作用吧～ React.memoReact.memo 主要是为了缓存组件，当父组件 state 更新，但未改变子组件的入参的 state 值时，子组件应该不自我更新，而是用先前的缓存值： 父组件： 12345678910111213141516171819202122232425262728// 父组件 App.tsximport React, &#123; useState, useCallback, useEffect &#125; from 'react';import Counter from './memo-test/counter';function App() &#123; const [counter1, setCounter1] = useState(1); const [counter2] = useState(2); const updateCounter1 = () =&gt; &#123; setCounter1(counter1 + 1); &#125;; useEffect(() =&gt; &#123; console.log('parent update'); &#125;); return ( &lt;&gt; &lt;button onClick=&#123;updateCounter1&#125;&gt;更新 Counter1&lt;/button&gt; &lt;h3&gt;Counter 1:&lt;/h3&gt; &lt;Counter count=&#123;counter1&#125; cname=\"Counter1\"&gt;&lt;/Counter&gt; &lt;h3&gt;Counter 2:&lt;/h3&gt; &lt;Counter count=&#123;counter2&#125; cname=\"Counter2\"&gt;&lt;/Counter&gt; &lt;/&gt; );&#125;export default App; 子组件： 123456789101112131415161718192021import React, &#123; memo &#125; from 'react';interface IProps &#123; cname: string; count: number;&#125;const Counter = (props: IProps) =&gt; &#123; const &#123; count, cname &#125; = props; // 每次重新加载时触发 console.log(`updated $&#123;cname&#125;`); return ( &lt;p&gt; &#123;cname&#125;'s value is: &#123;count&#125; &lt;/p&gt; );&#125;;export default memo(Counter); 这里点击“更新 Counter1”的按钮后，会导致父组件更新，父组件更新后因为无缓存，因此子组件也就一起更新了，但是仔细分析一下，我们的 Counter2 的传参并无任何变动，这里更新后造成了多余的渲染，资源浪费，因此需要做一下缓存（子组件的注释替换一下即可），这样就 Counter2 就不会重复渲染了。为缓存和缓存后写法的结果分别为： 未缓存： 已缓存： 可见缓存后的组件在参数不变的情况下是不会重新渲染的！ useMemouseMemo 主要是对变量进行缓存（当然函数也可以，但推荐使用 useCallback，除非需要一些定制化逻辑操作），该 Hook 一般于 useEffect 进行比较。useMemo 是在依赖变动后，Dom 变动前触发的，而 useEffect 则是依赖变动后，Dom 变动后才出发（副作用）。 因此，如果依赖变更后需要立即做出反应时可以使用 useMemo ，如果是依赖变动后，需要带着触发一些其它的操作，则使用 useEffect： 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; useState, useMemo, useEffect &#125; from 'react';function App() &#123; const [counter1, setCounter1] = useState(1); const updateCounter1 = () =&gt; &#123; setCounter1(counter1 + 1); &#125;; const getRandom = () =&gt; &#123; return Math.random() * 10; &#125;; const memoRandom = useMemo(() =&gt; &#123; // 此处会立即触发哟～ return Math.random() * 10; &#125;, []); useEffect(() =&gt; &#123; console.log('counter1 变动了'); &#125;, [counter1]); useEffect(() =&gt; &#123; console.log('getRandom 变动了'); &#125;, [getRandom]); useEffect(() =&gt; &#123; console.log('memoRandom 变动了'); &#125;, [memoRandom]); return ( &lt;&gt; &lt;button onClick=&#123;updateCounter1&#125;&gt;更新 Counter1&lt;/button&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;p&gt;Counter1: &#123;counter1&#125;&lt;/p&gt; &lt;p&gt;Random: &#123;getRandom()&#125;&lt;/p&gt; &lt;p&gt;MemoRandom: &#123;memoRandom&#125;&lt;/p&gt; &lt;/&gt; );&#125;export default App; 这里变更 counter1 时，咱们的 randome 会一直变更，但这显然不是我们需要的，此处就可以使用 useMemo 做一次缓存，这样就不会随着父组件的刷新而变动了。 useMemo 可以直接理解为 Vue 的 computed 钩子 useCallbackuseCallback 是对组件内的函数进行缓存。当组件的 state 变动后，其会更新整个组件内容，未做缓存的处理的函数都会重新生成一次，这在有 useEffect 监听的情况下会造成每次都触发，因此可用 useCallback 进行函数的缓存： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, &#123; useState, useCallback, useMemo, useEffect &#125; from 'react';import Counter from './memo-test/counter';function App() &#123; const [counter1, setCounter1] = useState(1); const [counter2, setCounter2] = useState(2); const updateCounter1 = () =&gt; &#123; setCounter1(counter1 + 1); &#125;; const updateCounter2 = () =&gt; &#123; setCounter2(counter2 + 1); &#125;; const callbackedCounter2 = useCallback(() =&gt; &#123; setCounter2(counter2 + 1); &#125;, [counter2]); useEffect(() =&gt; &#123; console.log('updateCounter1 变动了'); &#125;, [updateCounter1]); useEffect(() =&gt; &#123; console.log('updateCounter2 变动了'); &#125;, [updateCounter2]); useEffect(() =&gt; &#123; console.log('callbackedCounter2 仅在 counter2 变更时变更'); &#125;, [callbackedCounter2]); return ( &lt;&gt; &lt;button onClick=&#123;updateCounter1&#125;&gt;更新 Counter1&lt;/button&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;button onClick=&#123;updateCounter2&#125;&gt;更新 Counter2&lt;/button&gt; &lt;h3&gt;Counter 1:&lt;/h3&gt; &lt;Counter count=&#123;counter1&#125; cname=\"Counter1\"&gt;&lt;/Counter&gt; &lt;h3&gt;Counter 2:&lt;/h3&gt; &lt;Counter count=&#123;counter2&#125; cname=\"Counter2\" callbackedCounter2=&#123;callbackedCounter2&#125; &gt;&lt;/Counter&gt; &lt;/&gt; );&#125;export default App; 点击“更新 Counter1”的结果如下： 如果仅仅只是父组件内有函数变动，用不用 useCallback 影响不大，但是一旦有子组件有传入父组件的函数时，一定得注意 useCallback 来缓存父组件的函数，否则会带来不必要的渲染。 useCallback 是 useMemo 的语法糖：useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps) 总结 React.memo 的使用场景：父组件频繁变更的内容不会影响到子组件时，需要对子组件做 React.memo 缓存处理； useMemo 的使用场景：当组件内的函数返回值不需要随着组件的刷新而变更时，需要对其做 useMemo 缓存处理 useCallback 的使用场景：父组件传递函数给子组件，该函数均需做 useCallback 缓存处理，减少子组件重复渲染； 12345678910111213// useMemo 和 useCallback 函数缓存写法const memoFunc = useMemo(() =&gt; &#123; // 每次父组件重新渲染时会执行的部分，可以做额外操作 return () =&gt; &#123; // 函数内容 &#125;&#125;, []);// 只有 useMemo 的 return 的部分const callbackFunc = useCallback(() =&gt; &#123; // 函数内容&#125;, []) ⚠️注：开发环境请根据具体情况进行缓存优化，因为缓存的监听函数也是需要消耗资源的，过度缓存有时会适得其反。 参考文章 介绍React.memo, useMemo 和 useCallback 使用memo,useMemo和useCallback优化react渲染性能 useMemo和useEffect有什么区别","categories":[{"name":"React","slug":"React","permalink":"https://monocy.site/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://monocy.site/tags/React/"}]},{"title":"TS 高级技巧","slug":"TS-高级技巧","date":"2021-02-18T02:39:36.000Z","updated":"2021-02-18T02:48:18.744Z","comments":true,"path":"2021/02/18/TS-高级技巧/","link":"","permalink":"https://monocy.site/2021/02/18/TS-高级技巧/","excerpt":"前言假期在家中无意间刷到了一篇 TS 技巧的文章，自己尝试了一下，觉得确实挺不错的，因此这里做一些记录。","text":"前言假期在家中无意间刷到了一篇 TS 技巧的文章，自己尝试了一下，觉得确实挺不错的，因此这里做一些记录。 活用提示在使用 ts 的 interface 做定义声明时，一般写注释时都习惯性的使用单行注释 // ...，虽然在看对应的 interface 时我们能知道是什么内容，但是在使用时往往只有个光秃秃的声明，后期维护时会感觉特别鸡肋： 但是如果这样写注释的话，在注释的呈现上会更利于阅读： 对返回参数、组件传参声明 等会经常去查阅的 ts 声明部分，可使用多行注释的写法，让使用体验更友好。 interface &amp; typeTypeScript 中有两种定义接口类型的方法，分别是： interface（接口）、type alias（类型别名），它们之间是能够自身继承、相互继承的： 123456789101112131415161718192021222324// interface 继承 interfaceinterface Item &#123; name: string&#125;interface SubItem extends Item &#123; age: number&#125;// type alias 继承 type aliastype Shape = &#123; name: string &#125;type SubShape = Shape &amp; &#123; age: number &#125;// interface 继承 type aliastype Data = &#123; name: string &#125;interface SubData extends Data &#123;trueage: number&#125;// type alias 继承 interfaceinterface List &#123; name: string&#125;type SubList = List &amp; &#123; age: number &#125; 这两者使用上特别相似，但也稍微有些不一样的地方 1. 写法不同1234567891011121314// interface（偏向于：类、实例）interface IProps &#123; name: string funcA: (param1: number) =&gt; void&#125;// type alias（偏向于：字面量形式的值/对象、函数）type data = &#123; name: string &#125;type funcA = (param1: number) =&gt; void// 函数的 ts 声明的三种写法const func1: funcA = (p) =&gt; &#123;&#125; // type 声明const func2: IProps['funcA'] = (p) =&gt; &#123;&#125; // interface 声明const func3 = (p: number): void =&gt; &#123;&#125; // 内联式声明 目前项目中使用面向对象的写法会多一些，因此 类、实例 的出现比例会打一些，对于单独 .ts 文件内声明的函数可用 type 做声明会更方便一些 2. 其它不同其它部分就直接粘贴看到的文章了，就不赘述了 typeof这一点先前确实没关注过，不过对于有默认值的类型，确实会节省不少时间： 12345678910const defaultProps = &#123; /** 这里写属性的提示：姓名 */ name: ''&#125;/** 这里写整体的提示 */type IProps = typeof defaultProps;// 这里 hover 上时会有提示const myData: IProps = defaultProps keyof这个单独来看用途可能不是很大，但是封装通用函数时，没有这个可能问题很大： 按照以前的写法，所获得的值会丢失类型，这 ts 就有些尴尬： 使用 keyof 方法改写后，我们来看看效果： 这样我们便能够从方法中推断出对应对象的类型了，确实方便了很多。 参考文章 TypeScript: Interfaces vs Types [TypeScript 中提升幸福感的 10 个高级技巧](","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://monocy.site/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://monocy.site/tags/TypeScript/"}]},{"title":"Chales 安装配置","slug":"Chales-安装配置","date":"2021-01-09T08:08:19.000Z","updated":"2021-01-09T10:14:49.369Z","comments":true,"path":"2021/01/09/Chales-安装配置/","link":"","permalink":"https://monocy.site/2021/01/09/Chales-安装配置/","excerpt":"前言最近做到一些 H5 相关的内容开发，因为需要手机端的登陆 Cookie 信息，因此需要通过 Charles 抓包来获取 Cookie。安装虽然很简单，但是有几个比较坑的点着实花费了我不少时间，这里做一下记录。","text":"前言最近做到一些 H5 相关的内容开发，因为需要手机端的登陆 Cookie 信息，因此需要通过 Charles 抓包来获取 Cookie。安装虽然很简单，但是有几个比较坑的点着实花费了我不少时间，这里做一下记录。 安装下载下载直接去官网下载即可（特别慢，能科学上网的尽量科学），下载完后有 30 天的试用期，可以尝试在Charles授权码在线生成网站上生成 Charles 码，或者用如下激活码试试： 12name: https://zhile.iokey: 48891cf209c6d32bf4 配置代理http 解析配置打开 Proxy -&gt; Proxy Settings，勾选上 Enable transparent HTTP proxying 即可，Sockets 部分可根据自己情况配置： 这样本机的 http 请求就能解析了。 https 解析配置打开 Proxy -&gt; SSL Proxying Settings，勾选上 Enable SSL Proxying，然后添加 *:443 配置，用于拦截所有的 https 请求： 配置证书1. 配置 Mac 证书特别是对于第一次安装 Charles 的人来说，这一步很容易忽略掉： 证书安装完后其默认是不生效的，我们需要将其生效才能真正安装完： 2. iOS 证书安装除了电脑证书外，手机端的证书也比较重要，可以一并安装。这里需要注意一下，确保手机和电脑连接的是同一局域网内。 【1】 首先需要配置手机连接的局域网代理（iOS 是连接的网络的 i 图标 -&gt; 配置代理，改成手动）： 服务器： Mac 的 ip 地址 端口： 配置 Proxy Settings 时的 8888 端口（根据自己的设置进行配置） ⚠️ ：配置后 Mac 会出来一个弹框（默认为 Deny），此处一定得注意点击 Allow 【2】 下载手机端的证书，Safari 打开如下地址： https://chls.pro/ssl，此处会提示你安装证书，点击安装即可。 安装后需要在两个地方进行配置： 进人通用 -&gt; 描述文件与设备管理，安装刚下载的描述文件 进入通用 -&gt; 关于本机 -&gt; 证书信任设置，开启刚刚新增证书的信任 ⚠️ ：以上俩步缺少一个可能导致手机端无法上网，Charles 拦截乱码信息 其它问题Charles 拦截不到浏览器请求如果配置完成后 Charles 仍然拦截不到浏览器请求，请查看 Chrome 插件是否开启了 vpn 插件，一般开启后就拦截不到了。 配置手机代理时不小心点了 Deny点了 Deny 不要紧，手动将代理的 IP 地址填上即可，添加代理地址的路径为： Proxy -&gt; Access Control Settings 注意，添加的地址为最终代理的地址，一般 App 都是用所代理的电脑 IP（即配置局域网代理时填写的 IP） 参考文章 Mac 下配置 Charles，安装证书 Charles 常用功能 细说 Charles 配置 HTTPS 代理的乱码问题","categories":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/categories/环境/"}],"tags":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/tags/环境/"}]},{"title":"React Hook 初学记录","slug":"React-Hook-初学记录","date":"2020-12-05T09:38:00.000Z","updated":"2020-12-05T09:55:32.128Z","comments":true,"path":"2020/12/05/React-Hook-初学记录/","link":"","permalink":"https://monocy.site/2020/12/05/React-Hook-初学记录/","excerpt":"前言此篇为我从 Vue 转 React，初学 React Hook 的一些记录，记录一些写法和注意项。","text":"前言此篇为我从 Vue 转 React，初学 React Hook 的一些记录，记录一些写法和注意项。 useState此 hook 相当于 Vue 中 Date 函数返回的对象的值，返回一个数组： 1234// state: 对应的值// setState: 更新改值的函数// initialState: 初始化值const [state, setState] = useState(initialState); useState 的两种写法： 12345678// 对于简单值可直接设置useState(initVal);// 对于复杂的操作，可使用函数处理useState(() =&gt; &#123; // initVal 仅在初始化渲染时起作用 const initVal = complexFunc(props) return initVal;&#125;) setState 有两种使用方式： 1234567// 直接设置新值setState(newVal);// 基于旧值操作获得新值setState((preVal) =&gt; &#123; // ... return newVal;&#125;); useEffect此 hook 相当于 Vue 的 updated 钩子，其会在组件渲染到屏幕之后延迟执行（会保证在任何新的渲染前执行），也可以配置让其仅在某些值改变的时候执行： 12345678910111213141516171819// return 方法用于清楚一些副作用函数（如：removeEventListener）// 注：不能传入异步函数useEffect(() =&gt; &#123; someFunc(); return () =&gt; &#123; someClearFunc(); &#125;&#125;)// 在某些值改变的情况下执行// 注意：没有 someVal 时改 hook 仅会在初始化时执行useEffect(() =&gt; &#123; someFunc(); return () =&gt; &#123; someClearFunc(); &#125;&#125;, [someVal]) 如果需要在所有 DOM 变动之后同步调用 effect，则需要使用到 useLayoutEffect，但推荐一开始时优先使用 useEffect 方法。 若要从服务端渲染的 HTML 中排除依赖布局 effect 的组件，可以通过使用 showChild &amp;&amp; &lt;Child /&gt; 进行条件渲染，并使用 useEffect(() =&gt; { setShowChild(true); }, []) 延迟展示组件。这样，在客户端渲染完成之前，UI 就不会像之前那样显示错乱了。（如弹框组件初始化问题） useContext可以理解为 Vue 的 Provide/Inject 钩子（不是 ProvideReactive/InjectReactive）: 1234567891011const MyContext = React.createContext(/* default value */);function App() &#123; return ( &lt;MyContext.Provider value=&#123;themes.dark&#125;&gt; // Components &lt;/MyContext.Provider&gt; );&#125;useContext(MyContext) Provider 内如果绑定了 value（即使是 undefined）,default value 也不会生效 useReducer简化版的 Redux，与 useState 的区别是需要配置 reducer 函数，处理不同 type 的操作。 项目开发可能使用的不是很多，不做过多记录 useCallback可以理解成 Vue 的 computed 钩子，不过其记录的是函数，使其仅在依赖项变更时才更新函数。当依赖参数不经常变时，可以优化子组件的渲染（返回的是子组件）。 12345// 依赖项数组不会作为参数传给回调函数const memoizedCallback = useCallback( () =&gt; &#123; doSomething(a, b); &#125;, [a, b],); 此 hook useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。注：滥用的话不仅不会提升性能，反而会降低性能。 useMemo相当于 Vue 的 computed 钩子了，有助于避免在每次渲染时都进行高开销的计算。 1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。大致流程：Dom 变更 -&gt; useMemo -&gt; 所有 Dom 渲染完成 -&gt; useEffect useRef可以理解成 Vue 的 Ref 钩子，但是其不仅仅局限于保存 DOM 节点，其 .current 属性中可以保存一个可变值。 1const refContainer = useRef(initialValue); useRef() 和自建一个 {current: ...} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。注： 当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。 useImperativeHandle增强版 useRef，可以自定义设置在使用 ref 时需要暴露给父组件的实例值，且useImperativeHandle 应当与 forwardRef 一起使用： 1234567891011121314// 基本方法useImperativeHandle(ref, createHandle, [deps]);// 实例function FancyInput(props, ref) &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; ... /&gt;;&#125;FancyInput = forwardRef(FancyInput); 在大多数情况下，应当避免使用 ref 这样的命令式代码，可考虑使用 useImperativeHandle 做一层属性上的封装。 useLayoutEffect它会在所有的 DOM 变更之后同步调用 effect，在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。 尽可能使用标准的 useEffect 以避免阻塞视觉更新。useLayoutEffect 与 componentDidMount、componentDidUpdate 的调用阶段是一样的。 useDebugValueuseDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。 1234567891011function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); // ... // 在开发者工具中的这个 Hook 旁边显示标签 // e.g. \"FriendStatus: Online\" useDebugValue(isOnline ? 'Online' : 'Offline'); return isOnline;&#125; 不推荐你向每个自定义 Hook 添加 debug 值。当它作为共享库的一部分时才最有价值。 参考文档 Hook 简介","categories":[{"name":"React","slug":"React","permalink":"https://monocy.site/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://monocy.site/tags/React/"}]},{"title":"2020 年大厂面试总结","slug":"2020-年大厂面试总结","date":"2020-10-24T09:31:17.000Z","updated":"2020-10-25T12:31:28.339Z","comments":true,"path":"2020/10/24/2020-年大厂面试总结/","link":"","permalink":"https://monocy.site/2020/10/24/2020-年大厂面试总结/","excerpt":"前言这次面试因为有比较明确的目标，想去 阿里、美团、快手、头条 等大公司提升提升自己，因此在准备了一番后，依次面了对应的公司。此处主要是总结一下当时面试遇到的一些问题，看看对于 2 年前端经验的人面试官们到底需要怎样的能力，以及部分问题的解体的思路。 注：面试一定得表现的自然，轻松自然、说话流畅自信会更容易通过面试！","text":"前言这次面试因为有比较明确的目标，想去 阿里、美团、快手、头条 等大公司提升提升自己，因此在准备了一番后，依次面了对应的公司。此处主要是总结一下当时面试遇到的一些问题，看看对于 2 年前端经验的人面试官们到底需要怎样的能力，以及部分问题的解体的思路。 注：面试一定得表现的自然，轻松自然、说话流畅自信会更容易通过面试！ CSS 部分在我面试时，遇到的 CSS 相关问题很少，大概掌握两个问题即可。 更多 CSS 相关面试题可查阅： CSS 知识点整理 1. 水平居中布局这个算是经典中的经典题了，之前我也总结过一篇 水平垂直居中 的文章，网上同样也有很多相关的题目，这里就不赘述了。 当然，这个问题问出来只能算是一个引子，于此引出的问题还包括： flex 相关知识 translate 字体模糊问题 相关文章： Flex 布局教程：语法篇 translateZ 字体模糊问题 transform 使用导致元素内字体出现模糊的坑 2. BFC 问题该部分也是老生长谈的内容，可参考我之前总结的文章 浅谈 BFC，这里也不做赘述了。 面试出 CSS 的问题可以说基本上就这么俩，不会有过多其余的细节考察（除非校招生），重点还是在 JavaScript、算法和项目经验上。 JavaScript 部分JS 部分面试也基本和网上的面经差异不大，除非像头条、阿里部分会考察一些偏原理性的问题外，其余的基本是 ES6 外加一两道 JS 题，大致有如下内容： 1. ES6～11 新特性该部分的问题基本上和 ES6 入门教程 没太多出入，把网上那部分知识啃完，然后项目中多撸撸基本上没问题，比较重点的是这么几个： 从 let、const 问到 闭包函数，最后到 作用域 相关内容 原型链 与 Class Promise 与 代码执行顺序 ES Module 与 CommonJs 差异 箭头函数 与 this 相关问题 像 Proxy、解构、Set、Map、对象数组等的扩展 问题之类的，问的频率很小，我是没有被问到过。 相关文章： 深入理解 JavaScript 闭包之什么是闭包 2. bind 和 apply/call 的区别，实现一个 bind根本区别是 bind 返回一个函数，绑定时不执行，调用时执行；后者直接执行。 参考面试题题解 3. 实现一个任务调度函数这部分考察对 Promise 的理解，只要知道“当异步函数处理完获得了返回的结果后，再调用下一个任务”这个逻辑后，题目就很好解开了。 参考面试题题解 4. 实现一个 JSONP这个问题我当时没写出来，但是和面试官说明了思路（刷题刷漏了）。JSONP 的思路是 script 脚本不受跨域限制，因此后端将返回内容通过 JSON 拼接到 script 链接函数内后，前端拿到 script 脚本就会触发全局函数执行（提请注册的一个 callback 函数）。 参考面试题题解 5. 实现 excel 的字符串坐标转数组这个面试题是我觉得最简单的一个，主要是考察简单的正则以及进制转换。只要知道“10 进制转 N 进制”以及“N 进制转 10 进制”的逻辑，该题不难解。 参考面试题题解 大致都是一些不是特别难的手写代码的题目，更多手写代码的题目可参考 手写代码系列 6. 为什么提前调用 let 声明的变量会报错这个得回答到 let 会创建一个局部块，因为从 ES6 之后就有了块级作用域了，作用域外的变量无法调用到作用域内的变量，因此在 JS 第一次解析代码的时候，这东西不会弄到全局环境中，在它之前调用时，通过 RHS 查询就无法查到，于是就报错了。 可参阅 let 和 var 的区别 Node这部分我也遇到过一些，解释过只会很浅的使用，然后面到的问题主要为一下两个。Node 深挖也会挖出很多内容，比如：V8 和 Chrome 浏览器内核的 V8 有什么区别，事件循环的区别等等，最好准备准备。 1. 解释一下，什么是 Event Loop其实这个只要答道 “异步非阻塞模式” 以及解释一下 宏任务、微任务、同步任务 的个人理解基本上能过，当然越标准越好，因为这个学习 Node 的最基本的知识。 可参阅 带你彻底弄懂 Event Loop JavaScript中的Event Loop（事件循环）机制 2. npm 的理解该部分主要还是对 node_modules 的一些变化和问题进行考察，以及 lock 文件的理解，解释清除这个就没什么问题了。 可参阅 npm install 原理分析 3. npm 发布时版本号的问题emmm，这部分解释一下项目不同程度的修改该怎么升级版本号即可，举个例子： 项目从 v1.0.0 升级版本 改了个组件的小 bug： v1.0.1 更新了一个组件的函数，新增了一些组件： v1.1.0 组件库从支持 Vue 变为支持 React 了： v2.0.0 算法题因为前端对算法不是很严，除了头条有些神经质以外，其余的只需要稍微刷刷 leetcode 上的简单算法题（主要刷刷 二叉树 的题），基本上没问题。 算法题的重点基本上在二叉树上，因为可以用数组来模拟，然后就是堆和动态规划。 推荐刷题思路为： 基础排序算法 数组相关算法 二叉树的算法题 堆和动态规划 一般刷简单的就行了。 leetcode 传送门 HTTPHTTP 方便主要还是考察状态码、缓存和浏览器的渲染流程，稍微深一点的就是如为什么 TCP 慢、DNS 解析相关、首部压缩算法 等。 浏览器渲染（从输入url到页面渲染的完成过程）这个题其实问的挺多的，简单描述一下整体流程： DNS 解析域名得到 IP；（浏览器缓存 -&gt; 本地缓存 -&gt; DNS服务器 -&gt; 根服务器） 拿到服务器地址，与服务器建立连接，3 次握手； 获取并解析 html 文件，开始构建 CSSTree 和 DomTree； 合成 RenderTree 并在页面布局； 页面绘制； 离开页面，4 次挥手 这里面也会细扣一些内容，比如DNS 怎么解析的、3 次握手 和 4 次挥手分别做了什么 304 与缓存该部分网上查阅资料即可。 参阅 https://juejin.im/post/6844903512946507790 HTTP、HTTPS、HTTP2、HTTP3 和 WebSocket这些知识基本上是一套走的，多查阅文章即可。因为我掌握的也不是很多，仅是浅浅谈了一些内容以及部分实现，这些网上基本都能找到，想和面试官谈笑风生的话最好还是研究研究。 我遇到的问题包括： HTTP 和 HTTPS 有什么不同 HTTP2 有哪些新特性，与 HTTP1.1 相比有什么优势 HTTP2 的加密流程能描述一下吗 HTTP3 你有了解吗，与 HTTP2 相比有什么优势 卡尼项目中有用到 Websocket，你能说说它有什么好处吗 参阅 HTTP2 与 HTTP3 新特性一览 HTTP2 详解 巩固你的 HTTP 知识体系 Nginx 正向代理和反向代理 负载均衡和实现方式，优缺点 gzip 首部压缩 Webpack这部分内容在前端面试时也是加分项，开发点基础插件，了解下 Webpack 编译后的内容和源码相关的内容，开发点简单的包，基础扎实巩固。 更多 Webpack问题可参阅：关于webpack的面试题 1. webpack 主要是用来解决什么问题的核心思路： JS 的模块化开发 打包构建为一个整体 其实抓住“模块化”来回答即可，可以简单说一下 webpack 的由来原因，但主要还是因为 JS 的模块化开发方式。 2. plugins 和 loader 的区别 Loader: 主要用于使 Webpack 将非 JS 文件转化为 JS 文件 Plugins: 主要用于解决 Loader 无法解决的事，用于辅助，如：压缩、打包 等 3. Webpack 的 Loader 和 Plugins 的开发思想这部分我没回答上来，没开发过，可参考一下对应文章。 4. 了解过 Webpack 原理吗，能简单介绍一下吗同样没回答上来。 5. 做过哪些 Webpack 的性能优化因为了解过 Vue Plugins 部分的编写，也做过一点点 DllPlugins 的编写，将这些给面试官说了 DllPlugins 预打包 部分 ES6 模块的 TreeShaking 分析包体积，然后部分插件按需引用 6. 有做过包的开发吗，能描述一下开发思路介绍了一下当初写 npm 包时的一些思想： Library 打包和按需打包 类似 Element-ui 的项目结构的划分 文档的一些设计和建设思路 组件的一些编写思路 TypeScript这部分也是加分项，以前有过 Java 基础这部分应该问题不大，熟读官网，学习下装饰器的编写，一般也没什么太难的内容。 更多内容可以参阅 Typescript 面试问题 1. interface 和 type 有什么区别，它们能互相继承吗 interface 不能声明基本类型，type 可以； type 无法 extends，但能通过交叉继承（&amp;）来实现继承； interface 能够合并声明； interface 能 extends type，type 也能交叉继承（&amp;） interface，它们也能自己继承自己。 可参阅： interface VS type 2. namespace 和 module 区别简单来说，namespace 相当于包名，module 相当于文件，官方不推荐用 module 了。主要解决多文件命名冲突问题，目前我在项目内仅 vuex 部分使用，一处声明，多处使用。 3. TypeScript 优缺点这部分仁者见仁，智者见智，我总结的一些： 前期开发时间成本大，后期维护方便 合作开发方便，规范性强 组件潜在问题前期容易暴露出来，隐藏错误少 装饰器开发模式很便捷 这里不会装饰器的尽量不要谈这方面的内容，但这部分算是 TS 的重点部分，建议补补。 框架相关框架因为我这边是学习 Vue 相关的内容，了解部分源码的知识，这部分深挖一点准没错，基本问题网上能找到，这里就列举一些： Vue 的 数组 是怎么监听变化的？（原生方法重写） 简单的 Observer 函数能实现一个吗？（Object.defineProperty） 如果不用 Vue 组件能实现 EventBus 吗？（可以，观察者模式） Vue 组件通讯的方式？（$emit、prop、provider、eventbus、vuex 等） watch 和 computed 区别？（是否偏计算属性，是否缓存值） Vue 生命周期是什么？（官网图有） Vue3 有哪些新特性？（proxy、函数式风格等） Diff 算法？（动态规划找节点树、patch 补丁判断是否更新节点、更新） 项目相关其实面试题在整个面试环节中仅仅在一面碰的较多，二面会稍微提到一部分（一般是算法），后面基本上都是问项目相关的内容了。这部分不太好描述，大概的一些问题如下： 简单解释一下你的项目？（描述需要精简、流畅、项目间是否有关联、项目开发的目的） 项目中遇到最难的问题，你是怎么解决的？（有把握的，最好是可以体现自身在解决问题时能凸显价值的） 你对 xxx 项目的理解，怎么设计的？（最好近期开发的项目拿来说，比较熟，需要熟知整体流畅） 开发哪个项目时是你感觉收获最大的，为什么？（能凸显个人能力的项目） 你为什么要换工作？（自己思考清除原因，一定得清晰） 你有什么个人的职业规划吗？（自己之后的发展思路，提前想明白） 你觉得你的优势是什么？（很关键，千万不要说什么有潜力之类的话，基本差评，得凸显自己的价值：能独立开发项目、能带团队、善于沟通等等） 当然面试时结结巴巴的就不要说自己善于沟通了……","categories":[{"name":"Other","slug":"Other","permalink":"https://monocy.site/categories/Other/"}],"tags":[]},{"title":"记一次任务调度算法题","slug":"记一次任务调度算法题","date":"2020-09-22T08:32:49.000Z","updated":"2020-09-30T09:38:10.446Z","comments":true,"path":"2020/09/22/记一次任务调度算法题/","link":"","permalink":"https://monocy.site/2020/09/22/记一次任务调度算法题/","excerpt":"前言ES6 的 Promise 可以拓展很多比较好的调度算法，比如最近碰到的一个让人眼前一亮的简单任务调度实现的题目，这里我记录一下我的思考和实现。","text":"前言ES6 的 Promise 可以拓展很多比较好的调度算法，比如最近碰到的一个让人眼前一亮的简单任务调度实现的题目，这里我记录一下我的思考和实现。 题目12345678910111213141516171819202122232425class Scheduler &#123; add(promiseCreator) &#123; // 代码部分 &#125;&#125;const scheduler = new Scheduler();function addTask(time, order) &#123; scheduler.add(() =&gt; &#123; return new Promise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('order', order); res(); &#125;, time); &#125;); &#125;)&#125;;addTask(1000, '1');addTask(500, '2');addTask(300, '3');addTask(400, '4');// 结果要求 order 为： 2、3、1、4 思路&amp;题解 分析： 从结果来看，因为每次只能执行俩异步函数，因此数组处理逻辑大致为“队列” 从 scheduler 的链式调用可发现每次返回的都是 Promise 函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748(function () &#123; class Scheduler &#123; constructor() &#123; this.eventList = []; this.used = 0; this.currentPos = 0; &#125; add(promiseCreator) &#123; this.eventList.push(promiseCreator); // 执行任务 return Promise.resolve(this.excute()); &#125; excute() &#123; if (this.used &lt; 2 &amp;&amp; this.currentPos &lt; this.eventList.length) &#123; this.used++; const currentFunc = this.eventList[this.currentPos++]; return Promise.resolve(currentFunc()).then(() =&gt; &#123; this.used--; // 每次执行完查看是否继续执行后面的内容 this.excute(); &#125;); &#125; &#125; &#125; const scheduler = new Scheduler(); function addTask(time, order) &#123; scheduler.add(() =&gt; &#123; return new Promise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('order', order); res(); &#125;, time); &#125;); &#125;) &#125;; addTask(1000, '1'); addTask(500, '2'); addTask(300, '3'); addTask(400, '4');&#125;)(); 难度提升先前的打印都是在 addTask 函数内部的，假如没有这个 addTask 函数，而且获取的函数结果需要在 then 链中打印出来，这个改怎么重写这个类。题解如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061(function () &#123; class Scheduler &#123; constructor(maxUsed = 2) &#123; this.eventList = []; this.used = 0; this.maxUsed = maxUsed; this.currentPos = 0; &#125; add(timeout, val) &#123; const excute = () =&gt; &#123; if ( this.currentPos &lt; this.eventList.length &amp;&amp; this.used &lt; this.maxUsed ) &#123; const tarData = this.eventList[this.currentPos++]; const &#123; res, rej, timeout, val &#125; = tarData; this.used++; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(val); &#125;, timeout); &#125;) .then(res, rej) .finally(() =&gt; &#123; this.used--; excute(); &#125;); &#125; &#125;; // 执行任务 return new Promise((res, rej) =&gt; &#123; this.eventList.push(&#123; res, rej, timeout, val, &#125;); return excute(); &#125;); &#125; &#125; const scheduler = new Scheduler(); scheduler.add(1000, '1').then((res) =&gt; &#123; console.log(res); &#125;); scheduler.add(500, '2').then((res) =&gt; &#123; console.log(res); &#125;); scheduler.add(300, '3').then((res) =&gt; &#123; console.log(res); &#125;); scheduler.add(400, '4').then((res) =&gt; &#123; console.log(res); &#125;);&#125;)(); 小结其实题目考察的是对于 Promise 函数以及链式调用的理解，了解过 Promise 实现机制其实在琢磨此题时还是有那么一点头痛，只要关键的类递归函数部分琢磨清楚了，整体也不是很难。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"变量提升完全解读","slug":"变量提升完全解读","date":"2020-09-21T11:58:00.000Z","updated":"2020-09-21T13:27:34.883Z","comments":true,"path":"2020/09/21/变量提升完全解读/","link":"","permalink":"https://monocy.site/2020/09/21/变量提升完全解读/","excerpt":"前言变量提升这个问题不论是以前还是现在，总是作为面试常考题型出现，因为 ES6 的新特性的推行，对于 var 所导致的变量提升问题在项目中就很少存在了。但是为什么 let、const 能解决这个变量提升的问题呢，静下心来品一品，其实还是有很多内容可以学到的。","text":"前言变量提升这个问题不论是以前还是现在，总是作为面试常考题型出现，因为 ES6 的新特性的推行，对于 var 所导致的变量提升问题在项目中就很少存在了。但是为什么 let、const 能解决这个变量提升的问题呢，静下心来品一品，其实还是有很多内容可以学到的。 变量提升的本质首先为什么会有变量提升？先前在深入了解 this一文中有简单提到过：“JS 因为是运行时编译的，会粗略的提取变量声明，因此会有变量提升”。在变量提升后，当程序执行到对应行在进行赋值操作，因此大概流出如下： 变量声明提升 函数声明提升（已经指向了函数声明的内存块） 变量赋值 这也就解释了为什么函数和变量一起提升，但是在后面使用的时候，结果都会是函数。 小结：变量声明的提升优于函数声明的提升。 变量提升的位置其实变量提升的问题除了提升的顺序外，另一个就是提升的位置了。其实这个只需要记住 JS 中有哪些作用域了。在 ES6 之前，JS 的作用域仅有两个： 函数作用域 全局作用域 在引入 ES6 后有新增了一个 块级作用域。在变量提升时，其声明仅仅能够提升到当前作用域的最顶端（具体原因可查阅第二篇参考文章）。所以在确定了作用域的情况下，结合提升的顺序，我们就能很明确的了解到变量的顺序了。 小结：JS 仅有 全局作用域、函数作用域 和 块级作用域。 小试牛刀在作用域和变量提升顺序都清楚的情况下，跟着思路过一道题加深一下印象： 12345678910111213141516171819202122232425262728console.log(bb); // function bb() &#123; console.log('change'); &#125;var aa = 123;var bb = 'string';let cc = &#123;&#125;;function bb() &#123; console.log('change');&#125;(function () &#123; var ee = dd = []; cc = 'new String';&#125;)();console.log(aa); // 123console.log(bb); // 'string'var aa;var bb = function() &#123; console.log('who am I');&#125;console.log(aa); // 123console.log(bb); // \"function bb() &#123; console.log('who am I'); &#125;\"console.log(cc); // 'new String'console.log(dd); // []console.log(ee); // Error: ee is not defined 这里又几个注意的小细节： JS 赋值操作为“自右向左”进行的 JS 取值操作取最近的一次赋值的值 未声明的变量会报错，而非 undefined 参考一下处理后的结构（建议开两个页面分屏看）： 123456789101112131415161718192021222324252627282930313233343536373839var aa = undefined;var bb = undefined;let cc; // 仅声明，产生临时索取（取不到值）function bb() &#123; console.log('change');&#125;console.log(bb); // function bb() &#123; console.log('change'); &#125;aa = 123;bb = 'string';cc = &#123;&#125;;// console.log(dd) // Error: ee is not defined(function () &#123; var ee = undefined; dd; // 无声明默认挂在到 window 了（此时才挂载上 window 的，前面拿不到） dd = []; ee = dd; // 能拿到上级作用域中的 cc 变量 cc = 'new String';&#125;)();console.log(aa); // 123console.log(bb); // 'string'bb = function() &#123; console.log('who am I');&#125;console.log(aa); // 123console.log(bb); // \"function bb() &#123; console.log('who am I'); &#125;\"console.log(cc); // 'new String'console.log(dd); // []console.log(ee); // Error: ee is not defined 总结遇到变量提升相关问题时，只需关注一下几点基本都能解答上来： 变量所在作用域位置； 区分函数提升和变量提升，取 console 时最近的一次赋值位置； 小心全局变量声明的陷阱； 无变量声明的情况下，打印会报错； 参考文章 js 为什么会进行变量提升（词法分析） JS 变量的执行环境和生命周期","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"Mac 环境配置","slug":"Mac-环境配置","date":"2020-08-26T08:20:44.000Z","updated":"2021-03-17T06:00:19.352Z","comments":true,"path":"2020/08/26/Mac-环境配置/","link":"","permalink":"https://monocy.site/2020/08/26/Mac-环境配置/","excerpt":"前言最近新换了一台 Mac（原来公司的 Mac 敲多了胳膊酸），因此又要重新配置 Mac 环境，想了想如果之后 Mac 又换了一台，那不又双叒叕得重新翻阅文档再配置一遍 Mac 吗。为了省去之后再次查资料的麻烦，这里写一篇记录文。","text":"前言最近新换了一台 Mac（原来公司的 Mac 敲多了胳膊酸），因此又要重新配置 Mac 环境，想了想如果之后 Mac 又换了一台，那不又双叒叕得重新翻阅文档再配置一遍 Mac 吗。为了省去之后再次查资料的麻烦，这里写一篇记录文。 安装 HomebrewHomebrew 可以说是每台 Mac 必备的包管理工具了。因为官方的源经常连接不上，因此可用镜像安装方式来安装： 12# 中科大的源/usr/bin/ruby -e \"$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)\" 如果中间 homebrew-core 安装不上，则先终止安装，然后执行下述操作： 12345678# 进入安装目录cd \"$(brew --repo)/Library/Taps/\"# 创建 homebrew 目录mkdir homebrew &amp;&amp; cd homebrew# 克隆 homebrew-core 仓库git clone git://mirrors.ustc.edu.cn/homebrew-core.git 克隆完成后执行： 1brew update 如果想换源可查看参考文档或自行查询相关文档。 安装 gitgit 在大多数情况下都会用到，因此优先安装。 12345678brew install git# 配置 gitgit config --global user.name \"你的名字\"git config --global user.email \"你的邮箱\"# 生成 ssh key（一直回车即可）ssh-keygen -t rsa -C \"你的邮箱\" 配置 vim因为后续的配置需要用到 vim，因此我们先配置一下 vim，让编辑得更舒服。 创建一个 .vimrc 文件，在内部加上如下内容： 123456789101112131415syntax on \" 设置高亮set number \" 默认显示行号set ruler \" 显示标尺set expandtab \" 空格代替 Tabset tabstop=2 \" Tab 键宽为 2set nobackup \" 不生成临时文件set noeb \" 在处理未保存或只读文件的时候，弹出确认set scrolloff=3 \" 光标移动到buffer的顶部和底部时保持3行距离set mouse=a \" 内部滚动\" 语言设置set langmenu=zh_CN.UTF-8set helplang=cn\" 主题设置set background=darkcolorscheme solarized 主题部分需要安装对应的包，操作如下（如果有则忽略）： 123456789# 创建 .vim/colors 文件夹（有则跳过）mkdir -p ~/.vim/colors# 进入文件夹cd ~/.vim/colors# 克隆主题并拷贝出来git clone git://github.com/altercation/vim-colors-solarized.gitcp vim-colors-solarized/colors/solarized.vim ~/.vim/colors/# 删除仓库rm -rf vim-colors-solarized 安装 oh-my-zsh同样 oh-my-zsh 官方版容易挂，这里仍然记录的是镜像版的安装方式： 12345# 切换 shell 为 zsh（重新打开后生效）chsh -s /bin/zsh# 下载 oh-my-zsh 镜像sh -c \"$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)\" 默认的 zsh 貌似仅有 git 插件，主题也不怎么好看，这里先改改 ~/.zshrc： 123456789101112# 创建一个 .bashrc 文件touch ~/.bashrc# 更改 ~/.zshrc## 主题部分设置ZSH_THEME=\"pygmalion\"## 插件部分的设置plugins=(git zsh-syntax-highlighting zsh-autosuggestions)## 最后一行添加上（附带启动执行的文件）source ~/.bashrc 配置完了，然后是下载插件 12345# 进入自定义插件目录cd ~/.oh-my-zsh/custom/plugins# 拷贝插件git clone https://github.com/zsh-users/zsh-autosuggestions.gitgit clone https://github.com/zsh-users/zsh-syntax-highlighting.git 配置 iterm下载 solarized 主题，下载链接，这里我创建了一个 Custom 文件夹，解压缩在里边，然后进入 oxs-terminal.app-colors-solarized 文件夹，安装对应的俩 .terminal 主题（双击运行即可）。 安装完后下载的主题可以删掉了 打开 iTerm2 -&gt; Preferences，分别配置三处地方（Colors、Text、Window） Colors 部分：配置主题色为 solarized dark Text 部分：设置字体 Font 大小 Window 部分：设置 Transparent 背景透明度 一般设置前俩就够了，Window 主要配置 transparence 来控制背景透明度。 配置 nvm配置 node 环境这里选用 nvm 来控制，这样方便 node 版本快速切换，Mac 的安装方式很简单： 1brew install nvm nvm 安装完后，通过 nvm ls-remote v12 来看云上 12 版本 node 有哪些，安装最新维护版本的 node 即可（其余版本同理）： 12345678# 安装 nodenvm install v12.18.3# 取个别名方便查找nvm alias node12 v12.18.3# 使用 node12nvm use node12 此外，部分全局安装的包这里列举一下： yarn（通过 yarn 安装全局包就不用担心 node 切换后找不到包） nrm（换 npm 源比较方便） pm2（守护进程） 安装 nginx使用万能的 brew 安装 12345# 安装 nginxbrew install nginx# 后台启动brew services start nginx 附带一些 nginx 的默认配置地址： 123456# brew 安装 nginx 的路径/usr/local/Cellar/nginx/1.6.2# 配置文件路径/usr/local/etc/nginx/nginx.conf# 服务器默认路径/usr/local/var/www 因为层级比较深，建议还是用 ln -s 软链出来，统一管理会更为方便 常用工具推荐除了环境外我们还需要一些办公工具，这里列举一些： Vscode Numi（自然语言计算器） Chrome Navicat Agenda（我比较喜欢的 todoList 软件） WPS XMind Transmit（连接服务器的文件传输工具） Alfred4（高配聚焦） Postman Typora（markdown 写作工具） Github Desctop rdm（redis 连接工具） StarUML（流程图） Omniplan（排期工具） OneNote 或 有道云笔记 V2Rayx（科学上网需要） Scroll Reverser（外接鼠标滚轮方向配置） Axure（看产品原型图必备） 配置 VSCode通过 Sync 同步我个人的配置，这里记录 Sync 的配置，后续只需通过 gist 拉取即可 Command/Ctrl + Shift + P 调出控制台； 输入 Sync，选择 Sync 打开设置； 添加 GIST ID 为：0e7fde6e07ce3d8a9947880187fe5a3f 勾选 “强制下载” 和 “同步扩展” 选项（如果下载不下来则将“删除扩展”也选上）； Shift + Option + D 下载插件即可； 下载完成之后可讲 Sync 同步配置给关闭，然后根据自己喜好更新 settings.json 的配置文件和安装自己喜欢的插件。 参考文章 Mac 下镜像安装 Homebrew 很好很强大的 vimrc（带注释版） 给 vim 配置 solarized 主题颜色 Oh-My-Zsh 的配置与使用 mac 下 iterm 配色、半透明与样式设置","categories":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/categories/环境/"}],"tags":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/tags/环境/"}]},{"title":"背景水印与 MutationObserver","slug":"背景水印与-MutationObserver","date":"2020-08-05T03:23:28.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2020/08/05/背景水印与-MutationObserver/","link":"","permalink":"https://monocy.site/2020/08/05/背景水印与-MutationObserver/","excerpt":"前言因为项目需要配置背景水印，仅呈现背景水印这并没有什么难度，但是问题是当背景水印部分的代码通过什么原因被干掉了（例如：打开控制台，给背景水印部分代码加上 display: none），需要检测这个变化重新将水印更新会原状，emmmm，这就有的折腾了。于是乎就发现了 MutationObserver 方法，在此简单笔记一下。","text":"前言因为项目需要配置背景水印，仅呈现背景水印这并没有什么难度，但是问题是当背景水印部分的代码通过什么原因被干掉了（例如：打开控制台，给背景水印部分代码加上 display: none），需要检测这个变化重新将水印更新会原状，emmmm，这就有的折腾了。于是乎就发现了 MutationObserver 方法，在此简单笔记一下。 MutationObserver 作用简单来说，该方法就是用来监听 Dom 变化的，Dom 的任何微小变动它都能接受得到。引用一下阮老师对 Mutation Observer 的特点的描述： 它等待所有脚本任务完成后，才会运行（即异步触发方式） 它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。 它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。 因此在父级元素上挂在一个 MutationObserver 事件监听方法，不就可以做到对背景水印元素变动的监听了么！ 背景水印的解决思路由于是公司内部代码，这里就不做粘贴了，仅说明一下水印的解决思路。 检测 DOM 上是否存在水印节点，不存在则新增水印节点 为水印节点新增 Mutation Observer 方法，观察其对应属性变化，更新监听 配合 Vue 的逻辑则是编写一个 vue 的全局指令，做到动态更新即可。 MutationObserver 示例该例子只是对 Mutation Observer API 的学习例子，仅供参考。 传送门 参考文章 MDN MutationObserver Mutation Observer API MutationObserver 与 ResizeObserver","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"iptables 端口转发配置","slug":"iptables-端口转发配置","date":"2020-07-14T02:27:42.000Z","updated":"2020-08-17T06:25:42.066Z","comments":true,"path":"2020/07/14/iptables-端口转发配置/","link":"","permalink":"https://monocy.site/2020/07/14/iptables-端口转发配置/","excerpt":"前言先前转载了一篇 iptables 的使用和配置的文章，但是凡事都得自己动手学习一下才能深入了解，因此本篇用来记录动手操作了一番后的一些配置心得。当然建议大家了解的时候读一读参考文章，特别是 iptables 入门指南 和 iptables 详解，能让你对 iptables 有更深入的理解。","text":"前言先前转载了一篇 iptables 的使用和配置的文章，但是凡事都得自己动手学习一下才能深入了解，因此本篇用来记录动手操作了一番后的一些配置心得。当然建议大家了解的时候读一读参考文章，特别是 iptables 入门指南 和 iptables 详解，能让你对 iptables 有更深入的理解。 查看本地规则root 用户下 1iptables -nL -t nat --line-number 显示结果如下： 123456789101112131415[root@/]# iptables -nL -t natChain PREROUTING (policy ACCEPT)target prot opt source destinationREDIRECT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 redir ports 8020Chain INPUT (policy ACCEPT)target prot opt source destinationChain OUTPUT (policy ACCEPT)target prot opt source destinationREDIRECT tcp -- 0.0.0.0/0 127.0.0.1 tcp dpt:80 redir ports 8020REDIRECT tcp -- 0.0.0.0/0 &lt;本机IP&gt; tcp dpt:80 redir ports 8020Chain POSTROUTING (policy ACCEPT)target prot opt source destination 其中 Chain PREROUTING (policy ACCEPT) 指的是有外部访问本机的 80 端口时，其会转发到 8020 端口；Chain OUTPUT (policy ACCEPT) 指的是内部机器地址输出时，当监测到目标地址为 127.0.0.1 / &lt;本机IP&gt; 时，其默认的 80 端口会转发到 8020 端口，从而实现 80 -&gt; 8020 端口的转发。 添加转发规则外部访问端口转发iptables 转发端口时，其使用的并非默认的 filter，因此需要 -t 制定为 nat，此外上面有说到，外部访问时会经由 PREROUTING，因此需要对此规则做配置，指令如下： 1iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8020 -t： 指定表为 nat 表（默认为 filter 表） -A： 指定 nat 表中的三项规则中的哪一项，分别为： OUTPUT、PREROUTING、POSTEROUTING -p： 指定使用的协议 --dport: 指定目标端口 -j： 指定针对本机做重定向操作（DROP、ACCEPT、REDIRECT 等） --to-port： 重定向的端口 补充，不同表的操作链 表 INPUT FORWARD OUTPUT PREROUTING POSTEROUTING Filter true true true false false Nat false false true true true Mangle true true true true true 内部访问端口转发仅外部转发其实是不够的，对于内部地址访问时仍需要进行一次转发才能满足内外一致的情况，与上指令类似： 1iptables -t nat -A OUTPUT -p tcp -d 127.0.0.1 --dport 80 -j REDIRECT --to-port 8020 -d： 指定目的地址地址（与之相反的 -s 为指定源地址） 删除转发规则删除指令如下： 1iptables - t nat -D OUTPUT &lt;number&gt; 验证规则生效telnet ip port： 查看某一个机器上的某一个端口是否可以访问，如： 1telnet 127.0.0.1 8020 配置开机启动结合 iptables-save 和 iptables-reload 使用 1iptables-save &gt; /root/iptables.bk 配置启动脚本 123456789101112# 配置启动脚本vim /root/iptables-preload#### 将如下内容贴入其中并保存#!/bin/bash/sbin/iptables-restore &lt; /root/iptables.up.rules####chmod +x /root/iptables-preload#### 编辑 /etc/rc.local，添加如下内容/root/iptables-preload 参考文章 iptables 工具命令 iptables 详解 Linux之iptables端口转发（外网访问内网） iptables 入门指南","categories":[{"name":"Linux","slug":"Linux","permalink":"https://monocy.site/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://monocy.site/tags/Linux/"}]},{"title":"Linux 防火墙的使用和配置（转载）","slug":"Linux-防火墙的使用和配置（转载）","date":"2020-07-09T06:54:52.000Z","updated":"2021-06-30T15:25:42.952Z","comments":true,"path":"2020/07/09/Linux-防火墙的使用和配置（转载）/","link":"","permalink":"https://monocy.site/2020/07/09/Linux-防火墙的使用和配置（转载）/","excerpt":"前言文章转载自 linux 防火墙使用以及配置，使用方法大同小异，在此转载一篇做个笔记。","text":"前言文章转载自 linux 防火墙使用以及配置，使用方法大同小异，在此转载一篇做个笔记。 Centos 7 firewall ：1. firewalld 的基本使用 启动： systemctl start firewalld 关闭： systemctl stop firewalld 查看状态： systemctl status firewalld 开机禁用 ： systemctl disable firewalld 开机启用 ： systemctl enable firewalld 2. systemctl 是 CentOS7 的服务管理工具中主要的工具，它融合之前 service 和 chkconfig 的功能于一体。 启动一个服务：systemctl start firewalld.service 关闭一个服务：systemctl stop firewalld.service 重启一个服务：systemctl restart firewalld.service 显示一个服务的状态：systemctl status firewalld.service 在开机时启用一个服务：systemctl enable firewalld.service 在开机时禁用一个服务：systemctl disable firewalld.service 查看服务是否开机启动：systemctl is-enabled firewalld.service 查看已启动的服务列表：systemctl list-unit-files|grep enabled 查看启动失败的服务列表：systemctl --failed 3. 配置 firewalld-cmd 查看版本：firewall-cmd --version 查看帮助：firewall-cmd --help 显示状态：firewall-cmd --state 查看所有打开的端口：firewall-cmd --zone=public --list-ports 更新防火墙规则：firewall-cmd --reload 查看区域信息： firewall-cmd --get-active-zones 查看指定接口所属区域：firewall-cmd --get-zone-of-interface=eth0 拒绝所有包：firewall-cmd --panic-on 取消拒绝状态：firewall-cmd --panic-off 查看是否拒绝：firewall-cmd --query-panic 那怎么开启一个端口呢？ 添加： firewall-cmd --zone=public --add-port=80/tcp --permanent （–permanent 永久生效，没有此参数重启后失效） 重新载入：firewall-cmd --reload 查看：firewall-cmd --zone= public --query-port=80/tcp 删除：firewall-cmd --zone= public --remove-port=80/tcp --permanent 调整默认策略（默认拒绝所有访问，改成允许所有访问）： 12firewall-cmd --permanent --zone=public --set-target=ACCEPTfirewall-cmd --reload 对某个 IP 开放多个端口： 12firewall-cmd --permanent --add-rich-rule=\"rule family=\"ipv4\" source address=\"10.159.60.29\" port protocol=\"tcp\" port=\"1:65535\" accept\"firewall-cmd --reload Centos 6 iptables：1. iptables 的基本使用 启动：service iptables start 关闭：service iptables stop 查看状态：service iptables status 开机禁用：chkconfig iptables off 开机启用：chkconfig iptables on 2. 开放指定的端口-A 和 -I 参数分别为添加到规则末尾和规则最前面。 允许本地回环接口(即运行本机访问本机)：iptables -A INPUT -i lo -j ACCEPT 允许已建立的或相关连的通行：iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT 允许所有本机向外的访问： 12iptables -P INPUT ACCEPTiptables -A OUTPUT -j ACCEPT 允许访问 22 端口： 123# -s 后可以跟 IP 段或指定 IP 地址iptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A INPUT -p tcp -s 10.159.1.0/24 --dport 22 -j ACCEPT 允许访问 80 端口：iptables -A INPUT -p tcp --dport 80 -j ACCEPT 允许 FTP 服务的 21 和 20 端口： 123iptables -A INPUT -p tcp --dport 21 -j ACCEPTiptables -A INPUT -p tcp --dport 20 -j ACCEPT# 如果有其他端口的话，规则也类似，稍微修改上述语句就行 允许 ping：iptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT 禁止其他未允许的规则访问： 123# 注：如果 22 端口未加入允许规则，SSH 链接会直接断开。iptables -A INPUT -j REJECTiptables -A FORWARD -j REJECT 3. 屏蔽 IP 注：如果只是想屏蔽 IP 的话，上述 “2. 开放指定的端口” 可以直接跳过。 屏蔽单个 IP 的命令是：iptables -I INPUT -s 123.45.6.7 -j DROP 封整个段(即从 123.0.0.1 到 123.255.255.254)的命令：iptables -I INPUT -s 123.0.0.0/8 -j DROP 封 IP 段(即从 123.45.0.1 到 123.45.255.254)的命令：iptables -I INPUT -s 124.45.0.0/16 -j DROP 封 IP 段(即从 123.45.6.1 到 123.45.6.254)的命令是：iptables -I INPUT -s 123.45.6.0/24 -j DROP 4. iptables 的规则查看已添加的规则iptables -L -n 只显示 IP 地址和端口号，不将 IP 解析为域名 删除已添加的 iptables 的规则将所有 iptables 以序号标记显示，执行： iptables -L -n --line-numbers 比如要删除 INPUT 里序号为 8 的规则，执行： iptables -D INPUT 8 5. 可以直接编辑配置文件，添加 iptables 防火墙规则：iptables 的配置文件为 /etc/sysconfig/iptables 编辑配置文件： vi /etc/sysconfig/iptables 文件中的配置规则与通过的 iptables 命令配置，语法相似： 如，通过 iptables 的命令配置，允许访问 80 端口： iptables -A INPUT -p tcp --dport 80 -j ACCEPT 那么，在文件中配置，只需要去掉句首的 iptables，添加如下内容： -A INPUT -p tcp --dport 80 -j ACCEPT 保存退出。 有两种方式添加规则 iptables -A 和iptables -I iptables -A 添加的规则是添加在最后面。如针对 INPUT 链增加一条规则，接收从 eth0 口进入且源地址为 192.168.0.0/16 网段发往本机的数据。 iptables -A INPUT -i eth0 -s 192.168.0.0/16 -j ACCEPT iptables -I 添加的规则默认添加至第一条。 如果要指定插入规则的位置，则使用 iptables -I 时指定位置序号即可。 删除规则 如果删除指定则，使用 iptables -D 命令，命令后可接序号。效果请对比上图。 或 iptables -D 接详细定义； 如果想把所有规则都清除掉，可使用 iptables -F。 备份 iptabes rules 使用 iptables-save 命令，如： iptables-save &gt; /etc/sysconfig/iptables.save 恢复 iptables rules 使用 iptables 命令，如： iptables-restore &lt; /etc/sysconfig/iptables.save iptables 配置保存 以上做的配置修改，在设备重启后，配置将丢失。可使用 service iptables save 进行保存。 重启 iptables 的服务使其生效： service iptables save 添加规则后保存重启生效。 service iptables restart 后记关于更多的 iptables 的使用方法可以执行： iptables --help","categories":[{"name":"Linux","slug":"Linux","permalink":"https://monocy.site/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://monocy.site/tags/Linux/"}]},{"title":"Mysql 的小技巧","slug":"Mysql-的小技巧","date":"2020-06-09T02:50:48.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2020/06/09/Mysql-的小技巧/","link":"","permalink":"https://monocy.site/2020/06/09/Mysql-的小技巧/","excerpt":"前言近期开始学习 Node 和 MySQL 相关的知识了，项目也开始从纯前端转向了“全栈”（刚刚起步）。起初还是挺痛苦的，特别是数据库设计和查询，大学学习的东西基本都还回去了，不过在一次次问题中也渐渐总结了些经验，这里就记录一下“初学者”难免会遇到的一些问题。","text":"前言近期开始学习 Node 和 MySQL 相关的知识了，项目也开始从纯前端转向了“全栈”（刚刚起步）。起初还是挺痛苦的，特别是数据库设计和查询，大学学习的东西基本都还回去了，不过在一次次问题中也渐渐总结了些经验，这里就记录一下“初学者”难免会遇到的一些问题。 设置默认值其实先处理模型，然后再根据模型建库和表，基本上没什么太大问题（毕竟都是可视化操作，不写 SQL 代码生成了）。不过，在可视化建表的过程中，有时候为了图快往往容易忽视一些配置，如： int 的默认值部分配置 datetime 默认值部分配置 根据情况配置对应默认值可以减少代码内的部分重复操作，如： 配置 create_time 默认值为 CURRENT_TIMESTAMP， 那么每次新增时就可以不用带上时间戳了。 配置 modify_time 默认值勾选上 “根据当前时间戳更新”，那么每次编辑时可以不用去配置修改时间，对于重复数据操作会比较方便。 日期更新当然，也有情况是需要在进行某些操作后，更新其它数据的一些信息，这之中比较麻烦的是“日期”相关的操作，在网上也没找到比较合适的博文来解决。这里在翻查了 Mysql 的一些函数，顺利解决了这么一个问题，修改数据时间的 sql 为： 123update xxx_tableset xxx_time = CURRENT_TIMESTAMP()where xxx_id = 1 配合 mysql 的时间函数能比较方便的处理时间相关的操作。 ALTER 和 UPDATE 区别最开始写 sql 时，总是习惯性的使用 ALTER，毕竟是 ALTER 是修改的意思嘛。实际上这两个区别很大，ALTER 是修改表结构的，而 UPDATE 是更新表数据信息的。因此在平时对数据进行 CRUD 时，记住使用 UPDATE 即可。这里记录一下： ALTER、DROP 是结构上的更新和删除 UPDATE、DELETE 是数据上的更新和删除 group_concat 的长度限制在做函数聚合处理时，会经常使用到 group_concat 函数对字段进行聚合，但是 mysql 默认对聚合的字串设有长度限制（没记错的话应该是 1024）,这会导致在取值的时候对于比较长的字段就直接被截取掉了，还比较难发现问题。 对于自己的数据库，我们可以使用如下命令查看默认长度： 1show variables like 'group_concat_max_len'; 如果要修改其长度限制的话，有两种方法： （1）更改 Mysql 配置文件12# 在配置文件中加入如下内容：group_concat_max_len = 1024000 （2）在 Navicat 内运行如下命令12set global group_concat_max_len = 1024000;set session group_concat_max_len = 1024000; 注意： 该方法缺点是重启服务后设置失效 mysql 连接阻塞问题最近遇到搭建的测试环境报错，查看日志发现是 mysql 的 max_connect_errors 报错导致服务器 ip 被禁止连接 mysql。但是自己通过 navcat 能够连接上数据库，查了下原因，发现应该是中间有一版本的代码部署后，node 代码数据库连接部分配置失误，导致错误连接数过大，ip 被禁止连接 mysql 了，针对不同情况有不同的解决方法，这里都列举出来： max_connect_errors 值过小，容易出错通过 navicat 连接上 mysql，查询一下 mysql 的 max_connect_errors 属性是否值过小，较小时代码更新过程中容易产生 max_connect_errors 错误导致 mysql 连接不上，查询并更新方法如下： 12345# 查询连接数show variables like '%max_connect_errors%';# 设置连接数set global max_connect_errors = 1000; 累计连接错误数超出如果查询到的 max_connect_errors 数值已经比较大了，但是仍然报 max_connect_errors 超出的错误，那么应该是 mysql 的错误连接累计数量超出了，此时需要清空一下 max_connect_errors 数，在 navicat 的查询中输入： 1flush hosts; mysql 的 max_connect_errors 重启后变小因为 mysql 重启后会重新读取 mysql 的 conf 文件，如果不想每次重启 mysql 都需要重新更改 max_connect_errors 数值，那么需要修改一下 my.cnf 文件，将一下内容的值改改 1max_connect_errors = 1000 insert 数据重复问题在插入数据时，有时候会碰到插入的数据重复，因此可以使用 insert ... update ... 语句来进行插入/更新。 使用语法大致如下： 12345insert into target_table(unique_col1, col2, col3)values (val1, valb, valc), (val1, val2, val3)on duplicate key update col2 = values(col2), col3 = values(col3) 意思可理解为这样： 当插入的 unique_col1 值不存在时，进行新增操作，其值分别对应为：(val1、val2、val3) 当插入的 unique_col1 值存在时，进行更新操作，分别更新 col2 和 col3 的值为传入 values 组对应的 val2 和 val3 注意，唯一值重复时，后面的数据会覆盖前面的数据内容（即只取最新数据） 参考文档 MySQL 函数 MySQL中 insert into … on duplicate key update … values() 的使用笔记","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://monocy.site/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://monocy.site/tags/Mysql/"}]},{"title":"在 typescript 中添加 webworker","slug":"在-typescript-中添加-webworker","date":"2020-04-28T10:15:05.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2020/04/28/在-typescript-中添加-webworker/","link":"","permalink":"https://monocy.site/2020/04/28/在-typescript-中添加-webworker/","excerpt":"前言最近在做 Vue 项目时遇到一个读取 xlsx 文件的需求，考虑到文件可能比较大的情况，为了不让页面卡死，因此引入了 webworker，本来想着应该是很容易的事情，结果却并不是很简单，主要难在配置上，这里就记录一下配置时遇到的困难。","text":"前言最近在做 Vue 项目时遇到一个读取 xlsx 文件的需求，考虑到文件可能比较大的情况，为了不让页面卡死，因此引入了 webworker，本来想着应该是很容易的事情，结果却并不是很简单，主要难在配置上，这里就记录一下配置时遇到的困难。 配置 loader因为是 ts 写的项目，因此查阅了一下引入 webworker 需要那些插件，因此首先需要配置的是 loader 文件了。 安装 worker-loader 1yarn add worker-loader -D 在 vue.config.js 内添加如下内容： 123456789101112module.exports = &#123; chainWebpack: config =&gt; &#123; // ... // 添加 worker-loader 支持 config.module .rule('webWorker') .post() .test(/\\.worker\\.(j|t)s$/) .use('worker-loader') .loader('worker-loader'); &#125;&#125; 重启项目 worker 文件的写法在 ts 项目中，类型声明是很重要的一点，对于 worker 文件因为没有导出，在主进程中引入会很棘手，参考网上的例子，一般 worker 文件需要这么配置 12345678910111213// 文件命名： xxx.worker.ts// 创建 this 指针，或者配置 webpack 的 output 的 globalObject 属性const _self: Worker = self as any;// 监听 message 事件_self.addEventListener('message', e =&gt; &#123; // ...&#125;, false);// 监听错误事件_self.addEventListener('error', e =&gt; &#123; throw new Error(e.message);&#125;); 参考文章 Web Worker 使用教程 如何使用 JavaScript 实现纯前端读取和导出 excel 文件 webpack + typescript 环境下配置","categories":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/tags/Vue/"}]},{"title":"重习 typescript","slug":"重习-typescript","date":"2020-04-14T04:19:22.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2020/04/14/重习-typescript/","link":"","permalink":"https://monocy.site/2020/04/14/重习-typescript/","excerpt":"前言俗话说的好：“温故而知新”，以前学习 typescript 只是因为工作需要去了解，然后临时磨刀学了些皮毛，但缺没有对 typescript 有更深入的理解，因此今天趁工作之余，系统了解一下 typescript 的相关知识，为后续的学习做好铺垫。 注意：文章大部分为引用内容，且多为个人认为重要和难以记住的地方","text":"前言俗话说的好：“温故而知新”，以前学习 typescript 只是因为工作需要去了解，然后临时磨刀学了些皮毛，但缺没有对 typescript 有更深入的理解，因此今天趁工作之余，系统了解一下 typescript 的相关知识，为后续的学习做好铺垫。 注意：文章大部分为引用内容，且多为个人认为重要和难以记住的地方 了解 tsconfig 配置做 ts 项目的时候，经常会发现项目内有个 tsconfig.json 的配置文件，那么这些配置是从哪里来的呢，它具体有那些配置属性呢，这里就一点点列举： 生成配置属性12345678# 自己进入一个空项目yarn add typescript# 在 package.json 的 script 内写上：# \"tsinit\": \"tsc --init\"# 生成 tsconfig.jsonyarn tsinit 配置属性内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&#123; \"compilerOptions\": &#123; /* * Basic Options */ // \"incremental\": true, /* 是否增量编译 */ \"target\": \"es5\", /* 指定编译后的 ECMAScript 版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */ \"module\": \"commonjs\", /* 指定使用的模块标准: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */ // \"lib\": [], /* 指定编译时包含的库文件 */ // \"allowJs\": true, /* 指定是否允许编译 js 类型文件 */ // \"checkJs\": true, /* 指定是否检查和报告 js 文件中的错误，通常与 allowJS 一起使用 */ // \"jsx\": \"preserve\", /* 指定 jsx 代码用于的开发环境: 'preserve', 'react-native', or 'react' */ // \"declaration\": true, /* 是否在编译的时候生成相应的 \".d.ts\" 声明文件，但是 declaration 和 allowJs 不能同时设为 true */ // \"declarationMap\": true, /* 是否为声明文件生成 map 文件 */ // \"sourceMap\": true, /* 编译时是否生成 map 文件 */ // \"outFile\": \"./\", /* 指定输出的文件，它的值为一个文件路径名，只有设置 module 的值为 amd 和 system 模块时才支持这个配置 */ // \"outDir\": \"./\", /* 指定输出文件夹 */ // \"rootDir\": \"./\", /* 指定编译文件的根目录 */ // \"composite\": true, /* 是否编译构建引用项目 */ // \"tsBuildInfoFile\": \"./\", /* 增量编译文件的存储位置 */ // \"removeComments\": true, /* 是否将编译后的文件中的注释删掉 */ // \"noEmit\": true, /* 不生成编译文件 */ // \"importHelpers\": true, /* 指定是否引入 tslib 里的辅助工具函数 */ // \"downlevelIteration\": true, /* 当 target 为 'ES5' 或 'ES3' 时，为 'for-of', 'spread' 和 'destructuring' 中的迭代器提供完全支持 */ // \"isolatedModules\": true, /* 指定是否将每个文件作为单独的模块（与“ts.transpileModule”类似） */ /* * Strict Type-Checking Options */ \"strict\": true, /* 开启所有严格的类型检查 */ // \"noImplicitAny\": true, /* 禁止隐式的 any 类型 */ // \"strictNullChecks\": true, /* 不允许把 null、undefined 赋值给其他类型变置 */ // \"strictFunctionTypes\": true, /* 指定是否使用函数参数双向协变检查 */ // \"strictBindCallApply\": true, /* 对 bind、call 和 apply 绑定的方法的参数的检测是严格检测的 */ // \"strictPropertyInitialization\": true, /* 检查类的非 undefined 属性是否已经在构造函数里初始化，需要同时开启 strictNullChecks */ // \"noImplicitThis\": true, /* 禁止 this 的类型为 any */ // \"alwaysStrict\": true, /* 指定始终以严格模式检查每个模块，并且在编译之后的 js 文件中加入 \"use strict\" 字符串 */ /* * Additional Checks */ // \"noUnusedLocals\": true, /* 用于检查是否有定义了但是没有使用的变量 */ // \"noUnusedParameters\": true, /* 用于检查是否有在函数体中没有使用的参数 */ // \"noImplicitReturns\": true, /* 用于检查函数是否有返回值 */ // \"noFallthroughCasesInSwitch\": true, /* 用于检查 switch 中是否有 case 没有使用 break 跳出 switch */ /* * Module Resolution Options */ // \"moduleResolution\": \"node\", /* 模块解析策略: 'node' (Node.js) 或者 'classic' (TypeScript pre-1.6). */ // \"baseUrl\": \"./\", /* 设置解析非相对模块名称的基本目录 */ // \"paths\": &#123;&#125;, /* 设置模块名称到基于baseUrl的路径映射，类似于 webpack 的 alias 别名 */ // \"rootDirs\": [], /* 指定一个路径列表，在构建时编译器会将这个路径列表中的路径的内容都放到一个文件夹中 */ // \"typeRoots\": [], /* 指定声明文件或文件夹的路径列表，如果指定了此项，则只有在这里列出的声明文件才会被加载 */ // \"types\": [], /* 指定需要包含的模块，只有在这里列出的模块的声明文件才会被加载进来 */ // \"allowSyntheticDefaultImports\": true, /* 允许引入没有默认导出的模块 */ \"esModuleInterop\": true, /* 通过为导入内容创建命名空间，实现CommonJS和ES模块之间的互操作性。需要配置 'allowSyntheticDefaultImports'. */ // \"preserveSymlinks\": true, /* 不把符号链接解析为其真实路径 */ // \"allowUmdGlobalAccess\": true, /* 允许从模块访问 UMD 全局变量 */ /* * Source Map Options */ // \"sourceRoot\": \"\", /* 指定调试器应该找到 TypeScript 文件而不是源文件位置 */ // \"mapRoot\": \"\", /* 指定调试器找到映射文件而非生成文件的位置 */ // \"inlineSourceMap\": true, /* 指定是否将 map 文件的内容和 js 文件编译在同一个 js 文件中 */ // \"inlineSources\": true, /* 用于指定是否进一步将 *.ts 文件的内容也包含到输入文件中; 需要设置 '--inlineSourceMap' 或者 '--sourceMap' */ /* * Experimental Options */ // \"experimentalDecorators\": true, /* 指定是否启用实验性的装饰器特性 */ // \"emitDecoratorMetadata\": true, /* 指定是否为装饰器提供元数据支持 */ /* * Advanced Options */ \"forceConsistentCasingInFileNames\": true /* 不允许不同变量来代表同一文件 */ &#125;&#125; ### 基础语法数组数组有两张写法，个人推荐第一种，一目了然。 12345// 写法一let list: number[] = [1, 2, 3];// 写法二let list: Array&lt;number&gt; = [1, 2, 3]; 元组元组多用于记录确定数量和类型的数组。 123let x: [string, number];x = ['hello', 10]; // OKx = [10, 'hello']; // Error 当访问一个越界的元素，会使用联合类型替代： 1234x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型x[6] = true; // Error, 布尔不是(string | number)类型console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString 枚举使用枚举可以定义一些有名字的数字常量 12enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green; Any处理不确定的内容：比如没有 ts 声明的第三方库/用户自定义库 123let notSure: any = 4;notSure = \"maybe a string instead\";notSure = false; // okay, definitely a boolean 注：能不用就尽量不用，因为使用此和不用 ts 没什么区别 Void表示没有任何类型，常用于无返回值的函数。 123function warnUser(): void &#123; console.log(\"This is my warning message\");&#125; 注：声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null。 Nevernever 类型表示的是那些永不存在的值的类型。一般用于报错函数或者无终止条件的函数。 never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。 123456789101112131415// 返回 never 的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(\"Something failed\");&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; Objectobject 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。 类型断言类型断言有两种形式。 其一是“尖括号”语法： 123let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; 另一个为 as 语法： 123let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 当在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的。 注：类型断言会影响 ts 的类型校验，对于十分确定的情况可以使用断言来减少一些转换问题，但不要滥用。 接口基本写法1234567891011interface LabelledValue &#123; label: string; size?: number;&#125;function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label);&#125;let myObj = &#123;size: 10, label: \"Size 10 Object\"&#125;;printLabel(myObj); 注意：可选属性如果出现报红提示时，需要考虑传入的变量类型为 undefined 的情况，因为 undefined 和 null 是所有基础类型的子集 只读属性一些对象属性只能在对象刚刚创建的时候修改其值。你可以在属性名前用 readonly 来指定只读属性: 1234interface Point &#123; readonly x: number; readonly y: number;&#125; TypeScript 具有 ReadonlyArray&lt;T&gt; 类型，它与 Array&lt;T&gt; 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。 123456let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // error!ro.push(5); // error!ro.length = 100; // error!a = ro; // error! ⚠️：上面代码的最后一行，可以看到就算把整个 ReadonlyArray 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写： 1a = ro as number[]; 最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。做为变量使用的话用 const，若做为属性则使用 readonly。 额外的属性检查对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。 1234567891011interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; // ...&#125;// error: 'colour' not expected in type 'SquareConfig'let mySquare = createSquare(&#123; colour: \"red\", width: 100 &#125;); 绕开这些检查非常简单。 最简便的方法是使用类型断言： 1let mySquare = createSquare(&#123; width: 100, opacity: 0.5 &#125; as SquareConfig); 然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 12345interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125; ⚠️ 注意 还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量：因为 squareOptions不会经过额外属性检查，所以编译器不会报错。 12let squareOptions = &#123; colour: \"red\", width: 100 &#125;;let mySquare = createSquare(squareOptions); 函数类型为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 123456789interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; let result = source.search(subString); return result &gt; -1;&#125; 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配，函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。比如，我们使用下面的代码重写上面的例子： 12345678910111213// 不对应变量名let mySearch: SearchFunc;mySearch = function(src: string, sub: string): boolean &#123; let result = src.search(sub); return result &gt; -1;&#125;// 什么都不加let mySearch: SearchFunc;mySearch = function(src, sub) &#123; let result = src.search(sub); return result &gt; -1;&#125; 可索引的类型使用接口的方式来为数组进行类型声明 12345678interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [\"Bob\", \"Fred\"];let myStr: string = myArray[0]; 字符串索引签名能够很好的描述 dictionary 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property 和 obj[&quot;property&quot;] 两种形式都可以。下面的例子里，name 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示： 12345interface NumberDictionary &#123; [index: string]: number; length: number; // 可以，length是number类型 name: string // 错误，`name`的类型与索引类型返回值的类型不匹配&#125; 函数剩余参数剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + \" \" + restOfName.join(\" \");&#125;let employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\"); 声明文件UMDUMD 模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块。 许多流行的库，比如 Moment.js，就是这样的形式。 比如，在 Node.js 或 RequireJs 里，你可以这样写： 12import moment = require(\"moment\");console.log(moment.format()); namespace 和 modulenamespaceTS 里的 namespace 主要是解决命名冲突的问题，会在全局生成一个对象，定义在 namespace 内部的类都要通过这个对象的属性访问。对于内部模块来说，尽量使用 namespace 替代 module，可参考官方文档。例如： 123456789101112namespace Test &#123; export const USER_NAME = 'test name'; export namespace Polygons &#123; export class Triangle &#123; &#125; export class Square &#123; &#125; &#125;&#125;// 取别名import polygons = Test.Polygons;const username = Test.username 注意：import xx = require(‘xx’) 为加载模块的写法，不要与取别名的写法混淆。 默认全局环境的 namespace 为 global module模块可理解成 Vue 中的单个 vue 文件，它是以功能为单位进行划分的，一个模块负责一个功能。其与 namespace 的最大区别在于：namespace 是跨文件的，module 是以文件为单位的，一个文件对应一个 module。类比 Java，namespace 就好比 Java 中的包，而 module 则相当于文件。 参考文档 tsconfig.json配置详解 官方文档 区分 TS 中的 namespace 和 module 关于 TypeScript 中的 module 和 export 关键词","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"React 代码规范配置","slug":"React-代码规范配置","date":"2020-03-29T09:30:36.000Z","updated":"2021-03-17T06:05:51.569Z","comments":true,"path":"2020/03/29/React-代码规范配置/","link":"","permalink":"https://monocy.site/2020/03/29/React-代码规范配置/","excerpt":"前言最近开始初步学习 React 的一些知识，毕竟宅家这么久，总得开始学习学习新的内容了。“工欲善其事，必先利其器”，因此今天主要是配置 VSCode 的 React 支持，折腾来折腾去，核心的配置大概就如文中所示了。 推荐阅读：Mac 环境配置 的 “配置 VScode” 部分，通过 Sync 安装我总结的插件可不用关心以下的配置，默认配置好。","text":"前言最近开始初步学习 React 的一些知识，毕竟宅家这么久，总得开始学习学习新的内容了。“工欲善其事，必先利其器”，因此今天主要是配置 VSCode 的 React 支持，折腾来折腾去，核心的配置大概就如文中所示了。 推荐阅读：Mac 环境配置 的 “配置 VScode” 部分，通过 Sync 安装我总结的插件可不用关心以下的配置，默认配置好。 插件依赖 Prettier （格式化插件） ESlint（格式化插件） ES7 React/Redux/GraphQL/React-Native snippets (快捷指令) 注： 此处为一些必须安装的插件，安装后配置才会生效 项目配置VSCode 有整体的 setting.json 配置和单项目配置，个人还是推荐单项目配置，毕竟自己的开发器可能开发不仅仅就一种语言的吧，因此还是建立如下文件： 123--|- .vscode |- settings.json 然后 settings.json 内配置内容为： 1234567891011121314151617181920&#123; // 编辑器部分 \"editor.tabSize\": 2, \"editor.wordWrap\": \"on\", \"editor.formatOnSave\": true, \"editor.renderWhitespace\": \"none\", \"editor.multiCursorModifier\": \"ctrlCmd\", \"editor.defaultFormatter\": \"esbenp.prettier-vscode\", // 默认启用的代码格式化插件 \"files.insertFinalNewline\": true, /** * 代码配置 */ // eslint 部分 \"eslint.run\": \"onSave\", \"eslint.format.enable\": true, \"editor.codeActionsOnSave\": &#123; \"source.fixAll.eslint\": true &#125;, \"eslint.validate\": [\"typescriptreact\", \"typescript\"]&#125; 样式文件配置因为项目使用的是 prettier 格式化插件，因此我们需要在根目录创建一个 .prettierrc 的文件，然后粘贴一下内容（从 ant design 拷贝过来的，之后根据使用习惯再做修改） 123456789101112131415&#123; \"singleQuote\": true, \"trailingComma\": \"all\", \"printWidth\": 100, \"proseWrap\": \"never\", \"arrowParens\": \"avoid\", \"overrides\": [ &#123; \"files\": \".prettierrc\", \"options\": &#123; \"parser\": \"json\" &#125; &#125; ]&#125;","categories":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/categories/环境/"}],"tags":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/tags/环境/"}]},{"title":"Docker 安装 mysql","slug":"Docker-安装-mysql","date":"2020-03-11T11:27:28.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2020/03/11/Docker-安装-mysql/","link":"","permalink":"https://monocy.site/2020/03/11/Docker-安装-mysql/","excerpt":"前言自学 Docker 系列，了解常用包的使用和配置安装，此篇记录 mysql 的安装","text":"前言自学 Docker 系列，了解常用包的使用和配置安装，此篇记录 mysql 的安装 安装配置下载 mysql（8 版本和 7 版本不太一样） 12docker pull mysql:latestdocker pull mysql:5.7 安装 mysql57 1docker run --name mysql57 -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql:5.7 此时直接通过 tomcat 或者 workbench 连接上即可 安装 mysql:latest 1docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql 如果用 tomcat 连接不上 mysql，那么请参阅参考文章 参考文章 Docker 安装 mysql","categories":[{"name":"Docker","slug":"Docker","permalink":"https://monocy.site/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://monocy.site/tags/Docker/"}]},{"title":"Docker 安装 nginx","slug":"Docker-安装-nginx","date":"2020-03-11T07:44:19.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2020/03/11/Docker-安装-nginx/","link":"","permalink":"https://monocy.site/2020/03/11/Docker-安装-nginx/","excerpt":"前言自学 Docker 系列，了解常用包的使用和配置安装，此篇记录 nginx 的安装","text":"前言自学 Docker 系列，了解常用包的使用和配置安装，此篇记录 nginx 的安装 安装配置下载 nginx 1docker pull nginx:latest 普通运行 1docker run --name nginx -p 80:80 -d nginx 如果需要挂载在本地，则需要设置虚拟卷宗 1docker run --name nginx -p 80:80 -v /Users/saitane/Docker/nginx/nginx.conf:/etc/nginx/nginx.conf -v /Users/saitane/Docker/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf -v /Users/saitane/Docker/nginx/html:/usr/share/nginx/html -d nginx 此处我将 nginx.conf、default.conf 和 html静态文件夹 映射到本地的 nginx 文件夹内，之后就不用进入容器内配置文件以及繁琐的 docker cp 拷贝代码了，但得注意生成容器后需要将文件拷贝到本地 服务器 nginx 安装除了 Docker 的安装方式，此处记录一下我在 centos 装 nginx 遇到的一些问题和解决方法。 安装 nginxcentos 装 ngixn 先查看下是否有安装 nginx 的源 1234567yum repolist# 如果有安装会有这么一行信息# 源标识 源名称# ...# nginx/x86_64 nginx repo# ... 若没有安装源，则安装一下 nginx 的源 1rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 启动 nginx配置前先看一看是否有历史遗留的 nginx 服务 123456netstat -lntp | grep nginx# 如我这里就有一些安装的，但是部分没用却没有停止的服务，根据情况 kill 掉部分# tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 14514/nginx: master# tcp 0 0 0.0.0.0:440 0.0.0.0:* LISTEN 3451/nginx: master# tcp 0 0 0.0.0.0:8099 0.0.0.0:* LISTEN 24166/nginx: master 如果需要深度清理残留 nginx 文件，find / -name nginx 根据情况来处理即可 处理完成后，注册 nginx 服务 1234567# 注册开机启动 nginxsystemctl enable nginx# 启动 nginxservice start nginx# 重启指令： `service restart nginx`# 停止指令： `service stop nginx` 注意，更新 nginx 文件后需要重启 nginx 然后 nginx 就启动成功了 配置 nginxyum 安装的 nginx 配置文件一般在 /etc/nginx 内，配置 nginx.conf 或者 conf.d/default.conf 即可，更多配置可以翻查下文档，这里就不介绍了。 12# 是在记不住就用这个命令查找，它会列举处所有地址whereis nginx 此处仅仅改了 root 文件夹的位置，方便项目构建 12345# conf.d/default.conflocation / &#123; root &lt;target-path&gt;; index index.html index.htm;&#125; 便捷指令记录： 查看服务器 IP 地址命令： ifconfig -a 查看端口是否占用： lsof -i:&lt;端口&gt; 问题总结nginx 反向代理替换规则代理地址是否添加尾部 ‘/‘ 会影响到路径的匹配，总结的规律如下： 1234567location ^~ /xxx/ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_pass http://127.0.0.1:1234/;&#125;# 此最终会被替换成： http://127.0.0.1:1234/ 1234567location ^~ /xxx/ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_pass http://127.0.0.1:1234;&#125;# 此最终会被替换成： http://127.0.0.1:1234/xxx/ nginx 的 nginx.pid 丢失问题nginx 重启时有时候会丢失 pid 文件，特别是被强制杀掉进程的情况，这种情况下我们需要进入 nginx 的安装目录的 sbin 下重新启动 nginx： 12# cd &lt;nginx-dir&gt;/sbin./nginx -c &lt;nginx.conf path&gt; 防止此丢失问题发生，在更新 nginx 时尽量使用 nginx reload 来平滑重启，重载配置。 参考文章 CentOS 7 yum 安装 Nginx Linux 彻底卸载 Nginx Linux kill 命令 nginx 重启报找不到 nginx.pid 的解决方法","categories":[{"name":"Docker","slug":"Docker","permalink":"https://monocy.site/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://monocy.site/tags/Docker/"}]},{"title":"Github 无法登陆问题","slug":"Github-无法登陆问题","date":"2020-03-09T07:47:11.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2020/03/09/Github-无法登陆问题/","link":"","permalink":"https://monocy.site/2020/03/09/Github-无法登陆问题/","excerpt":"前言从过年回家到现在（肺炎封城），github 就从来没有登陆成功，原先一直以为是家里网的问题，知道今天偶然间用手机登上了 github，发现事情并没有那么简单，重新配置了一下 /etc/hosts 文件后，终于能登上 github 官网了。","text":"前言从过年回家到现在（肺炎封城），github 就从来没有登陆成功，原先一直以为是家里网的问题，知道今天偶然间用手机登上了 github，发现事情并没有那么简单，重新配置了一下 /etc/hosts 文件后，终于能登上 github 官网了。 hosts 文件Hosts 是一个没有扩展名的系统文件，其作用就是将一些常用的网址域名与其对应的 IP 地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从 Hosts 文件中寻找对应的 IP 地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交 DNS 域名解析服务器进行 IP 地址的解析。 注意：Hosts 文件配置的映射是静态的，如果目标域名对应的 ip 更改了，但 hosts 文件的映射没有及时更新，会导致页面无法访问。 解决解决方法非常简单，将 /etc/host 文件内的 github.com 的映射注释掉即可，或者是更新对应的 ip。 一般在 IPAddress 里面进行 IP 查询。 补充：更新 IP 的方法好像不行 参考文档 hosts","categories":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/categories/环境/"}],"tags":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/tags/环境/"}]},{"title":"npx 的用途","slug":"npx-的用途","date":"2020-03-04T13:27:52.000Z","updated":"2021-03-17T06:01:25.386Z","comments":true,"path":"2020/03/04/npx-的用途/","link":"","permalink":"https://monocy.site/2020/03/04/npx-的用途/","excerpt":"前言最近在使用 package.json 的 script 运行指令时，发现通过 npm 包安装的部分指令无法使用（比如 docsify 指令），原因是因为 docsify-cli 当作 devDependence 依赖项安装至项目中了，这与在终端上直接运行 docsify 指令一样，因为全局环境并没有对应的指令，因此会提示找不到对应的指令，这时候就能用上 npx 了。","text":"前言最近在使用 package.json 的 script 运行指令时，发现通过 npm 包安装的部分指令无法使用（比如 docsify 指令），原因是因为 docsify-cli 当作 devDependence 依赖项安装至项目中了，这与在终端上直接运行 docsify 指令一样，因为全局环境并没有对应的指令，因此会提示找不到对应的指令，这时候就能用上 npx 了。 简介 npxnpx 是自 npm5.2 之后发布的一个命令，用于执行 node_modules/.bin 内的可执行命令，其主要解决的就是前言中描述的问题：能够直接执行项目内安装的模块的命令。 npx 的执行流程如下： 去 node_modules/.bin 路径检查 npx 后面的命令是否存在，找到之后执行； 找不到，就去环境变量 $PATH 里面，检查 npx 后面的命令是否存在，找到之后执行; 还是找不到，自动下载一个临时的依赖包最新版本在一个临时目录，然后再运行命令，运行完之后删除，不污染全局环境。 使用 npx 能够减少无用的全局模块的安装，比如 npx http-server 可以在当前目录启动一个 Web 服务，即使没有安装对应的包 npx 常用参数–no-install 参数如果想让 npx 强制使用本地模块，不下载远程模块，可以使用 –no-install 参数。如果本地不存在该模块，就会报错。 1npx --no-install http-server –ignore-existing 参数与上面相反，此命令是强制忽略本地的同名模块，强制安装使用远程模块。比如，本地已经全局安装了create-react-app，但还是想使用远程模块，就用这个参数。 1npx --ignore-existing create-react-app my-react-app 参考文档 npx npx 使用教程 npx详细使用","categories":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/categories/环境/"}],"tags":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/tags/环境/"}]},{"title":"前端面试题大全","slug":"前端面试题大全","date":"2020-01-27T07:37:14.000Z","updated":"2021-06-30T15:25:54.873Z","comments":true,"path":"2020/01/27/前端面试题大全/","link":"","permalink":"https://monocy.site/2020/01/27/前端面试题大全/","excerpt":"前言临近春节，很多人又考虑换工作了，考虑到还有一年多的工作的时间，提前总结总结也是不错的，这里就记录一下最近翻到了以及先前自己总结的一些问题，为之后的复习做准备。","text":"前言临近春节，很多人又考虑换工作了，考虑到还有一年多的工作的时间，提前总结总结也是不错的，这里就记录一下最近翻到了以及先前自己总结的一些问题，为之后的复习做准备。 HTML 篇H5 有哪些新特性 语义化标签（header、footer、nav、aside、article、section 等） 增强表单（传送门） 本地存储 多媒体元素标签： vedio 与 audio 新增地理定位方法 canvas 画布 拖放事件 webWorker webSocket webStorage 和 Cookie 的区别以及各自的优缺点 特性 cookie localStorage sessionStorage 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 数据存储大小 4K 5M 5M 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。 svg 与 canvas svg canvas svg 是一种使用 xml 描述 2D 图形的语言，矢量图 canvas 通过 javascript 来绘制 2D 图形，标量图 svg 基于 xml，这意味着 svg DOM 中的每个元素都是可用的，您可以为某个元素附加 javascript 事件处理器 canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象 移动端页面适配方案1234567891011121314151617181920&lt;script&gt; // 获取缩放大小 var scale = 1 / window.devicePixelRatio; // content 配置默认缩放大小，不允许缩放 var content = 'width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'; // 动态 meta 标签适配 document .querySelector('meta[name=\"viewport\"]') .setAttribute('content', content); // 基准 font-size 设置 document.documentElement.style.fontSize = document.documentElement.clientWidth / 75 + 'px';&lt;/script&gt; CSS 篇CSS3 的新特性 transition（过渡动画）、animation（贞动画）、transform（形状变化） 新增选择器（伪类选择器、相邻选择器等） 边框、阴影、滤镜等 弹性布局、栅格布局 推荐阅读 position 默认值以及默认基于什么定位默认值为：static； 定位是基于最近的且 position 值为非 static 的父元素； 水平垂直居中有哪些方法。（至少 3 种） translate 方法 position + margin 定位 flex 布局 table-ceil 方法 padding 实现 清除浮动有哪些方式。 after 伪类（IE 需要设置 zoom: 1） 空 div 元素，设置 css ： clear: both 父级形成 BFC 结构，如: overflow: hidden BFC 的相关知识考察 BFC 提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。 常见问题： 高度塌陷 外边距折叠 实现方式： 浮动元素，float 除 none 以外的值 绝对定位元素，position（absolute，fixed） display 为以下其中之一的值 inline-block，table-cells，table-captions overflow 除了 visible 以外的值（hidden，auto，scroll） …… 参考文章： 浅谈 BFC CSS 选择器实现以下字体样式效果 12345678910111213&lt;div&gt; &lt;p&gt;&lt;!-- 红 --&gt;&lt;/p&gt; &lt;p&gt;&lt;!-- 白 --&gt;&lt;/p&gt; &lt;p&gt;&lt;!-- 红 --&gt;&lt;/p&gt; &lt;p&gt;&lt;!-- 白 --&gt;&lt;/p&gt; &lt;!-- ... n 个 p --&gt; &lt;p class=\"center\"&gt;&lt;!-- 黄 --&gt;&lt;/p&gt; &lt;p&gt;&lt;!-- 蓝 --&gt;&lt;/p&gt; &lt;p&gt;&lt;!-- 蓝 --&gt;&lt;/p&gt; &lt;p&gt;&lt;!-- 蓝 --&gt;&lt;/p&gt; &lt;!-- ... n 个 p --&gt; &lt;p&gt;&lt;!-- 绿 --&gt;&lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122div &#123; background-color: black;&#125;p &#123; &amp;:nth-child(2n) &#123; color: white; &#125; &amp;:nth-child(2n + 1) &#123; color: red; &#125; &amp;.center &#123; color: yellow; &#125; // 此处得考虑优先级问题 &amp;.center ~ p:not(:last-child) &#123; color: blue; &#125; &amp;:last-child &#123; color: green; &#125;&#125; JavaScript 篇ES6+ 有哪些新特性 let, const 变量 模板字符串 “`” 解构赋值 与 扩展运算符（... 运算符） Promise 与 async Map、Set class Array 的一些原生方法 箭头函数、默认值 … let 与闭包、解构 undefined 和 null 的值时的默认值问题、class 与原型链、Set 与 除重方法等等 Promise.all() 的实现12345678910111213141516171819202122232425function PromiseAll(promiseArr) &#123; if (!Array.isArray(promiseArr)) &#123; throw new TypeError('You must pass an array'); &#125; const arrayLen = promiseArr.length; const resolvedArr = []; let pos = 0; return new Promise((resolve, reject) =&gt; &#123; promiseArr.forEach(item =&gt; &#123; Promise.resolve(item) .then(res =&gt; &#123; resolvedArr.push(res); pos++; if (pos === arrayLen) &#123; resolve(resolvedArr); &#125; &#125;) .catch(e =&gt; &#123; reject(e); &#125;); &#125;) &#125;);&#125; 数组去括号并去重12// 试题let originArr = [1, 2, [2, 3], 3, [2, [3, 0]], 4, [[[5]]]] 1234567891011121314151617// 实现的方法:function formatArr(originArr) &#123; function flattenDeep(arr) &#123; let resArr = []; if (Array.isArray(arr)) &#123; resArr = arr.reduce((a,b)=&gt;[...a, ...flattenDeep(b)], resArr); &#125; else &#123; resArr.push(arr); &#125; return resArr; &#125; const flatArr = flattenDeep(originArr); return [...new Set(flatArr)];&#125;const testArr = [1, [[2], [3, [4, 5]], 5]];console.log(formatArr(testArr)); 123456// 简单方法function formatArr(originArr) &#123; const flatArr = originArr.toString().split(','); const filteredArr = [...new Set(flatArr)]; return filteredArr.map(n =&gt; Number(n));&#125; This 指向问题123456789let obj = &#123; b: 1, a: () =&gt; &#123; console.log(this.b) &#125;&#125;obj.a()// 输出 undefined 参考文章： 深入了解 this 以下代码依次输出的结果1234567891011121314151617181920212223242526async function async1() &#123; console.log('as1') await async2() console.log('end as1')&#125;async function async2() &#123; console.log('as2')&#125;console.log('start')async1(1)setTimeout(() =&gt; &#123; console.log('setTimeout')&#125;)new Promise((rs, rj) =&gt; &#123; console.log('promise') rs()&#125;).then(() =&gt; &#123; console.log('then')&#125;)console.log('end') 12345678startas1as2promiseendend as1thensetTimeout HTTP 篇常用的 HTTP 方法有哪些 GET：用于请求访问已经被 URI 识别的资源，可以通过 URL 传参给服务器 POST：用于传输信息给服务器,主要功能 GET 类似，但一般推荐使用 POST 方式 PUT：传输文件，报文主体中包含文件内容，保存到对应的 URI 位置 HEAD：获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效 DELETE：删除文件，与 PUT 方法相反，删除对应 URI 位置的文件 OPTIONS：查询对应 URI 支持的 HTTP 方法 GET 和 POST 的区别 GET 重点从服务器上获取资源，POST 重点向服务器发送数据 GET 传输的数据量小，因为受 URL 长度限制，但效率较高；POST 可以传输大量数据，所以上传文件时只能用 POST 方式； GET 是不安全的，因为 URL 是可见的，可能会泄露私密信息，如密码等；POST 较 GET 安全性较高； 请求报文和响应报文a. 请求报文包含三部分： 请求行：包含请求方法、URI、HTTP 版本信息 请求首部字段 请求内容实体 b. 响应报文包含三部分： 状态行：包含 HTTP 版本、状态码、状态码的原因短语 响应首部字段 响应内容实体 常见的状态码 200：表示请求已成功，请求所希望的响应头或数据体将随此响应返回。 301：永久重定向，资源已永久分配新 URI。 302：临时重定向，资源已临时分配新 URI。 304：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 307：临时重定向，POST 不会变成 GET。 401：需要通过 HTTP 认证，或认证失败。 403：表示对请求资源的访问被服务器拒绝了。 404：表示服务器找不到你请求的资源。 500：表示服务器执行请求的时候出错了。 503：表示服务器超负载或正停机维护，无法处理请求。 强缓存和协商缓存a. 强缓存相关的字段： expires cache-control：max-age=number b. 协商缓存相关的字段： Last-Modified/If-Modified-Since Etag/If-None-Match 性能优化HTML 不要使用空 src 的 image 标签 减少 iframe 的数量，其开销高，会阻塞 onload 事件，同域会抢资源 减少不必要的 DOM 元素 图片懒加载 使用 CDN 的资源 css 样式放在顶部 header，js 放在 body 最后面 CSS 能使用 base64 的尽量使用 base64 背景图加载 尽量不使用 @import 语法 JavaScript 减少 DOM 访问 多次修改统一节点时使用 documentFragment 文档片段来做中间拼接处理 减少获取 clientHeight 等信息的次数，会造成反复重绘 合理添加事件监听函数 其它短链接的生成思路一般链接的特点：不考虑 query 字段，一般就只有 26 个英文字母，而短链接的特点是含有 ([a-z][a-z][0-9])，因此一个粗略的想法就是将 26 进制转化成 62 进制，因此将对应算法写出来基本上就算是答道点子上了。 算法的大致思路为： 26 进制 -&gt; 10 进制 -&gt; 62 进制 参考文档 前端面试问题","categories":[{"name":"Skill","slug":"Skill","permalink":"https://monocy.site/categories/Skill/"}],"tags":[{"name":"Skill","slug":"Skill","permalink":"https://monocy.site/tags/Skill/"}]},{"title":"Mac 指令学习","slug":"Mac-指令学习","date":"2020-01-19T12:24:18.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2020/01/19/Mac-指令学习/","link":"","permalink":"https://monocy.site/2020/01/19/Mac-指令学习/","excerpt":"前言最近在研究可视化编辑器部分的内容，同时借此机会学习学习 node 相关的知识。然而在学习的过程中，发现好不容易申请下来的测试机却不会用，是时候该补充补充 linux 相关的知识了！ 该文档持续完善，争取每周一个指令","text":"前言最近在研究可视化编辑器部分的内容，同时借此机会学习学习 node 相关的知识。然而在学习的过程中，发现好不容易申请下来的测试机却不会用，是时候该补充补充 linux 相关的知识了！ 该文档持续完善，争取每周一个指令 grep 命令123# 获取对应文件内的内容## -n 表示加上行号，file 支持 * 通配符grep -n &lt;content&gt; &lt;file&gt; du 命令du 命令用于显示目录或文件的大小 123# 查看文件深度为 n 的所有文件大小# n=0 时为该文件大小du -d &lt;depth &gt;= 0&gt; -h &lt;file-path&gt; tar 命令tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。可以用来做文件压缩 123456789# touch a.c# 压缩 a.c文件为 test.tar.gztar -czvf test.tar.gz a.c# 列出压缩文件中的内容tar -tzvf test.tar.gz# 解压缩tar -xzvf test.tar.gz -v：显示过程； -c 建立新的备份文件； -z：gzip 处理备份文件； -x：从备份文件中还原文件； -t：列出文件内容 which 指令其主要用途是定位程序在系统的哪个位置，使用方法很简单 1which &lt;target1&gt; &lt;target2&gt;","categories":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/categories/环境/"}],"tags":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/tags/环境/"}]},{"title":"Docker 安装笔记","slug":"Docker-安装笔记","date":"2019-12-14T06:00:36.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/12/14/Docker-安装笔记/","link":"","permalink":"https://monocy.site/2019/12/14/Docker-安装笔记/","excerpt":"前言不知不觉已经快过 2 个月了，这期间由于项目变更，再加上遇到了一些生活上的波折，基本上没太多心思花在博文的编写了。好不容易稍微有点时间了，立马开始写上一篇，记录一下最近折腾配置的环境。 仅记录 Mac 环境的配置","text":"前言不知不觉已经快过 2 个月了，这期间由于项目变更，再加上遇到了一些生活上的波折，基本上没太多心思花在博文的编写了。好不容易稍微有点时间了，立马开始写上一篇，记录一下最近折腾配置的环境。 仅记录 Mac 环境的配置 Docker 安装Docker 安装很简单，有两种方式（基本上网上都有），分别为： brew 安装 安装包安装 brew 安装brew 安装很简单，命令为： 12## 等待的时间会有点长brew cask install docker 手动下载安装docker 手动下载安装也不是特别复杂，但是为了更为方便快捷，最好还是去官网注册一个 ID（迟早会去注册账号的），然后再 download 桌面版。 虽然不知道能不能打开此链接，但是还是奉上 download 传送门 此外，还有其它的安装途径，比如 Docker 极速下载 网站（该版本比较低，因此需要自己升级） Docker 镜像加速Docker 默认使用的是国外的源，而国外的源有时会有网络的问题，在后续的拉取中会比较缓慢。 Mac 上的更改操作比较简单，步骤为： 点击 Docker 图标 -&gt; Perferences -&gt; Daemon 标签页 -&gt; Registry mirrors 可添加源有： 12345678# 国内官方https://registry.docker-cn.com# 网易源https://hub-mirror.c.163.com# 阿里云https://registry.aliyuncs.com# 中科大https://docker.mirrors.ustc.edu.cn 之后点击 Apply &amp; Restart 等待片刻即可。 基础命令拉取远程镜像1docker pull [registry[:port]/]packages[:tags] 默认拉取的为 Docker Hub 的 latest 版本的包 镜像列举与空间占用1234# 查看当前下载的镜像资源（压缩的）docker images# 查看镜像、容器、卷宗占用体积docker system df docker image prune 删除无用镜像 删除镜像与容器1234# 删除镜像docker rmi &lt;image&gt; [others...]# 删除容器docker rm &lt;container-hash/container-name&gt; 运行与操作容器创建并运行容器 1234567docker run [--name &lt;container-name&gt;] [-p &lt;image-port&gt;:&lt;local-port&gt;] [-v &lt;local-path&gt;:&lt;container-path&gt;] [-e &lt;container-env&gt;=&lt;params&gt;] [-d] &lt;image-name&gt; name 为容器别名； p 为端口映射； v 为卷宗地址映射； e 为环境变量声明； d 为后台运行容器 启动容器 1docker start &lt;container-name/container-hash&gt; 重新启动容器 1docker restart &lt;container-name/container-hash&gt; 终止容器 1docker stop &lt;container-name/container-hash&gt; 进入容器 12# 以 bash 的方式，进入伪终端； -it： 支持 stdin 切推出不会停止容器docker exec -it &lt;container-name&gt; bash 拷贝镜像内容1docker cp &lt;container&gt;:&lt;path&gt; &lt;local-path&gt; 参考文章 MacOS Docker 安装 Docker — 从入门到实践","categories":[{"name":"Docker","slug":"Docker","permalink":"https://monocy.site/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://monocy.site/tags/Docker/"}]},{"title":"webpack library","slug":"webpack-library","date":"2019-10-18T12:26:58.000Z","updated":"2020-08-30T13:03:22.517Z","comments":true,"path":"2019/10/18/webpack-library/","link":"","permalink":"https://monocy.site/2019/10/18/webpack-library/","excerpt":"前言虽然先前有过使用 webpack 构建包的经验，但是最近同事问我 library 相关知识时，还是支支吾吾答不上来。想了想，知其然而不知其所以然，这和没学没有什么区别啊。所以，经过一番努力，总结了一点关于 library 的知识，这里就做个笔记，以做备忘吧。","text":"前言虽然先前有过使用 webpack 构建包的经验，但是最近同事问我 library 相关知识时，还是支支吾吾答不上来。想了想，知其然而不知其所以然，这和没学没有什么区别啊。所以，经过一番努力，总结了一点关于 library 的知识，这里就做个笔记，以做备忘吧。 配置目的在开发 npm 库时，我们有时候需要考虑配置多场景的引入方式，比如： AMD、CommonJS、ES6 Moudule、NodeJs/Window 等等。那么为了能够支持这么些引入方式，library 便是 webpack 为我们提供的简化打包策略的方法，使用 library 的配置方式可以让我们专注于 ES6 的写法，而编译部分就不做过多考虑了。 由于 ECMAScript 越来越普及，此处仅介绍 ECMAScript 模块语法配置需要注意的问题。 文件配置单文件配置单文件 library 的配置就非常简单了，官方就有很好的例子，这里就先贴一下： 123456789101112var path = require('path');moudule.export = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack-numbers.js', library: 'webpack-demo', // 支持 AMD 和 CommonJS libraryTarget: \"umd\" &#125;&#125; 对于如今的项目来说，如果不是对引入方式有特别要求，建议使用 umd 方式；如果有明确指定环境时，再换成对应配置即可。 多文件配置多文件配置唯一注意的是文件的引入，以及默认 library 名同样需要设置成动态的。 123456789101112131415161718var path = require('path');// 多入口文件 JSON 对象var components = require('./components.json');moudule.export = &#123; entry: components, output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].js', // 每个文件的导出对象名与文件名保持一致 library: '[name]', // 支持 AMD 和 CommonJS libraryTarget: \"umd\", // ES6 编写的组件，如果导出为 export default // 如果文件引入测试有问题，可配置此属性 libraryExport: \"default\" &#125;&#125; 属性详解其实配置什么的，随便在网上查查，再根据自身的理解尝试，都能有所成效。但是知其然我们也得知其所以然，这里我们就看看大家所关注的 library、libraryTarget、libraryExport 此三属性吧。 librarylibrary 可设置的类型有两种，分别是：string 和 object。 当我们需要对不同环境设置不太一样的导出名时，我们才可能用到 object，例如： 12345678// 仅此三属性// 无 root 配置则其采用 commonjs 名，反之 commonjs 采用 root，此两属性必须配置其// 一，否则会有全局污染的危险library: &#123; commonjs: 'my-package-a', amd: 'my-package-b', root: 'my-package-c'&#125; 自测 demo 结果展示： 1234567891011(function e(t, n) &#123; if (typeof exports === \"object\" &amp;&amp; typeof module === \"object\") module.exports = n(); else if (typeof define === \"function\" &amp;&amp; define.amd) define([], n); else if (typeof exports === \"object\") exports[\"my-package-a\"] = n(); else t[\"my-package3-c\"] = n()&#125;)(/*...*/) 否则直接使用 string 模式即可。 注意，library 对象模式必须设置 libraryTarget 为 umd 模式；此外 library 名称最好使用驼峰式，毕竟生成的是变量。 疑问： umd 模式无论如何配置 amd，打包出的内容 amd 部分基本都是 define([], n);，即使配置成驼峰式的值，此外官方的例子上也没有对应值，不清楚是什么问题；但 amd 模式单独打包则有对应的配置名称。此 amd 的配置与 amd-require 的结果很相似。 libraryTargetlibraryTarget 属性主要配置如何暴露我们的 library 名。其支持的值如下： 变量类型： var（默认） assign（产生隐含的全局变量，慎用） 对象类型： this（绑定至 this 对象上） window（浏览器环境的全局对象 ） global（node 环境的全局对象） commonjs（绑定至 export 对象） self（绑定至 self 对象） 模块类型： amd（amd 引入模式） umd（多模式并存） commonjs-module（module.exports） commonjs2（commonjs-module 的模块导出 + commonjs 对象，会忽略 library 名） amd-require（立即加载版的 amd，会忽略 library 名） system（systemJs 引入） umd2 其他类型： jsonp（library 为名的 jsonp 容器） 一般根据情况选取合适的 target 方式，通常来看 umd 已经能解决绝大多数通用的引入模式了。 umd2 结果和 umd 貌似差不多，个人暂未找到相应的解释 libraryExport该属性主要是用于配置经由 libraryTarget 公开那些模块，默认为 undefined。 默认情况下（假设 libraryTarget 为 var），变量导出的格式为： 1var MyDefaultModule = _entry_return_; 如果需要显示表明导出哪些模块，我们可以这么配置： 1234567// 指定模块// libraryExport: 'MyModule'var MyModule = _entry_return_.MyModule;// 指定模块路径// libraryExport: ['MyModule', 'MySubModule']var MySubModule = _entry_return_.MyModule.MySubModule; 一般并不需要配置此属性，有一种情况是：当我们使用 ES6 编写模块时，有时候打包生成的文件在引入时，其内容呈现为： 123&#123; default: &#123;/* ... */&#125;&#125; 毕竟 ES6 的 export default 其 default 严格上来说也是一个变量名，因此为了修复此问题，我们可以配置 libraryExport: &#39;default&#39;，将默认导出分配给库目标 测试例子该部分内容还是自己动手，配合官方文档理解起来会更快，可以拷贝该 测试 Demo 进行尝试。 参考文章 output.library 创建 library muti-part-library webpack 全量配置 commonjs 与 commonjs2","categories":[{"name":"Webpack","slug":"webpack","permalink":"https://monocy.site/categories/webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://monocy.site/tags/Webpack/"}]},{"title":"使用 git submodule 来管理子模块","slug":"使用-git-submodule-来管理子模块","date":"2019-10-17T02:40:40.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/10/17/使用-git-submodule-来管理子模块/","link":"","permalink":"https://monocy.site/2019/10/17/使用-git-submodule-来管理子模块/","excerpt":"前言近期在考虑项目拆分的过程中，对于公共组件的维护总共找到了两种方式，分别是：发布 npm 包与 git submodule 子模块管理。对于 npm 发包的方法这里我就不做赘述了（先前有写到过），而另一种 git submodule 的方法这里就详细介绍一下，对于不想使用发包的方式（比较繁琐）来维护子项目的 coder 来说，这种方式可以算是最为方便的了。","text":"前言近期在考虑项目拆分的过程中，对于公共组件的维护总共找到了两种方式，分别是：发布 npm 包与 git submodule 子模块管理。对于 npm 发包的方法这里我就不做赘述了（先前有写到过），而另一种 git submodule 的方法这里就详细介绍一下，对于不想使用发包的方式（比较繁琐）来维护子项目的 coder 来说，这种方式可以算是最为方便的了。 使用场景有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。也许是第三方库，或者你独立开发的，用于多个父项目的库。现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。 我们举一个例子。假设你正在开发一个网站然后创建了 Atom 订阅。你决定使用一个库，而不是写自己的 Atom 生成代码。你可能不得不通过 CPAN 安装或 Ruby gem 来包含共享库中的代码，或者将源代码直接拷贝到自己的项目中。如果将这个库包含进来，那么无论用何种方式都很难定制它，部署则更加困难，因为你必须确保每一个客户端都包含该库。如果将代码复制到自己的项目中，那么你做的任何自定义修改都会使合并上游的改动变得困难。 Git 通过子模块来解决这个问题。子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。 该部分直接引用官方的例子，就不造轮子了。 命令使用使用 git submodule 时，需要的一些命令有： 12345678910111213# 当前项目文件名如不指定，则默认为仓库名# 目标仓库路径可为远程仓库地址，也可为当前相对路径git submodule add &lt;目标仓库路径&gt; &lt;当前项目文件名&gt;# 查看子模块状态git submodule (status)# 将子模块与远程保持同步（会切换至一个临时分支）git submodule update --remote# 将所有子模块都切换至 master 分支git submodule foreach 'git checkout master'# 将所有子模块同步远程更新git submodule foreach 'git pull'# 查看子模块追踪的内容信息git diff --cached --submodule 初次添加仓库操作作为添加者来说，子模块的添加是很简单的一件事，主要步骤如下： 1234567891011# 添加仓库git submodule add &lt;子模块仓库路径&gt; &lt;当前项目文件名&gt;# 此时打印 git status 会显示 submodule 的一些信息# .submodule 文件内存储的就是我们需要的映射信息了# 提交更新并推送至远程# 当仓库提交至远程时，子模块的内容并不会被带过去git add .git commit -m \"init submodule\"git push 拷贝远程仓库拷贝远程带有子模块的项目需要稍微注意一点，那就是子模块需要额外的步骤才能将内容拷贝下来，具体步骤如下： 123456789# 克隆仓库git clone &lt;远程仓库地址&gt;# 此时子模块是没有内容的，所以# 初始化本地配置文件git submodule init# 配置文件有记录对应的 commit id，此将子模块文件同步至配置文件内记录的 id 处# 注意： `git submodule update` 拿到的文件内容并不一定与子模块仓库的最新状态保持一致# 因为它记录的为先前初始化时的版本，需要额外更新git submodule update 三步简化成一步的操作为： git clone &lt;远程仓库地址&gt; –recursive 更新子模块更新的方法也有多种，最为基础的处理方式是： 1234567# 进入项目中的子模块内cd &lt;child-module&gt;# 拉取新内容git fetch# 合并新内容git merge# fetch 和 merge 可以简化为一步： git pull 当然，此做法比较繁杂，较为简便的处理方法是（无需进入子模块）： 12# 添加 remote 会更新至远程项目的最新版本，否则是本地最新版本git submodule update --remote Git 会自动进入子模块并更新它。但是该命令会默认假定你想要更新并检出子模块的 master 分支。简单的说，此时子模块会自动生成一个新临时分支，与远程的源保持一致，如果子模块内部有改动，想要迁回，那么将子模块的 branch 切回原来的分支即可。 例如：子模块本来是 master 分支，后来远程子模块的源更新了，此时 git submodule update --remote 会将子模块分支切换成一个 hash id 分支。此时进入子模块目录，git checkout master 切回 master 分支，你会发现该 master 分支内容与执行 update 指令之前的是一致的，没有变动，但会提醒你远程的源已经更新了，需要手动 pull 一下。 这样看来，这两种写法都没差啦～反正最后都得自己手动处理一下。 对于包含多个子模块的项目来说，进入子模块一个个更新着实是很麻烦，批量更新可以使用 foreach，例如： 12345# 同步最新的 head 指针，否则git submodule update --remote# 将默认迁出的分支迁回 master，然后拉取更新git submodule foreach git checkout mastergit submodule foreach git pull 或者，如果知道更新了，可以省略掉前两步骤（前面步骤主要是为了 git status | git submodules 看有没有子模块变动），直接拉取就行，这样也不用再去切分支了。 1git submodule foreach git pull 更改子模块前面对子模块的处理仅仅只是同步更新而已，这和使用 npm 包没啥区别，但毕竟是将子模块给弄进项目了，当个包放在那里用，那也太委屈了。其实在主项目内，我们还可以对子模块进行更新，还可以并发布其改动，这样就能节省很多时间和劳力了（前提是别改造得别人无法使用，变成私有代码库了）。 这里仅介绍比较省时的操作，直接启动 merge ，我们可以用下面这个命令： 1git submodule update --remote --merge 进入子模块后，我们就能和平常一样的合并冲突了。 在主分支进行推送时，我们得保证当前分支的所有子模块都已经与远程一致（或者都落后，但不可 diverged），防止别的伙伴接受不到新的变动，因此推送的命令改为： 123# 这样 git 会进入到子模块中然后在推送主项目前推送了它。如果那个子模块因为某些原因推送失败，主项目也会推送失败# 该方法暂未尝试，一直用的 foreach push，比较方便git push --recurse-submodules=on-demand 注：如果出现了无法推送的情况，特别是远程分支为本地项目的情况，此时我们需要进入该远程分支，然后设置 ‘.git/config’ 文件，加上内容如下： 12[receive] denyCurrentBranch = false 这样就能 push 了。 删除子模块删除子模块需要进行 2 步操作，首先得删除对应的 cache 缓存追踪，然后再删除对应的模块文件 12git rm --cached &lt;fileName&gt;rm --rf &lt;fileName&gt; 参考文章 Git 子模块 Git 子模块的管理和使用","categories":[{"name":"Git","slug":"Git","permalink":"https://monocy.site/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://monocy.site/tags/Git/"}]},{"title":"分析 Vue 的观察者模式（中）","slug":"分析-Vue-的观察者模式（中）","date":"2019-10-11T03:48:30.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/10/11/分析-Vue-的观察者模式（中）/","link":"","permalink":"https://monocy.site/2019/10/11/分析-Vue-的观察者模式（中）/","excerpt":"前言在上篇分析 Vue 的观察者模式（上）中，简单实现了“手动”版观察者模式，而在本篇中我们继续沿着该思路往下探索，看如何实现“自动”版的观察者。","text":"前言在上篇分析 Vue 的观察者模式（上）中，简单实现了“手动”版观察者模式，而在本篇中我们继续沿着该思路往下探索，看如何实现“自动”版的观察者。 完善的观察者紧接着上文的思路，因为我们只是实现了 Dep 依赖（管家），却还没有对平台的观察处理方式优化，因此我们需要将此步骤给完善起来。 首先，要实现发布者更新内容后自动触发订阅事件，那么我们需要的是对发布者内容改变的监听，ES5 中恰好有这么一种方法能满足我们的需求，那就是 Object.defineProperty(...)。其语法很简单，我们此处仅仅需要拦截 get 和 set 方法，大致写法为： 1234567891011121314const data = &#123; name: 'test'&#125;;Object.defineProperty(data, name, &#123; get() &#123; return data.name; &#125;, set(newVal) &#123; // 调用 setter 方法，不可直接赋值，否则会死循环 // 错误写法 obj[key] = newVal // 可查看 Vue 中的 setter 获取 &#125;&#125;) 既然有了能够观测发布者的方法，那么对于对象变更后的监听就能自动化处理了，那么先前手动触发 dep.depend() 和 dep.notify() 函数的操作就能整合入 Object.defineProperty 内了。 延续先前的逻辑，dep.notify() 方法执行都得在对象值变动之后，因此我们可以将此方法放入 set 函数内；而 dep.depend() 方法主要是将订阅者事件存储入自身的事件列表中，因此该方法执行一次就行，之后每次更新都触发 notify 来依次执行注册的函数即可。因此，在考虑只是传入简单对象的情况时，这阶段的代码思路大致是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// （私人管家）依赖收集class Dep &#123; constructor() &#123; this.subscriberList = []; &#125; // 添加订阅方法 depend() &#123; // 此处添加对应订阅方法 &#125; // 发布者更新消息 notify() &#123; this.subscriberList.forEach(sub =&gt; &#123; // 依次处理订阅的方法 &#125;); &#125;&#125;// （发布者和管家的联系方式）监听器function observer(data = &#123;&#125;) &#123; Object.keys(data).forEach(key =&gt; &#123; let val = data[key]; const dep = new Dep(); Object.defineProperty(data, key, &#123; get() &#123; // get 时添加依赖，当有目标的时候才添加 if (target) &#123; dep.depend(); &#125; return val; &#125;, set(newVal) &#123; if (newVal === val) &#123; return; &#125; // set 时触发更新 // 此处用 setter 做变动，此处偷懒一下，不要直接赋值，会反复触发 set val = newVal; dep.notify(); &#125; &#125;) &#125;);&#125; 那么现在问题又有了。目前代码实现至此我们仅仅只是将发布者与其 Dep 依赖进行了关联，那么观察者又该如何将其获订阅者的事件与 Dep 存储的事件列表进行关联呢？从订阅者角度分析一下： 订阅者决定好要订阅的内容（订阅者的函数）； 订阅者在对应的观察者平台上注册事件，绑定发布者信息； 观察者先联系到 Dep 管家，将订阅事件存放至管家处； 待管家拿到了发布者新情报，则响应所有存储好的订阅者的订阅事件了。 思路逐渐清晰，那么这么个流程我们可以简化为如下代码： 12345678910111213141516171819202122232425262728target = null;class Dep &#123; constructor() &#123; this.sub = []; &#125; depend() &#123; if (target &amp;&amp; !this.sub.includes(target)) &#123; this.sub.push(target); &#125; &#125; notify() &#123; this.sub.forEach(cb =&gt; cb()); &#125;&#125;function watcher(callback) &#123; target = callback; // 此处触发一下监听对象的 get 方法，将 callback 方法加入 Dep 依赖的订阅队列中 // 然后清除掉 target，防止重复注册 target = null;&#125;watcher(() =&gt; &#123; // 此处是订阅事件&#125;) 这样我们就讲观察者的订阅方法和 Dep 依赖给绑定上了。考虑到 watcher 的通用性，这里写了一个加强版的 demo，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899let target = null;// （私人管家）依赖收集class Dep &#123; constructor() &#123; this.subscriberList = []; &#125; // 将当前的 watcher 加入 dep 中 addSub(watcher) &#123; this.subscriberList.push(watcher) &#125; // 添加订阅方法 depend() &#123; if (target) &#123; target.addDep(this); &#125; &#125; // 发布者更新消息，触发所有的订阅方法 notify() &#123; this.subscriberList.forEach(sub =&gt; &#123; sub.update(); &#125;); &#125;&#125;// （平台）观察者class Watcher &#123; constructor(data = &#123;&#125;, key = '', cb = () =&gt; &#123;&#125;) &#123; this.cb = cb; this._data = data; this.key = key; target = this; // 触发 getter，存储本 watcher this.value = data[key]; // 防止反复触发 target = null; &#125; addDep(dep) &#123; dep.addSub(this); &#125; update() &#123; const newVal = this._data[this.key]; this.value = newVal; this.cb(newVal); &#125;&#125;// （发布者和管家的联系方式）监听器function observer(data = &#123;&#125;) &#123; Object.keys(data).forEach(key =&gt; &#123; let val = data[key]; const dep = new Dep(); Object.defineProperty(data, key, &#123; get() &#123; if (target) &#123; // get 时添加依赖 dep.depend(); &#125; return val; &#125;, set(newVal) &#123; if (newVal === val) &#123; return; &#125; // set 时触发更新 val = newVal; dep.notify(); &#125; &#125;) &#125;);&#125;// 发布者const publisher = &#123; bookName: 'book', bookContent: 'hello world'&#125;// 管家开始观测发布者observer(publisher);// 订阅者在平台上订阅发布者的部分信息new Watcher(publisher, 'bookName', name =&gt; &#123; console.log(`new book name is $&#123;name&#125;`);&#125;);new Watcher(publisher, 'bookContent', content =&gt; &#123; console.log(`new book content is $&#123;content&#125;`);&#125;);// 发布者发布信息publisher.bookName = 'new book';publisher.bookContent = 'new content'; Vue 观察者的实现在看源码之前，首先让我们看看 Vue 的实现原理图： 先仅考虑 data 部分的观察者模式，我们可以看到大致步骤为： 为发布者 data 做数据监听处理； 为劫持方法添加 Dep 依赖收集，get 存储 target 目标，set 设置 target 目标； 依赖收集触发后，触发 Watch 观察者，通知订阅者改变。 因为流程图中只是详细展示了响应式部分的变动，为了便于大家更清楚的理解这部分的流程，所以这里先解释一下 Vue 中完整的流程： 页面开始渲染，对 data 进行依赖收集； 依赖收集完毕，开始监测订阅者的方法，并存储原值方便变更时的对比； 因为依赖收集完毕，要存储原值则触发了 get 事件，此时添加 dep 依赖，将对应生成的 watcher 存储入依赖列表内 页面渲染完成，用户触发页面某些点击事件（比如按钮）； 点击事件绑定了某个 methods 方法，该 methods 方法使得 data 部分内容更新了； 因为已经对 data 进行了依赖收集，触发了对应的 set 方法； set 方法对比新旧值发现值更新了，此时重新收集依赖新的值（特别是对象的情况），然后通知它的私有管家 Dep 进行更新； Dep 依赖开始遍历其所存储的数组，为该发布者的订阅者们发送消息，触发订阅事件。 各订阅者事件触发 update 更新，此时便流转到 render 渲染，之后页面就更新啦！ 为了方便大家理解源码，这里手动实现了一个简单的 observer 模式，基本是按着源码的思路一点点撸出来的，注释很全，方便大家理解！ 个人版 vue-observer 源码 源码地址所有的 demo 都写入仓库了，仓库地址为：传送门","categories":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"分析 Vue 的观察者模式（上）","slug":"分析-Vue-的观察者模式（上）","date":"2019-10-10T07:34:04.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/10/10/分析-Vue-的观察者模式（上）/","link":"","permalink":"https://monocy.site/2019/10/10/分析-Vue-的观察者模式（上）/","excerpt":"前言最近又鼓起勇气鼓捣 vue 源码，然后不经意间瞅了瞅最早开始学习 vue 源码时跟着撸的一个 vue-observer 的实例，发现自己对于观察者模式还是有些不太明白。因此，在学习了《JavaScript 设计模式》的“观察者模式”一篇后，总算有了一点灵感。目前趁灵感还在，在此便记录下我的理解。","text":"前言最近又鼓起勇气鼓捣 vue 源码，然后不经意间瞅了瞅最早开始学习 vue 源码时跟着撸的一个 vue-observer 的实例，发现自己对于观察者模式还是有些不太明白。因此，在学习了《JavaScript 设计模式》的“观察者模式”一篇后，总算有了一点灵感。目前趁灵感还在，在此便记录下我的理解。 观察者模式什么是观察者模式呢？首先引用一下比较正规的说法： 观察者模式：又被称作发布-订阅者模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。 简单来说，观察者模式主要实现的是一种对于未来可能发生的事情做的一种消息订阅处理。DOM2 级事件中的 addEventListener 方法以及生活中的订报纸都基本上就是这种原理。 首先我们得有发布者和订阅者，他们之间如何联系起来那就需要一个观察者平台。订阅者在观察者平台上向发布者添加订阅，待发布者在发布信息后，观察者平台获取到更新的信息后，给各个订阅者发提醒表示“你关注的发布者更新了文档哦～”，这样订阅者就能得到更新后的消息内容了。 其实发布者和订阅者都很简单，关键点还是观察者这个中间平台的实现。我们最终想要的结果其实可简化为如下代码： 12345678910// 观察者（平台）function observer() &#123; /***/ &#125;// 发布者（平台作者）const publisher = &#123; bookName: 'Hello World!', content: 'This is a book' &#125;// 订阅者（在平台上订阅某作者）const subscriber = observer(publisher);// 之后 publisher 改变什么东西，observer 触发订阅的消息即可。 简单的观察者前面分析到，观察者其实就是对于发布者和订阅者的一个中间平台，因此观察者所需要的能力包括：添加订阅者、消息推送和删除订阅者。先不考虑最终自动化处理发布订阅的流程以及删除操作，手动处理的大致流程为： 平台上新增了一个订阅者，并订阅了一个发布者； 发布者更改了自身的某些属性； 平台通知订阅者，“你订阅的发布者更新了新内容”。 因此我们可以简化一个观察者模型为： 1234567891011121314151617181920212223242526272829303132333435class Observer &#123; constructor() &#123; this.subscriberList = []; &#125; // 添加订阅方法 addSubscriber(subscribFunc) &#123; if (subscribFunc &amp;&amp; !this.subscriberList.includes(subscribFunc)) &#123; this.subscriberList.push(subscribFunc); &#125; &#125; // 发布者更新消息，触发所有的订阅方法 notify() &#123; this.subscriberList.forEach(subscribFunc =&gt; subscribFunc()); &#125;&#125;// 观察者const observer = new Observer();// 发布者const publisher = &#123; bookName: 'Hello' &#125;// 订阅者const subscriber = function () &#123; console.log(`The publisher your followed update the book $&#123;publisher.bookName&#125;`);&#125;// 订阅者订阅事件需要平台完成observer.addSubscriber(subscriber);// 发布者更新消息publisher.bookName = 'Hello World';// 平台根据订阅者设置的事件通知订阅者，你有新订阅信息observer.notify(); 稍复杂的观察者前面基本上勾勒出了基本的观察者模型大致逻辑，虽然是纯“手动”操作，但是顺着这个机制走下去就没有太大问题。现在我们需要的是慢慢将“手动”转变为“自动”，而要实现这种转变则需要一些中间的封装，也就是中间的依赖类，此时我们的思路是这样的： 为每个发布者生成一个对应的依赖收集对象（类比 Vue 中 data 返回的对象） 为负责依赖收集的对象添加订阅者事件（类比 Vue 中的 methods 和 computed 内容） 发布者更新内容，订阅者事件触发 因为待依赖收集的对象总是动态变动的，因此我们还得维护一个全局的 target 对象来动态绑定当前变动的发布者，此时的代码可以抽象为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748let target = null;class Dep &#123; constructor() &#123; this.subscriberList = []; &#125; // 添加订阅方法 depend() &#123; if (target &amp;&amp; !this.subscriberList.includes(target)) &#123; this.subscriberList.push(target); &#125; &#125; // 发布者更新消息，触发所有的订阅方法 notify() &#123; this.subscriberList.forEach(sub =&gt; sub()); &#125;&#125;// 中间依赖的平台const dep = new Dep();// 发布者（data 对象中的属性，为了方便处理，直接扩出来了，写成对象也行）let bookName = \"Hello World\";let bookContent = \"This is a book\";let publishInfo = ''; // 消息提示// 绑定当前的订阅者（method 方法）const target = function () &#123; publishInfo = `The book $&#123;bookName&#125;‘s content is $&#123;bookContent&#125;`;&#125;// 订阅者还未订阅信息console.log(publishInfo); // ‘’// 订阅者在平台上添加订阅事件，并推送用户目前的最新信息dep.depend();target();console.log(publishInfo) // The book Hello World‘s content is This is a book// publisher 更新消息bookContent = 'The content is \"Hello World\"';// 平台还未处理前，原信息没有改变console.log(publishInfo) // The book Hello World‘s content is This is a book// 平台观察到 publisher 更新内容了，更新了用户的通知信息dep.notify();// 呈现更新后的信息console.log(publishInfo) // The book Hello World‘s content is The content is \"Hello World\" 与前面的相比，目前这一版的优点在于： 每个发布者都有属于自己的小管家，而不是与各订阅者一一绑定（原绑定方式：发布者 -&gt; 平台 -&gt; 订阅者），方便消息推送管理； 平台能动态绑定发布者（原来是通过订阅者显示绑定发布者）； 但是目前还有一些缺陷，那就是：还没有实现动态的观察变化 参考文章 以 Vue 为例，解释 JavaScript 的反应性","categories":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"记 JS 对象属性顺序","slug":"记-JS-对象属性顺序","date":"2019-10-09T07:28:46.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/10/09/记-JS-对象属性顺序/","link":"","permalink":"https://monocy.site/2019/10/09/记-JS-对象属性顺序/","excerpt":"前言早期与后台对接接口时，让后台区分开数组与对象的传递参数，对于为什么也仅仅只是知道对象遍历顺序无法像数组一样得到保证，具体是怎么个规则还是不太了解。最近在学习了解 Reflect 部分知识时，正好又看到了对象属性排序部分的内容，因此做个笔记记录下来，用作备忘。 该部分基本上来自书本内容，夹带一些个人理解","text":"前言早期与后台对接接口时，让后台区分开数组与对象的传递参数，对于为什么也仅仅只是知道对象遍历顺序无法像数组一样得到保证，具体是怎么个规则还是不太了解。最近在学习了解 Reflect 部分知识时，正好又看到了对象属性排序部分的内容，因此做个笔记记录下来，用作备忘。 该部分基本上来自书本内容，夹带一些个人理解 ES6 属性顺序对于 ES6 之前，一个对象的属性列出的顺序是依赖于具体实现，并未在规范中定义。虽然多数引擎按照创建的顺序进行枚举，但是开发者们一直强烈建议不要依赖这个顺序。 而对于 ES6 来说，拥有属性的列出顺序则是又 [[OwnPropertyKeys]] 算法定义的（ES6 规范 9.1.12 节），其顺序为： 首先，按照数字上升排序，枚举所有的整数索引拥有的属性； 然后，按照创建顺序枚举其余的拥有的字符串属性名； 最后，按照创建顺序枚举拥有的符号属性。 此顺序只对 Reflect.ownKeys(...) （以及扩展的 Object.getWonPropertyNames(...) 和 Object.getOwnPropertySymbols(...) ）有保证，为 [[OwnPropertyKeys]] 算法。 此算法不会遍历原型链上的属性 123456789const obj = &#123;&#125;;obj[Symbol('a')] = 'symbol property';obj[1] = 'number property';obj.str = 'string property';Reflect.ownKeys(obj); // [\"1\", \"str\", Symbol(a)]Object.getOwnPropertyNames(obj); // [\"1\", \"str\"]Object.getOwnPropertySymbols(obj); // [Symbol(a)] 枚举算法ES6 规范中还有另外一种 [[Enumerate]] 算法（ES6 规范 9.1.11 节），其只从目标对象和 prototype 原型链产生可枚举属性。其可以观察到的顺序与具体实现有关，不由规范控制。 对于日常工作中常用的 Object.keys(...)、for ... in 和 JSON.stringify(...)（还有 Reflect.enumerate(...)）基本上属于 [[Enumerate]] 算法。此四种方法虽然严格上是通过不同路径实现排序的，但将其与 [[OwnPropertyKeys]] 的排序相匹配的具体实现还是允许的，但些许又些差别： 附：本质上 Reflect.enumerate(...) 和 for ... in 的实现方式是一样的 123456789101112131415161718192021function Parent() &#123;&#125;Parent.prototype = &#123; age: 123, 2: 234, [Symbol('b')]: 345&#125;const obj = new Parent();obj[Symbol('a')] = 'symbol property';obj[1] = 'number property';obj.str = 'string property';console.log(Object.keys(obj)); // ['1', 'str']console.log(JSON.stringify(obj)); // &#123;\"1\":\"number property\",\"str\":\"string property\"&#125;// 对象 -&gt; 原型链，每一层的显示方式同上面的规范，整体上的排序则是和具体实现相关// 此处的具体实现则是先对象这一层，然后原型链层for (const prop in obj) &#123; console.log(prop); // 1 str 2 age&#125; 总结对于 ES6 来说，Reflect.ownKeys(...)、Object.getWonPropertyNames(...) 和 Object.getOwnPropertySymbols(...) 的顺序都是可预测且可靠的，这由规范保证。所以依赖这个顺序的代码是安全的。 Reflect.enumerate(...)、Object.keys(…)和for … in（以及扩展的JSON.stringify(…)）还像过去一样，可观察到顺序是相同的。但是这个顺序不再必须与Reflect.ownKeys(…)` 相同。在使用它们依赖于具体实现的顺序时要小心。 扩展阅读 Chrome Opera 中 for-in 语句遍历出对象属性的顺序与定义的不同","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"浅谈 Proxy","slug":"浅谈-proxy","date":"2019-09-21T11:39:49.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/09/21/浅谈-proxy/","link":"","permalink":"https://monocy.site/2019/09/21/浅谈-proxy/","excerpt":"前言最近阅读的 《你所不知道的 JavaScript 下篇》 基本上讲的都是 ES6 的一些知识，先前跟着阮一峰老师的 《ES6 入门》 一书，将大多数工作中常用的知识都过了一遍，但是少数稍微复杂的却都是“点到为止”，Proxy 代理正属于这一类。现在正好又学到了这一块，为了加深印象，还是写一篇博文以作记录。 此篇仅记录一些基础内容，方便理解，更为深层次的内容之后有时间进行补充。","text":"前言最近阅读的 《你所不知道的 JavaScript 下篇》 基本上讲的都是 ES6 的一些知识，先前跟着阮一峰老师的 《ES6 入门》 一书，将大多数工作中常用的知识都过了一遍，但是少数稍微复杂的却都是“点到为止”，Proxy 代理正属于这一类。现在正好又学到了这一块，为了加深印象，还是写一篇博文以作记录。 此篇仅记录一些基础内容，方便理解，更为深层次的内容之后有时间进行补充。 简介Proxy 是什么，其有什么作用？简单来说，其主要是拦截对目标对象进行的一些操作，方便定义一些基本的操作以及配置自定义的用户行为。 Proxy 的语法很简单，如下： 1const proxyObject = new Proxy(target, handler); 其中 target 为需要进行“代理”的对象，handler 则是对该对象进行拦截的一些配置了。 引： Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 handler 方法handler 总共有 13 种可代理的方法，每一种方法都有与之对应的 Reflect 函数，具体的我就不全部列举出来了，这里今介绍一些可能会常用的： getOwnPropertyDescriptor 与 defineProperty此两操作可以算是一种配套的操作，一个读取对象的属性描述符，另一个配置对象，例如： 1234567891011121314151617var target = &#123;&#125;;var p = new Proxy(target,&#123; getOwnPropertyDescriptor(target, prop) &#123; console.log('called' + prop); return Reflect.getOwnPropertyDescriptor(target, prop); &#125;, defineProperty(target, prop, descriptor) &#123; console.log('defined', prop); return Reflect.defineProperty(target, prop, descriptor); &#125;&#125;);p.age = 123;// called age// defined age 注意： 当 handler 中有设置 get/set 方法时，此两 trap 会被覆盖掉。 get 与 set此两方法一眼便知是拦截对象的读写操作，与上面的不同的是，此仅仅涉及到读与写的配置，更为详细的配置还是得依靠 defineProperty 方法。 12345678910111213141516171819202122var target = &#123;&#125;var p = new Proxy(target,&#123; get(target, prop)&#123; console.log('get', prop) return Reflect.get(target, prop) || '-'; // 直接 target[prop] 结果也一致 &#125;, set(target, prop, value, receiver) &#123; console.log('set', prop, value); return Reflect.set(target, prop, value, receiver); &#125;&#125;);p.a = 123;console.log(p.a);// set a 123// get a// 123 apply 与 construct此两方法主要用于扩展构造函数，例如 MDN 上的 extend 的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function extend(sup, base) &#123; // 获取 base 的 constructor 描述（不是原型链描述，而是构造函数描述） // base === base.prototype.constructor var descriptor = Object.getOwnPropertyDescriptor( base.prototype, \"constructor\" ); // base 的 prototype 继承 sup 的 prototype base.prototype = Object.create(sup.prototype); // 添加 base 构造函数的代理 var handler = &#123; // new 对象时为目标对象绑定 __proto__ 链（就是手动实现 new 的过程） construct: function(target, args) &#123; // 创建目标函数 var obj = Object.create(base.prototype); // 注：this 为 handler 对象，触发 apply 方法，绑定示例属性 this.apply(target, obj, args); // 返回目标函数 return obj; &#125;, // 调用目标函数时，将 sup 的 base 的作用域绑定至实例对象 // 也就是原来构造函数的那种 apply/call 写法 apply: function(target, that, args) &#123; sup.apply(that, args); base.apply(that, args); &#125; &#125;; var proxy = new Proxy(base, handler); // 构造函数添加代理拦截 descriptor.value = proxy; Object.defineProperty(base.prototype, \"constructor\", descriptor); // 返回配置后的代理 return proxy;&#125;var Person = function(name)&#123; this.name = name&#125;;// 注意 name 需写在 age 前面，与父类保持一致// 内部不在需要 apply/call 方法，已经通过代理处理了var Boy = extend(Person, function(name, age) &#123; this.age = age;&#125;);Boy.prototype.sex = \"M\";// 此才会出发 handlervar Peter = new Boy(\"Peter\", 13);console.log(Peter.sex); // \"M\"console.log(Peter.name); // \"Peter\"console.log(Peter.age); // 13 参考文章 Proxy ES6 Proxy MDN handler MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"IntersectionObserver 与延迟加载","slug":"IntersectionObserver-与延迟加载","date":"2019-09-10T11:18:42.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/09/10/IntersectionObserver-与延迟加载/","link":"","permalink":"https://monocy.site/2019/09/10/IntersectionObserver-与延迟加载/","excerpt":"前言随着项目图表使用的复杂程度的提升，“大数据”与多图表渲染带来的影响是页面响应慢、用户体验随时间越来越糟。通过 chrome 的 performance 分析出的原因是：接口耗时基本可忽略不计，页面渲染耗时才是对用户体验的真正影响。因此如何更“智能”的加载渲染的图表才是问题解决的关键，而这就要聊到“延迟加载”了。","text":"前言随着项目图表使用的复杂程度的提升，“大数据”与多图表渲染带来的影响是页面响应慢、用户体验随时间越来越糟。通过 chrome 的 performance 分析出的原因是：接口耗时基本可忽略不计，页面渲染耗时才是对用户体验的真正影响。因此如何更“智能”的加载渲染的图表才是问题解决的关键，而这就要聊到“延迟加载”了。 延迟加载延迟加载比较通俗的说法为“懒加载”，其使用的场景都是在页面加载时优先加载关键资源（比如整体的页面轮廓等），非关键资源则在需要时才进行加载。 那为什么需要延迟加载呢？有需必有求，首先看看直接加载所导致的一些问题： 加载过多无用内容，造成数据流量的浪费，增加浏览器压力。 渲染时间增长，用户等待时间增长，会造成部分用户流失。 浪费处理时间、电池电量和其它系统资源 为了增强用户体验，因此我们需要进行延迟加载。 getBoundingClientRect早期还没有 IntersectionObserver 时，为了支持延迟加载，我们常使用的方法是 Element.getBoundingClientRect()。通过该方法来获取目标元素的大小以及其相对于视口的位置，从而来判断是否加载需要渲染的内容。 其语法为： 123456789const targetElement = document.getElementById('id');const rectObject = targetElement.getBoundingClientRect();rectObject.top // 元素上边到视窗上边的距离;rectObject.right // 元素右边到视窗左边的距离;rectObject.bottom // 元素下边到视窗上边的距离;rectObject.left // 元素左边到视窗左边的距离;rectObject.width // 是元素自身的宽rectObject.height // 是元素自身的高 例子： 既然有了 getBoundingClientRect 方法，那么为什么还需要 IntersectionObserver 方法呢？这里引用 MDN 上的一段话： 过去，交集检测通常需要涉及到事件监听，以及对每个目标元素执行 Element.getBoundingClientRect() 方法以获取所需信息。可是这些代码都在主线程上运行，所以任何一点都可能造成性能问题。当网页遍布这些代码时就显得比较丑陋了。 简而言之，getBoundingClientRect 方法对于需要监听大量对象的情况，其处理并不是特别完美（比如无限滚动，scroll 事件发生过于密集，容易造成性能问题），而这种情况下 IntersectionObserver 可以比较完美的解决这个问题。 IntersectionObserver首先 IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发（即我们不用监听 scroll 事件了）。此外，该观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。 这里再一次引用 MDN 上的解释： Intersection Observer API 会注册一个回调方法，每当期望被监视的元素进入或者退出另外一个元素的时候(或者浏览器的视口)该回调方法将会被执行，或者两个元素的交集部分大小发生变化的时候回调方法也会被执行。通过这种方式，网站将不需要为了监听两个元素的交集变化而在主线程里面做任何操作，并且浏览器可以帮助我们优化和管理两个元素的交集变化。 少了对滚动事件的处理，在不考虑兼容性的情况下，性能方面肯定优于 getBoundingClientRect。那么它具体该如何使用呢？Demo 如下： 12345678910// 创建一个 observerconst io = new IntersectionObserver(callback, options);// 监听目标元素io.observe(element);// 停止目标元素的监听io.unobserve(element);// 终止对所有目标元素可见性变化的观察io.disconnect(); 上面代码中，callback 是触发可见行变化时的回调函数，options 是配置对象。 options首先看看 options 配置，其总共有三个属性：root、rootMargin 和 threshold。 root 指选定的目标容器，默认为浏览器的视窗。 rootMargin 定义元素的 margin，viewport + rootMargin 为最终计算的视窗大小，这里引用一张图 threshold 属性决定了什么时候触发回调函数。它是既可以是一个单一的 number 也可以是一个 number 数组，其表示目标元素和 root 元素相交程度达到该值的时候，callback 回调函数将会被执行。 1234567new IntersectionObserver( (entries, observer) =&gt; &#123; /* ... */ &#125;, &#123; // 在相交程度为 0、25%、50%、75%、100% 时触发回调 threshold: [0, 0.25, 0.5, 0.75, 1] &#125;); callback当目标元素可见行变化时，其会触发 callback 函数，一般情况该函数会触发2次（进入和离开）。该函数有两个参数： IntersectionObserverEntry 对象 和 观察者 的列表。 123456789101112131415161718192021222324252627282930const callback = function(entries, observers) &#123; entries.forEach(entry =&gt; &#123; // Each entry describes an intersection change for one observed // target element: // entry.rootBounds // entry.boundingClientRect // entry.intersectionRect // entry.intersectionRatio // entry.isIntersecting // entry.target // entry.time &#125;);&#125;;🔽[IntersectionObserverEntry] time: 3893.92 🔽rootBounds: ClientRect bottom: 920 height: 1024 left: 0 right: 1024 top: 0 width: 920 🔽boundingClientRect: ClientRect // ... 🔽intersectionRect: ClientRect // ... intersectionRatio: 0.54 🔽target: div#observee // ... rootBounds： root 元素调用 getBoundingClientRect() 函数的返回值（默认是 viewport 视口） boundingClientRect： 目标 observer 调用 getBoundingClientRect() 函数的返回值 intersectionRect： 上述两矩形的交集，并且有效的告诉你观测到的元素的哪一部分是可见的 intersectionRect： 该属性告诉你元素目前有多少是可见的，比率是多少 isIntersecting： 目标元素在 root 元素中可见性是否发生了变化（至少得达到 thresholds 数组中的一个阈值） target： 被观测的目标 DOM 元素 time： 可见行发生变化的时间（单位： ms） 再次引用一张图片来解释上述部分参数： 请留意，你注册的回调函数将会在主线程中被执行。所以该函数执行速度要尽可能的快。如果有一些耗时的操作需要执行，建议使用 Window.requestIdleCallback() 方法。 实战：无限滚动 文章推荐 Trust is Good, Observation is Better—Intersection Observer v2 延迟加载图像和视频 参考文章 IntersectionObserver’s Coming into View Intersection Observer API getBoundingClientRect IntersectionObserver API 使用教程 谈谈 IntersectionObserver 懒加载","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"JSX 语法总结","slug":"JSX-语法总结","date":"2019-09-01T08:12:23.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/09/01/JSX-语法总结/","link":"","permalink":"https://monocy.site/2019/09/01/JSX-语法总结/","excerpt":"前言最近着手编写 JSON 可视化部分的内容，由于此部分需要基于基础组件进行封装，Vue 的 JSX 的写法用的比较频繁，此处就记录我目前所能总结出的 JSX 的写法，以做备忘。","text":"前言最近着手编写 JSON 可视化部分的内容，由于此部分需要基于基础组件进行封装，Vue 的 JSX 的写法用的比较频繁，此处就记录我目前所能总结出的 JSX 的写法，以做备忘。 基础写法Vue 官网对于 JSX 语法和 Template 语法已经做了很详细的对比了，在此我就不做赘述，此处就仅仅引用一下 JSX 的写法。 创建一个 VNode 的写法1234567891011121314151617181920212223242526// @returns &#123;VNode&#125;createElement( // &#123;String | Object | Function&#125; // 一个 HTML 标签名、组件选项对象，或者 // resolve 了上述任何一种的一个 async 函数。必填项。 'div', // &#123;Object&#125; // 一个与模板中属性对应的数据对象。可选。 &#123; // (详情见下一代码块) &#125;, // &#123;String | Array&#125; // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成， // 也可以使用字符串来生成“文本虚拟节点”。可选。 [ '先写一些文字', createElement('h1', '一则头条'), createElement(MyComponent, &#123; props: &#123; someProp: 'foobar' &#125; &#125;) ]) VNode 中的数据对象的写法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#123; // @params &#123; String, Object &#125; // 与 `v-bind:class` 的 API 相同， // 接受一个字符串、对象或字符串和对象组成的数组 'class': &#123; foo: true, bar: false &#125;, // @params &#123; String, Object &#125; // 与 `v-bind:style` 的 API 相同， // 接受一个字符串、对象，或对象组成的数组 style: &#123; color: 'red', fontSize: '14px' &#125;, // 普通的 HTML 特性 attrs: &#123; id: 'foo' &#125;, // 组件 prop props: &#123; myProp: 'bar' &#125;, // DOM 属性 domProps: &#123; innerHTML: 'baz' &#125;, // 事件监听器在 `on` 属性内， // 但不再支持如 `v-on:keyup.enter` 这样的修饰器。 // 需要在处理函数中手动检查 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅用于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ &#123; name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // 作用域插槽的格式为 // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; createElement('span', props.text) &#125;, // 如果组件是其它组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其它特殊顶层属性 key: 'myKey', ref: 'myRef', // 如果你在渲染函数中给多个元素都应用了相同的 ref 名， // 那么 `$refs.myRef` 会变成一个数组。 refInFor: true&#125; 模板修饰符的一些兼容写法 假设此处已经配置了 Babel 插件 v-if 和 v-for 的实现1234567// v-if 的实现props: &#123; isSection: &#123; type: Boolean, default: false &#125;&#125;,render() &#123; return this.isSection ? &lt;div&gt;&lt;/div&gt; : &lt;section&gt;&lt;/section&gt;&#125; 12345678910111213141516// v-for 的实现props: &#123; pList: &#123; type: Array, default: () =&gt; [] &#125;&#125;,render() &#123; return ( &lt;div&gt; &#123; this.pList.map(config =&gt; &#123; const methods = &#123; props: config &#125; return &lt;p &#123;...methods&#125;&gt;&lt;/p&gt; &#125;) &#125; &lt;/div&gt; )&#125; v-model 的实现1234567891011121314151617props: &#123; value: &#123; type: String, default: '' &#125;&#125;,render() &#123; const methods = &#123; domProps: &#123; value: this.value &#125;, on: &#123; input: function (e) &#123; this.$emit('input', e.target.value) &#125; &#125; &#125; return &lt;input &#123;...methods&#125;&gt;&lt;/input&gt;&#125; 修饰符 修饰符 前缀 .passive &amp; .capture ! .once ~ .capture.once 或 .once.capture ~! 例如： 12345on: &#123; '!click': this.doThisInCapturingMode, '~keyup': this.doThisOnce, '~!mouseover': this.doThisOnceInCapturingMode&#125; 其余的修饰符如下： 修饰符 处理函数中的等价操作 .stop event.stopPropagation() .prevent event.preventDefault() .self if (event.target !== event.currentTarget) return 按键： .enter, .13 if (event.keyCode !== 13) return (对于别的按键修饰符来说，可将 13 改为另一个按键码) 修饰键： .ctrl, .alt, .shift, .meta if (!event.ctrlKey) return (将 ctrlKey 分别修改为 altKey、shiftKey 或者 metaKey) 例如： 12345678910111213141516on: &#123; keyup (event) &#123; // 如果触发事件的元素不是事件绑定的元素 // 则返回 if (event.target !== event.currentTarget) return // 如果按下去的不是 enter 键或者 // 没有同时按下 shift 键 // 则返回 if (!event.shiftKey || event.keyCode !== 13) return // 阻止 事件冒泡 event.stopPropagation() // 阻止该元素默认的 keyup 事件 event.preventDefault() // ... &#125;&#125; 简化写法简化写法需要项目引入对应的 Babel 支持，简化后我们可以直接返回对应的 html 写法，其又有两种编写方法： 123456&lt;!-- 行内属性 --&gt;&lt;div props=&#123;&#123; propName: 123 &#125;&#125;&gt;&lt;/div&gt;&lt;!-- 解构属性 --&gt;const methods = &#123; propName: 123 &#125;&lt;div &#123;...methods&#125;&gt;&lt;/div&gt; 由于第二种写法更助于逻辑与结构分离，个人更偏向于第二种写法风格。 参考文章 渲染函数 &amp; JSX Scoped Slots in JSX Babel Preset JSX","categories":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"Vue 代码规范配置","slug":"Vue-代码规范配置","date":"2019-08-23T05:10:27.000Z","updated":"2021-03-17T06:06:03.013Z","comments":true,"path":"2019/08/23/Vue-代码规范配置/","link":"","permalink":"https://monocy.site/2019/08/23/Vue-代码规范配置/","excerpt":"前言工欲善其事，必先利其器。一个好的规范能使的团队开发的效率提升一倍，因此，一个好的规范对于一个团队来说是必不可少的。此处记录我为所在团队维护的一套前端规范相关的配置。 推荐阅读：Mac 环境配置 的 “配置 VScode” 部分，通过 Sync 安装我总结的插件可不用关心以下的配置，默认配置好。","text":"前言工欲善其事，必先利其器。一个好的规范能使的团队开发的效率提升一倍，因此，一个好的规范对于一个团队来说是必不可少的。此处记录我为所在团队维护的一套前端规范相关的配置。 推荐阅读：Mac 环境配置 的 “配置 VScode” 部分，通过 Sync 安装我总结的插件可不用关心以下的配置，默认配置好。 VSCode 配置在项目根目录下新建一个 .vscode 文件夹，然后在该文件内创建一个 settings.json 文件，粘贴以下内容即可： 注意：该部分配置需要安装两个必须的 VSCode 插件： Vetur 和 ESLint。 1234567891011121314151617181920212223242526272829303132&#123; // 编辑器部分 \"editor.tabSize\": 2, \"editor.fontSize\": 15, \"editor.wordWrap\": \"on\", \"editor.formatOnSave\": true, \"editor.renderWhitespace\": \"none\", \"editor.multiCursorModifier\": \"ctrlCmd\", \"editor.defaultFormatter\": \"octref.vetur\", \"editor.codeActionsOnSave\": &#123; \"source.fixAll\": true &#125;, \"files.insertFinalNewline\": true, /** * 代码配置 */ // eslint 部分 \"eslint.run\": \"onSave\", \"eslint.validate\": [\"typescriptreact\", \"typescript\"], // vetur 部分 \"vetur.format.defaultFormatter.css\": \"prettier\", \"vetur.format.defaultFormatter.less\": \"prettier\", \"vetur.format.defaultFormatter.js\": \"vscode-typescript\", \"vetur.format.defaultFormatter.ts\": \"vscode-typescript\", \"vetur.format.defaultFormatter.html\": \"prettyhtml\", \"vetur.format.defaultFormatterOptions\": &#123; \"prettyhtml\": &#123; \"printWidth\": 75, \"singleQuote\": false &#125; &#125;&#125; ESlint 配置此处配置的 ESlint 为 TS 环境下的 typescript-eslint 的配置。配置文件为：.eslintrc.js。 123456789101112131415161718192021222324252627282930313233343536module.exports = &#123; root: true, env: &#123; browser: true, commonjs: true, es6: true, &#125;, parserOptions: &#123; parser: '@typescript-eslint/parser', sourceType: 'module', &#125;, extends: ['plugin:vue/essential', '@vue/standard', '@vue/typescript'], rules: &#123; 'no-var': 'error', 'arrow-parens': 'off', semi: 'off', '@typescript-eslint/semi': ['error'], 'eol-last': 'off', '@typescript-eslint/no-unused-vars': [ 'error', &#123; vars: 'local', args: 'none', ignoreRestSiblings: true, &#125;, ], 'generator-star-spacing': 'off', camelcase: ['error', &#123; properties: 'never' &#125;], 'space-before-function-paren': [ 'error', &#123; anonymous: 'always', named: 'never' &#125;, ], 'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off', 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', &#125;,&#125;; tsconfig.json 配置12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; \"compilerOptions\": &#123; \"allowSyntheticDefaultImports\": true, \"baseUrl\": \".\", \"checkJs\": false, \"esModuleInterop\": true, \"importHelpers\": true, \"experimentalDecorators\": true, \"jsx\": \"preserve\", \"jsxFactory\": \"h\", \"lib\": [ \"esnext\", \"dom\", \"dom.iterable\", \"scripthost\" ], \"module\": \"esnext\", \"moduleResolution\": \"node\", \"paths\": &#123; \"@/*\": [ \"src/*\" ] &#125;, \"pretty\": true, \"sourceMap\": true, \"strict\": true, \"target\": \"esnext\", \"types\": [ \"webpack-env\" ] &#125;, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"tests/**/*.ts\", \"tests/**/*.tsx\" ], \"exclude\": [ \"node_modules\", \"public\" ]&#125; 相关依赖（项目由非 TS -&gt; TS）： 12345678910111213141516&#123; \"devDependencies\": &#123; \"@babel/core\": \"^7.0.0-0\", \"@babel/plugin-syntax-jsx\": \"^7.2.0\", \"@vue/cli-plugin-babel\": \"^3.7.0\", \"@vue/cli-plugin-eslint\": \"^3.0.5\", \"@vue/cli-plugin-typescript\": \"^3.8.1\", \"@vue/cli-service\": \"^3.0.5\", \"@vue/eslint-config-standard\": \"^4.0.0\", \"@vue/eslint-config-typescript\": \"^4.0.0\", \"babel-eslint\": \"^10.0.1\", \"eslint\": \"^5.8.0\", \"eslint-plugin-vue\": \"^5.0.0-0\", \"typescript\": \"^3.4.3\" &#125;&#125; Stylelint 配置此部分规范 css 和 less 语法，配置文件为： stylelint.config.js。 12345678910111213141516module.exports = &#123; extends: 'stylelint-config-standard', ignoreFiles: ['**/*.js', '**/*.md', '**/*.png', '**/*.json'], rules: &#123; indentation: 2, 'color-hex-case': 'lower', 'string-quotes': 'single', 'color-hex-length': 'long', 'number-leading-zero': 'never', 'rule-empty-line-before': null, 'no-descending-specificity': null, 'no-missing-end-of-source-newline': false, 'selector-pseudo-element-colon-notation': null, 'selector-list-comma-newline-after': 'always-multi-line', &#125;,&#125;; 相关依赖： 123456&#123; \"devDependencies\": &#123; \"stylelint\": \"^10.1.0\", \"stylelint-config-standard\": \"^18.3.0\" &#125;&#125; 规范参考 Code Guide 风格指南","categories":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/categories/环境/"}],"tags":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/tags/环境/"}]},{"title":"前端缓存查询状态","slug":"前端缓存查询状态","date":"2019-08-15T08:38:59.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/08/15/前端缓存查询状态/","link":"","permalink":"https://monocy.site/2019/08/15/前端缓存查询状态/","excerpt":"前言为了提升用户的使用体验，多数场合我们都会对表单场景做一些缓存。当然最简单的情况是弹框处理下钻页面，这样基本上不用考虑换页返回时的状态缓存问题了，然而并不是所有的需求都满足这种场景，此处我就记录一下这次做缓存时的一些策略选择和遇到的问题。","text":"前言为了提升用户的使用体验，多数场合我们都会对表单场景做一些缓存。当然最简单的情况是弹框处理下钻页面，这样基本上不用考虑换页返回时的状态缓存问题了，然而并不是所有的需求都满足这种场景，此处我就记录一下这次做缓存时的一些策略选择和遇到的问题。 背景在做项目迭代时，第一期因为时间的原因，在保证原有功能的情况下，并没有做缓存处理。在这一期的项目迭代时，应用户和产品的需求，在原有的逻辑基础上添加了缓存处理。要求仅从下钻页面返回时保留离开的状态，否则呈现默认的状态。 项目结构项目总体有三层： 登陆与权限判断层 公共路由层 业务页面层 登陆与权限判断层主要处理用户的登陆信息和对应页面的权限拦截，对于无页面权限的跳转和未登录状态做重定向处理，此外全局 vuex 存储获得的页面信息。 公共路由层主要处理获取的页面路由结构，同时与权限路由的菜单配置绑定，为各页面具体的权限约束提供对应的配置方法，方便产品将其与用户角色做相关绑定。 业务页面层仅关注对应业务逻辑的开发以及相关权限控制，统一接口和方法处理权限。 缓存方案实现缓存的方法有多个，当前考虑的可行的方案有三种，分别是： vuex 做查询缓存 keep-alive 做页面缓存 webStorage 做条件缓存 首先说一下最后选择的方案是：sessionStorage 做条件缓存。这里分别来分析一下各方案的优缺点。 vuex 方案vuex 方案是最容易想到的一个方案，毕竟对于跨页面的单页应用来说，在数据的传递上可谓是非常便捷的，对于查询缓存来说，其优点如下： 获取数据和传递数据容易 存储数据的操作简单，代码量不大 但是其缺点也很明显： 子页面刷新再返回会导致缓存的数据清空 无论是从子页面还是从别的页面切换回来，此都会缓存查询条件 缺点的解决思路： 对于数据会清空的问题，vuex 需要配合 webStorage 对刷新情况做处理； 对于任意页面都会缓存查询条件问题，又需要配合路由来做处理。 keep-alive 方案keep-alive 方案与 vuex 方案基本差别不带，其缓存整个组件的状态，来保证跳转至其它组件后，当前组件的状态不改变。与 vuex 写法相比，其优点还包括： 整体的状态能得以保存，无需过多的数据缓存处理 但是其缺点相对 vuex 来说，也有一些： 页面参数共享不是很方便 每新增一个缓存页面都需要更新一下 include 数组 缺点的解决思路：与 vuex 的解决思路基本一致，但是此还有另外一种操作方法 keep-alive 还有一种配合路由 meta 的操作写法。但是由于项目路由基本上是动态的，有后台提供相应的路由结构，配置相应的字段还需要与后台沟通，如果考虑不是很充足对于之后的开发也不是很友好；此外，该方法对于页面回退情况有相应问题（刷新同样无法处理）。因此此方案 pass 了。 webStorage 方案鉴于之前的两种方案都包含路由的处理以及 webStorage 的使用，从代码复杂度来衡量，最终还是选用了此方法。具体的思路为： 路由层添加 $route 的监听，并将其存入路由的 vuex 内，存储页面的 to 与 from。 子页面删除 mount 钩子，监听对应的 from 的路由，并设置 immediate: true，为需要赋值缓存的页面做单独赋值处理，否则不做操作（如有默认查询则设置默认查询） 在触发查询操作之前，缓存查询条件至对应的 sessionStorage 当然，这种方法并不是说缺点很少，其实它也有一些痛点没有解决： 难以抽象出通用的处理逻辑，仅能对路由层级做一层简单的抽象和存储 默认值赋值操作比较麻烦，特别是组件拆分比较细的情况 需要控制好 nextTick 问题总结inject 和 provide在使用 vuex 对监听的路由参数做缓存之前，首先考虑的是 inject 和 provide 来做动态传递，毕竟业务组件都在同一个 router-view 之下，这样做参数透传原则上是可行的。 但是问题是，不知道为何，对于 from 的路由总是监听不到，inject 获取的值一直为 undefined（即使能打印出来结果）。由于使用 JSON.stringfy 分析 from 时会报错，暂时也没法处理该问题，因此采用了 vuex 的备选方案。 class 风格的 ProvideReactive 还没有做过尝试，之后看能否可行 分页问题在赋值默认值时，由于分页参数会存储在传参之中，但是总数值不会。虽然做初始化赋值之后查询内容与预期的结果一致，但是唯独分页组件的当前页数不正确（element UI 的 el-pagination），无论 currentPage 值为多少，其最终显示的结果仍然为 1。 原因： el-pagination 处理分页逻辑时，在 total / pageSize &lt; currentPage 的情况，其会使用默认的 internalCurrentPage 值，而此属性的默认值为 1。在查询完结果后在为对应的 total 和 currentPage 赋值时，因为 currentPage 和查询返回值是一致的，对于相同值的情况，其 internalPageCount 的新旧值就判断一致了，因此 pager 的显示就会一直为 1。 解决：解决思路是在初始化时将 count 值设置大一些，或者缓存上一次的 count 值，然后初始化赋值。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/tags/Vue/"}]},{"title":"ES6 模块","slug":"ES6-模块","date":"2019-08-11T11:57:03.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/08/11/ES6-模块/","link":"","permalink":"https://monocy.site/2019/08/11/ES6-模块/","excerpt":"前言作为 JS 中最重要的代码组织模式，了解 ES6 模块也是很有必要的。在最近的阅读学习过程中，对于模块这部分也略有心得，在此记录一下习得的知识。 知识点来自《你所不知道的 JavaScript 下卷》","text":"前言作为 JS 中最重要的代码组织模式，了解 ES6 模块也是很有必要的。在最近的阅读学习过程中，对于模块这部分也略有心得，在此记录一下习得的知识。 知识点来自《你所不知道的 JavaScript 下卷》 旧方法在程序编写过程中，我们有时候需要一个包含内部变量和函数的外层函数，来实现面向接口式的编程。例如： 1234567891011// 目标功能function Hello(name) &#123; function greeting() &#123; console.log('hello' + name + '!'); &#125; // 公共 API return &#123; greeting: greeting &#125;&#125; 每一次调用 Hello 我们都会生成一个新的实例，如果我们仅需要单例的话，此常见的变形便是闭包（IIFE）了，如： 123456789101112var hello = (function(name) &#123; function greeting() &#123; console.log('hello' + name + '!'); &#125; // 公共 API return &#123; greeting: greeting &#125;&#125;)('katty');hello.greeting(); // hello katty ! 新方法“新方法”其实有很多，比如 UMD、AMD和CommonJS等，但是此处仅仅介绍 ES6 的模块方法，毕竟基于语言官方推荐的模块导出引入，必将成为未来的主流方法。 支撑起 ES6 模块的两个主要关键字是 export 和 import，此两方法必须出现在所有代码块和函数的外面（如：不能放在 if 方法内），下面详细介绍一下。 导出方法export 关键字即表示模块的导出。导出的方式有很多种，比如： 12345// 命名导出export const arrPos = 1;// 默认导出export default function bar() &#123;&#125; 对于一个 ES6 模块来说，没有 export 表示的任何变量或者函数，其都是作用域内部私有的。 此外，一个模块内（即一个 js 文件内）只有一个默认导出方法，但是可以有多个命名导出的方法，下面就介绍一下“命名导出”。 命名导出首先我们得注意的是，命名导出导出的是变量的引用，而非值的拷贝。例如： 123// bar.jsexport let num = 2;num = 3; 对于之后引用 bar.js 文件的 num 属性时，我们获得的 num 值为 3。 此外，命名导出还有许多变体，例如： 12345678function foo() &#123;&#125;function baz() &#123;&#125;// ES6 的简略写法export &#123; foo, baz &#125;// 更改导出名称export &#123; foo as bar, baz &#125; 既然有更改导出的名称的写法，那么我们能不能更改默认导出的绑定内容呢？答案是可以的。我将其称之为“动态默认导出”。 动态默认导出所谓动态默认导出，即它能够动态的改变默认导出的内容而不影响其余代码的更改。例如： 1234567let foo = 42;export &#123; foo as default &#125;;export let bar = \"hello world\";foo = 10;bar = \"cool\"; 当倒入这个模块时， default 和 bar 会默认绑定到局部变量 foo 和 bar，即它们会暴露更新后的值 10 和 “cool”。 注：导出时刻的值是无关紧要的，导入时候的值也是，绑定是活连接，所以重要的是访问这个绑定时刻的当前值。 导出内容能够动态改变，那么这样能否减少我们对模块导入时的代码量呢？那么看看“动态模块导出”吧。 动态模块导出对于公共文件夹内文件来说，初期文件不多的情况我们经常会这么引用： 1import ModuleA from './common/module-a'; 然而，当文件越来越多时，这种写法就比较笨拙了，因此我们可以维护一个公共 index.ts 文件来中心化文件导出： 12345678910111213// index.tsimport ModuleA from './module-a';import ModuleB from './module-b';export &#123; ModuleA, ModuleB&#125;export default &#123; ModuleA, ModuleB&#125; 当然，这种写法基本能解决模块引入问题，然而缺点是每次新增文件后，都需要改 3 处，变动的点相对太多了。因此为了减少改变的代码量，我们可以使用“动态模块导出”法： 123// 动态模块导出export &#123; default as ModuleA &#125; from './module-a';export &#123; default as ModuleB &#125; from './module-b'; 这样每次变动后，我们只需要新增一行即可，代码的改变量就很少了。 导入方法与 export 相同，import 导入同样也有相应的变体，比如： 123456789// 全量导入import ModuleA from './module-a';import &#123; default as ModuleA &#125; from './module-a';// 部分导入import &#123; foo &#125; from './module-a';// 变名导入import &#123; bar as foo &#125; from './module-a'; 当然，我们还可以将默认导入和其他命名导入一起导入。加入我们有这么一个导出的模块，例如： 123export default function foo() &#123;&#125;export function bar() &#123;&#125; 那么导入这个模块的默认导出和它的命名导出的写法为： 1import Foo, &#123; bar &#125; from './module-a'; ES6 模块这些强烈建议的方法是，只从模块导入需要的具体绑定。如果一个模块提供了 10 个 API 方法，但是你只需要其中的 2 个，有些人坚信将所有的 API 绑定都导入进了是一种浪费。 因此他们提倡的是“窄导入”（没有 export default），这样除了代码更加清晰外，其另一个好处是使得静态分析和错误检测（比如意外使用了错误的绑定名称）更加健壮。 然而这种方法的缺点是比较繁复、每次新增东西时都得更新 import 方法（特别是需要全量导入的情况），因此 import 又有一种语法变体可以支持这种模块的导入，称为“命名空间导入” 命名空间导入命名空间导入就是将模块内所有的导出内容（包括默认导出的内容）都归纳在一个命名空间内，如： 12345678// 导出模块// foo.tsexport function bar() &#123;&#125;export let name = \"myName\";export function baz() &#123;&#125;// 导入模块import * as foo from \"foo\" 注意，如果对应的导出模块有 default 导出时，使用 * as xxx 全量引入时，我们可以通过 xxx.default 来获取/使用默认导出的内容。 模块依赖环模块部分最令人疑惑的是 A 导入 B，然后 B 导入 A，这种情况是如何工作的。 首先“模块A”： 1234567// A 模块import bar from \"B\";export default function foo(x) &#123; if (x &gt; 10) return bar(x - 1); return x * 2;&#125; 然后是“模块B”： 1234567// B 模块import foo from \"A\";export default function bar(y) &#123; if (y &gt; 5) return foo(y / 2); return y * 3;&#125; 在 ES6 的模块下，改两声明处于不同的作用域内，因此其需要额外的工作来支持这样的循环引用。下面是粗略概念的意义上循环的 import 依赖如何生效和解析的过程： 如果先加载“模块A”，第一步是扫描这个文件分析所有的导出，这样就可以注册所有可以导入的绑定。然后处理 import … from “B”。 引擎加载“模块B”之后，会对它的导出绑定进行同样的分析。当看到 import … from “A”，它已经了解 “A” 的 API，所以可以验证 import 是否有效。现在它了解 “B” 的 API，就可以验证等待的 “A” 模块中 import … from “B” 的有效性。 现在让我们验证一下这两个模块： 1234567// 引用 fooimport foo from \"A\";foo(25); // 11// 引用 barimport bar from \"bar\";bar(25); // 11.5","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"搭建私人 git 仓库","slug":"搭建私人-git-仓库","date":"2019-08-04T09:57:18.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/08/04/搭建私人-git-仓库/","link":"","permalink":"https://monocy.site/2019/08/04/搭建私人-git-仓库/","excerpt":"前言本文原来维护在 segmentfault 上，由于本周时间不是很充足，因此将原来的文章维护至本博客，之后时间充裕的时候再补充一篇。本文简单介绍一下如何在自己服务器上搭建死人的 git 仓库，毕竟近期的 github 也不算是十分安全~还是有必要了解一下私人 git 仓库的搭建之法的。","text":"前言本文原来维护在 segmentfault 上，由于本周时间不是很充足，因此将原来的文章维护至本博客，之后时间充裕的时候再补充一篇。本文简单介绍一下如何在自己服务器上搭建死人的 git 仓库，毕竟近期的 github 也不算是十分安全~还是有必要了解一下私人 git 仓库的搭建之法的。 客户端配置安装 git官方下载 git 安装包，根据提示安装即可，Git 官网。 安装完成后配置个人的 git 信息，在 git bash 中输入以下信息。 12git config --global user.name \"your name\"git config --global user.email \"your email\" 创建 sshkey在 bash 中输入以下信息，看有没有配置 ssh 123cd ~/.ssh# 如果没有报错则打印下 pub 信息，之后会用到。cat .\\id_rsa.pub 下面为创建 ssh-key 的方法 12# 默认生成 SSH-2 的 RSA 密钥，密码部分直接回车即可ssh-keygen -t rsa -C \"mailaddress@example.com\" 远程配置（ubuntu 16）创建 git 用户123456# 检验用户是否已经存在id git# 不存在则创建一个 git 用户(会有提示创密码)adduser git# 给 git 配置 sudo 权限usermod -aG sudo git 注： 非 root 权限需要加 sudo 配置 Git安装/更新 git 1234apt-get install git# 初始化个人信息git config --global user.name \"your name\"git config --global user.email \"your email\" 配置仓库12345678# 选取合适的位置，创建 xxx.git 文件夹（必须 .git 结尾）mkdir /data/git/yourname.git# 创建空远程仓库git init --bare data/git/yourname.git# 将仓库拥有着改为 git 用户chown -R git:git yourname.git# 切换用户(切不切都无所谓，不切注意后面得改拥有者)su git 注： 更改用户拥有者这一步，如果你是在 root 用户下建立文件的话需要更改，如果先切换成 git 用户了，那么就不需要改，可用 ll 或 ll -a 命令查看 配置认证用户信息123456789101112131415161718192021# 配置 ssh_configcd /etc/sshsudo vi sshd_config# 解开注释，如果注释了的话RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile %h/.ssh/authorized_keys# 重启服务（ubuntu 的 sshd 位置和其他博客写的不一样……），cd /etc/init.d，你可以在这里看到 sshsudo service ssh restart# 进入 git 用户目录下，创建认证文件。注：此 .ssh 文件夹权限必须为 gitcd home/gitsudo mkdir .sshcd .sshsudo vi authorized_keys# 然后此处粘贴客户端先前打印的的 rsa 的 pub 文件内容# 修改仓库权限cd /home/gitsudo chmod 700 .sshsudo chmod 600 .ssh/authorized_keys 在此仓库就配完了。 注： 很多博客没有 %h 这个东西，查了下 askubuntu ，这个貌似就是指 home 服务器自动部署配置添加 hook12345678// 进入所创仓库的 hooks 文件目录cd /data/git/server.git/hooks/sudo vi post-receive// 写入如下内容#/bin/shGIT_WORK_TREE=yourFileAddress git checkout -f// 保存后改下权限即可chmod +x post-receive 注： yourFileAddress 的拥有者应该是 git 用户 扩展知识如何测试账户的连接情况1ssh -T user@host 其中： user：远程分支的通过 adduser 创建的用户，一般创建 git 用户管理 git 相关内容 host：服务器地址，可以直接用 ip 地址，有域名的可以写域名 例：ssh -T git@github.com 关于关闭 bash 登陆系统问题。此主要配置禁止通过 git 来登陆服务器，为了服务器安全性建议配置一下： 12sudo vi /etc/passwd# 然后将 git 用户的那行的 /bin/bash 改成 /usr/bin/git-shell 注：如果出现错误，请自行查找该系统下的 git-shell 在哪个文件路径，默认应该是 /usr/bin 内 关于 600 和 700 权限问题。语法： 1chmod abc file 其中 a, b, c 各为一个数字，分别表示 User， Group 及 Other 的权限。因为： 读取 写入 执行r = 4, w = 2, x = 1 故而： rwx : 4 + 2 + 1 =&gt; 7 rw : 4 + 2 =&gt; 6 我们这边仅弄 User 权限，因此略。 参考ubuntu 权限配置仓库权限%h meanhooks 配置","categories":[{"name":"Git","slug":"Git","permalink":"https://monocy.site/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://monocy.site/tags/Git/"}]},{"title":"记 JS 的类型转换","slug":"记-JS-的类型转换","date":"2019-07-16T02:50:54.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/07/16/记-JS-的类型转换/","link":"","permalink":"https://monocy.site/2019/07/16/记-JS-的类型转换/","excerpt":"前言JS 内最为诟病的便是其隐式类型转换问题，对于初学者来说，其复杂的规则以及诡异的结果很容易一头雾水。这难道表明 JS 不是很好吗？其实不然，隐式的转换带给我们的是代码的简介度，在合适的时机使用，同样会带来优质的 coding 体验。本文就来梳理一下 JS 类型转化规则，方便大家理解。 本篇参考文章 《你所不知道的 JavaScript 中篇》 第四章","text":"前言JS 内最为诟病的便是其隐式类型转换问题，对于初学者来说，其复杂的规则以及诡异的结果很容易一头雾水。这难道表明 JS 不是很好吗？其实不然，隐式的转换带给我们的是代码的简介度，在合适的时机使用，同样会带来优质的 coding 体验。本文就来梳理一下 JS 类型转化规则，方便大家理解。 本篇参考文章 《你所不知道的 JavaScript 中篇》 第四章 总体转换规则文档内介绍的比较清除，此处为了更好的展示效果，仅引用一下截取自 Alex Dorey 的 GithubIO 的一张图： 仔细理解一下，对于 JS 中很多相等比较的奇妙结果便都能解释了。比如： 1\"0\" == false; // true 当 string 与 boolean 类型比较时，会优先将 boolean 转化为 number，因此我们得到中间步骤为： 12// Step 1\"0\" == 0 然后 string 比较 number 时，此时会优先将 string 转化为 number，因此我们得到 12// Step 20 == 0 最终的结果显而易见，那就是 true 了。 极端情况当然我们不排除有些难以理解的极端情况，以下列举一个 Case： 1[] == ![] // true 分析一下，由于 ! 的存在，我们优先进行显示转换，于是有： 123456// Step 1[] == !Boolean([])// Step 2[] == !true// Step 3[] == false 然后对象与 boolean 类型比较时，我们需要调用对象的 [[DefaultValue]] 方法（toString/valueOf），因此我们得到 1234// Step 4[].toString() == false// Step 5&apos;&apos; == false 这一步又回到了 string 与 boolean 的比较了，很明显最终的结果为 true。 此外，还有部分比较难以理解的，这里就稍微列举一下： 1234// 数组单个值的解析'' == [null]'' == [null].toString()'' == '' // true 1234// 对象的解析0 == &#123;&#125;0 == ToString(&#123;&#125;) // 调用自身 __proto__ 上的 toString 方法0 == '[Object object]' // false 逻辑运算符隐式类型转换相关的还有逻辑运算符，但是 JS 中的逻辑运算符又和其它强类型语言（如 C）的逻辑运算符不同，其返回值并非 boolean 类型。我们看个例子： 123456789const a = 4;const b = \"a\";const c = null;a || b // 4a &amp;&amp; b // \"a\"c || b // \"a\"c &amp;&amp; b // null 可见，|| 和 &amp;&amp; 首先会对第一个操作数（a 和 c）执行条件判断，如果其不是布尔值就进行 toBoolean 强制类型转换，然后再执行条件判断。 其规律为： 对于 || 来说，如果条件判断的结果为 true 就返回第一个操作数（a 和 c）的值，否则返回第二个操作数（b）的值。 对于 &amp;&amp; 来说，如果条件判断的结果为 true 就返回第二个操作数（b）的值，否则返回第一个操作数（a 和 c）的值。 换个角度来看，它们很像三元运算符，但是它不会有副作用即：其不会执行两次。如 a ? a : c，如果 a 为比较复杂的运算，那么 a 会执行两次，但是 a || c，其 a 只会执行一次。 此“逻辑运算符”在 JavaScript 中可能更为贴切的叫法为“操作数选择器”吧，在大多数的代码压缩后的内容中我们常常能见到其影子，工作中不妨也可以一试 ☆*:.｡. o(≧▽≦)o .｡.:*☆ &amp;&amp; 和 || 运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。 —— ES5 规范 11.11 节 代码块我们知道，在 JS 中 { / … / } 表明这是一个对象，但是我们常常忘了它还能表示为代码块，比如 while / if 后面的大括号。然而这和 JS 类型转换有什么关系呢，我们看看下例： 12[] + &#123;&#125; // [object Object]&#123;&#125; + [] // 0 那么问题来了，仅仅调换了一个位置，为什么结果会相差这么多？ 分析一下，在第一个例子中，{} 是在 + 运算符表达式中，词法分析将 {} 解析为第二个参数，因此经过隐式转换，{} 会被转换成 ‘[object Object]’，空数组就不用多解释了，所对应的结果也就如上了。 然而第二个却有些不同。我们知道 {} 作为空代码块是不执行任何操作的，且不用带 ; 结尾，所以在此处是不存在语法问题的。因此自左向右来看，词法分析将此分解为 {} 与 +[] 两部分，前者作为空代码块执行，无任何副作用，后者强制转换结果就是 0 了。 参考文章 比较操作符 The Abstract Equality Comparison Algorithm JavaScript 中的相等比较 ES5 规范中文文档","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"项目 ts 迁移的踩坑记录","slug":"项目-ts-迁移的踩坑记录","date":"2019-07-14T05:43:13.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/07/14/项目-ts-迁移的踩坑记录/","link":"","permalink":"https://monocy.site/2019/07/14/项目-ts-迁移的踩坑记录/","excerpt":"前言先前发过一篇对于 shimes-vue-ts 文件的思考，其中有一节写到项目 ts 迁移所遇到的问题和解决方法。因为项目才刚迁移完一部分 ts（用得到的部分），踩坑的过程还在进行中，为了更好的记录 ts 迁移过程中所遇到的问题，还是单独写一篇来做记录吧。此篇便是改进后的问题记录，以及相对详细的解决方法。该篇会持续跟新哦~","text":"前言先前发过一篇对于 shimes-vue-ts 文件的思考，其中有一节写到项目 ts 迁移所遇到的问题和解决方法。因为项目才刚迁移完一部分 ts（用得到的部分），踩坑的过程还在进行中，为了更好的记录 ts 迁移过程中所遇到的问题，还是单独写一篇来做记录吧。此篇便是改进后的问题记录，以及相对详细的解决方法。该篇会持续跟新哦~ 问题集锦动态引入无 ts 声明的文件项目内有动态设置 cookie 的文件，因为不同测试环境需要配置不同的 cookie，每天都需要从服务器拿取一次 cookie，目前的做法为： 1234// cookie-set 文件夹已经移除 git 缓存跟踪if (process.env.NODE_ENV === 'development') &#123; import('@/cookie-set');&#125; 由于需要迁移 ts，对于原有的 cookie-set.js 需要进行类型声明（或者都改成 cookie-set.ts），为了兼容两种情况，这里还是做了对应类型声明，如： 12// 在 declarations.d.ts 文件内添加declare module '@/cookie-set'; 参考文章： 模块】、typescript-declare-third-party-modules 引入无 typings 的 npm 包比较全的 npm 包会包含对应的 typings 文件来支持 ts 项目，但是对于没有 typings 文件的包来说，我们需要对齐进行外部文件声明。那么为了支持 vue.use 方法，我们可以这么写对应的声明： 针对默认导出的声明写法： 123456// 此适用于 import vueClipboard from 'vue-clipboard2';declare module 'vue-clipboard2' &#123; import &#123; PluginFunction &#125; from 'vue'; const clipboard: PluginFunction&lt;any&gt;; export default clipboard;&#125; 针对解构的写法： 12345// 此适用于 import &#123; monitorVue &#125; from 'fe-monitor-sdk';declare module 'fe-monitor-sdk' &#123; import &#123; PluginObject &#125; from 'vue'; export const monitorVue: PluginObject&lt;any&gt;;&#125; export 和 export default 可参考模块部分内容 参考文章： 模块、TypeScript 支持 vue-router 的组建引用报错虽然在 webpack 内我们配置了 alias，但那仅仅只是 webpack 打包时用的，ts 并不认账，它有自己的配置文件。因此，在升级至 ts 项目时，我们还得为 ts 配置一份模块路径，如： 1234567// tsconfig.jsonpath: [ \"@/*\": [ \"src/*\" ], // ...] 此外，因为编辑器的原因使得无法识别 .vue 后缀，所以对于 vue 文件的引用必须添加 .vue 后缀，如： 1import myComponent from './my-component.vue'; 参考文章： Typescript: IDE reports TS2307、模块解析 vue 的 data 部分爆红这个问题比较隐蔽，折腾了很久才发现因为 data 为函数(主要是写惯了才难以察觉，官网文档因为类型推断所以没有写)，其内的对象为返回值，因此此部分的声明可以写（个人推荐不要用断言）： 123456789// 返回值声明写法data(): Your Interface here &#123; return &#123;&#125;;&#125;// 断言写法data() &#123; return &lt;Your assertions here&gt; &#123;&#125;;&#125; 注: 主要是为 data 内的数组、对象声明对应类型，都为基础类型时不写后面使用也不会报错。 vue 的 mixins 文件写法Vue 的 mixins 写法有两种，一种为普通的 ts 写法，另一种为装饰器的写法 123456789101112// 原来的写法export default &#123;/**/&#125;// 普通 ts 写法import Vue form 'vue';export default Vue.extend(&#123;/**/&#125;)// 装饰器写法import &#123; Vue, Component, Prop &#125; from \"vue-property-decorator\";@Componentexport default class ComponentName extends Vue &#123; &#125; 注: 普通 ts 写法的 computed 部分需要添加范围值，可参考 vue 文档 TypeScript 支持部分。 参考文章： TypeScript-Vue-Starter、TypeScript 支持 VS Code experimentalDecorators 问题因为 vue 装饰器写法为实验性特性，可能在未来的发行版中发生变化，因此需要配置此参数来删除警告。直接根据警告来做相应配置，即在 tsconfig.json 内添加属性： 1\"experimentalDecorators\": true 类的静态方法关于类一般会采用 abstruct 抽象类来规范方法和属性等类的细节，但是对于“类”中 static 部分无法进行抽象规范，需要在对应静态方法部分进行单独处理，对于此部分是否有更好的处理方法存在疑问🤔（如：提取一个 interface 之类的声明）。目前想到的比较靠谱的写法有两个： namespace 写法官方文档中也有说过，对于业务内的模块来说，推荐使用 namespace 来做全局命名，因此对于业务内比较通用的公共方法来说，可以使用 namespace 来处理。 对于多层命名空间的写法，可用别名写法 import NS = FirstNameSpace.SecondNameSpace，然后直接通过 NS.xxx 来直接取对应属性即可。同时区别加载模块时使用的 import someModule = require(&#39;moduleName&#39;)，此处的别名仅仅只是创建一个别名而已，简化代码量。 module 文件另一种可用 ES6 的思想，import + export ，因为类中只有 static 方法，因此可以认为该类为一个模块，而一个模块对应一个文件，因此作为一个 ts 文件来存储对应方法，需要时在 import 引入即可。 eslint 迁移至 tslint 时部分校验修复失效问题semi 无自动补全将原来配置的 eslint 的 semi 校验替换： 123456// 原来的配置semi: [&apos;error&apos;, &apos;always&apos;]// 现在的配置&quot;semi&quot;: &quot;off&quot;,&quot;@typescript-eslint/semi&quot;: [&quot;error&quot;], import 引入没有使用的内容不报错因为 @vue/eslint-config-typescript 的文件内将 @typescript-eslint/no-unused-vars 给注释掉了，同时 no-unused-vars 设置为 ‘off’，使得对没有使用的变量都不校验。其对应设置的解释为：传送门 解决方法（跟项目 eslint 和 typescript 版本不同而不同）： 12345678'@typescript-eslint/no-unused-vars': [ 'error', &#123; vars: 'local', args: 'none', ignoreRestSiblings: true &#125;] 参考文档：@typescript-eslint/eslint-plugin、TypeScript 支持、typescript/no-unused-vars $refs 引用报错问题由于 Vue 对 refs 的声明为 type Vue | Element | Vue[] | Element[]，在通过 $refs 调用对应组件方法时，因为 Vue 和 Element 上没有对应方法声明，因此我么需要对其进行断言处理，如： 1234567891011121314interface MyComponent extends Vue &#123; someMethod(): void&#125;// 普通 ts 写法(this.$refs.myComp as MyComponent).someMethod()// 装饰器写法@Componentexport default class A extends Vue &#123; $refs: &#123; myComp: MyComponent &#125; this.$refs.myComp.someMethod()&#125; @Prop 的类型问题官方对于 @Prop 装饰器的写法提供了两种思路，分别为： 1234// 不带 type@Prop(&#123; default: '' &#125;) readonly propB!: string// 带 type@Prop(&#123; type: String, default: '' &#125;) readonly propB!: string 带 type 的和原来的写法可以说没什么区别，但是不带 type 的会出现两种问题： 问题一当为 Boolean 类型时，会使得属性官方 boolean 的简写方式无法生效，如： 12&lt;!-- 不写 type 时此不生效，只能显示绑定 true 值 --&gt;&lt;blog-post is-published&gt;&lt;/blog-post&gt; 官方例子 问题二此不会触发部分的相应的 ts 类型校验，例如： 123&lt;!-- 假如对应 props 为： @Prop() likes!: number; --&gt;&lt;!-- 此时 likes 传入类型为 string，但是不报错 --&gt;&lt;blog-post likes=\"42\"&gt;&lt;/blog-post&gt; 个人建议： 除非非常确定传入的 Prop 的类型，否则尽量都加上对应的 type 声明 exceljs 引入报错问题引入 exceljs 后，ts 一直报错 import(&quot;stream&quot;) 行因为没有找到 stream 包，因此报错。 问题定位了很久，才发现 stream 是 Node 自带的包，而我们的 tsconfig.json 内却并没有将对应的 node 类型引入，因此会报错，解决方法： 123456789&#123; \"compilerOptions\": &#123; // ... \"types\": [ \"webpack-env\", \"node\" // 将 node 类型加入即可 ] &#125;&#125; 注意，引入 node 后，可能会引发新的 ts 问题，比如自定义的 process.env.XXX 可能为 undefined，这个需要自己做兼容了。 参考 issue 拓展内容namespaceTS 里的 namespace 主要是解决命名冲突的问题，会在全局生成一个对象，定义在 namespace 内部的类都要通过这个对象的属性访问。对于内部模块来说，尽量使用 namespace 替代 module，可参考 namespace 一节。例如： 123456789101112namespace Test &#123; export const USER_NAME = 'test name'; export namespace Polygons &#123; export class Triangle &#123; &#125; export class Square &#123; &#125; &#125;&#125;// 取别名import polygons = Test.Polygons;const username = Test.username 注：import xx = require(‘xx’) 为加载模块的写法，不要与取别名的写法混淆。默认全局环境的 namespace 为 global 参考文档：namespace module模块可理解成 Vue 中的单个 vue 文件，它是以功能为单位进行划分的，一个模块负责一个功能。其与 namespace 的最大区别在于：namespace 是跨文件的，module 是以文件为单位的，一个文件对应一个 module。类比 Java，namespace 就好比 Java 中的包，而 module 则相当于文件。 如果你的模块需要将新的名称引入全局命名空间，那么就应该使用全局声明。如果你的模块无需将新的名称引入全局命名空间，那么就应该使用模块导出声明。 FromDefinitelyTyped","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"使用 vue-cli 发布一个完善的包","slug":"使用-vue-cli-发布一个完善的包","date":"2019-07-11T03:41:56.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/07/11/使用-vue-cli-发布一个完善的包/","link":"","permalink":"https://monocy.site/2019/07/11/使用-vue-cli-发布一个完善的包/","excerpt":"前言其实先前有写过一篇《发布一个 vue 包》，不过对于“极简主义者”来说，该文章还是显得有些复杂，毕竟需要配置“复杂”的 webpack。那么有没有一种简单上手、开箱即用的方法呢？答案是有的，vue-cli 已经完美的考虑到了这些问题，此处就介绍如何使用 vue-cli 来搭建一个完整的发包环境。 注：此处的 vue-cli 指的是 @vue/cli ，为 3.x 版本。","text":"前言其实先前有写过一篇《发布一个 vue 包》，不过对于“极简主义者”来说，该文章还是显得有些复杂，毕竟需要配置“复杂”的 webpack。那么有没有一种简单上手、开箱即用的方法呢？答案是有的，vue-cli 已经完美的考虑到了这些问题，此处就介绍如何使用 vue-cli 来搭建一个完整的发包环境。 注：此处的 vue-cli 指的是 @vue/cli ，为 3.x 版本。 目标我们的最终目标是发布的包、测试环境和包的使用文档，此可概括为：项目构建环境和项目使用文档。由于 vue-cli 可以手动配置项目需要的环境，因此在项目构建环境部分此处仅记录 vue-cli 的部分配置选项和相关解释，整体的项目结构和先前的基本一致。 然而文档方面因为 vue-cli 没有做相应的支持，因此我们需要找一个能识别 vue 组件的文档库，个人建议首选 vuepress，其次可以尝试 docsify 或者其余能够支持 vue 的文档网站生成工具（当然自己造对应轮子也是可以的）。 项目环境构建使用 vue-cli 创建一个项目，此处就以 vue-cli-plugin-demo 做为例子。直接使用 vue create 创建项目，然后选择 Manully select features，之后选择的内容如下图： 这里解释一下其中部分选项的选择的原因： TS 的 Class 风格支持因为 vue3 相对于 vue2 版本有比较大的变动，至于 vue2 所支持的 class 风格的 TS 写法在 vue3 中可能不怎么支持，因此现有项目是否使用 Class 风格可能会有些争议（主要是担心写习惯后到时候不太好切换写法）。 个人建议使用，毕竟单纯的 TS 写法在 vue2 中的会稍显难受，装饰器的写法要稍微舒服一些。此外，多学习一些新知识总归是对自己有好处。 TS 使用 eslint-standard有人会问为什么创建项目时不直接选 TSlint 作为校验规则呢？这其实也是有原因的。可以上网对比一下 ESlint 和 TSlint ，你会发现 ESlint 的校验规则相对来说更细致，且更完全。此外，TypeScript 官方都决定迁移 TSlint 至 typescript-eslint，那我们还有什么理由坚持 TSlint 了呢？嘿嘿～ The TypeScript Team themselves also announced their plans to move the TypeScript codebase from TSLint to typescript-eslint, and they have been big supporters of this project. More details at https://github.com/microsoft/TypeScript/issues/30553 其余部分单元测试部分因为我仅仅了解 Mocha 的部分内容，因此选择的是 Mocha，熟悉 Jest 的可以选 Jest；至于勾选 vue-router 和 vuex，这个是对于运行 devServer 做的一些配置；然后是 vue-router 不选择 history 模式，这个仁者见仁，智者见智吧，毕竟 lib 发包不走这个。 项目配置结构配置过滤掉默认生成的并且不做修改的部分，最终项目的结构大致为 1234567891011121314151617181920vue-cli-plugin-demo├── components.json├── docs├── packages├── src| ├── App.vue| ├── components| ├── entry.js| ├── main.js| ├── mixins| ├── router.js| ├── store.js| ├── views| └── types├── types| └── index.d.ts├── vue.config.js├── tsconfig.json├── webpack.component.js└── yarn.lock 其中 docs 为文档的文件夹，然后 components.json 、webpack.component.js 和 src/entry.js 主要为了按需引入而做的单独打包处理，其次在根目录和 src 文件夹内都添加了一个 types 文件，最后在根目录下建立了一个 packages 文件夹作为发包组件的结构。接下来我们一步步来搭建我们自己的 vue 包。 整体结构参考 element-ui 的项目结构 配置 tsconfig.json 和 vue.config.jstsconfig.json 内的配置内容不是很多，仅配置以下信息： 1234567891011121314\"jsxFactory\": \"h\", // 简写 jsx 的 render 函数\"paths\": [ // 配置 import 引入的路径索引，视情况扩展 // ..., \"@views/*\": [ \"src/views/*\" ]],\"pretty\": true, // 为错误消息设置样式\"includes\": [ // 添加需要 ts 校验的文件 // ... \"packages/**/*.ts\", \"packages/**/*.tsx\", \"packages/**/*.vue\"] vue.config.js 内的配置如下： 12345678910111213141516171819202122const path = require('path')// 配置公共请求路径function resolve (dir) &#123; return path.join(__dirname, dir)&#125;module.exports = &#123; lintOnSave: true, productionSourceMap: false, chainWebpack: config =&gt; &#123; // 设置 output 的默认 export 值 config.output.libraryExport('default') // 新增部分别名，视情况扩展 config.resolve.alias .set('@', resolve('src')) .set('@views', resolve('src/views')) // ... // 新增 js 的 exclude 内容 config.module.rule('js').exclude.add([resolve('lib'), resolve('dist')]) &#125;&#125; 注： 两文件内的别名扩展需要保持一致。除了配置别名外，另一个需要关注的部分是修改 rule(‘js’) 部分的配置，否则后面测试自己打包好的 lib 文件会报错。 packages 包写法packages 包用于存放我们编写的包组件，我们统一其每一项的结构为： 12345/*...*/vue-cli-project-demo/packages└── button ├── index.ts └── src └── main.vue 这么写的原因在于方便按需打包，使用统一的格式利于我们抽象对应的函数方法，同时也利于项目的维护。其中 index.ts 用于暴露 src 中的 vue 文件和其对应的 install 扩展方法。 index.ts 内没有必要对单文件进行 install 扩展，除非需要规范化对应 component 的标签值，比如：element-ui 单文件引入的是 Button，没有 el 前缀，用 Vue.use 就是为了补充上前缀，内部走 Vue.component 方法。 个人建议：保证导出的组件的 name 值符合总体规范即可，并不需要一定走此配置的格式。 打包配置这里使用的是 vue-cli 提供的 lib 打包方式，基本不用额外的 webpack 配置，命令为： 1vue-cli-service build --target lib --name myLib [entry] 因此我们可以改造 package.json 如下： 12345678\"scripts\": &#123; \"dev\": \"vue-cli-service serve --open\", \"build\": \"vue-cli-service build --target lib --dest lib ./src/entry.ts &amp;&amp; yarn removeHtml\", \"removeHtml\": \"rm ./lib/*.html\", \"lint:js\": \"vue-cli-service lint\", \"lint:css\": \"npx stylelint src packages --fix\", \"test:unit\": \"vue-cli-service test:unit\"&#125; 因为构建 lib 包会默认生成一个 html 文件，在此我做了删除。此外添加了 stylelint 的一些配置。demo 内还规范了发包上传的内容以及 commit 时的校验配置，可视情况添加。 此外如果更规范一点，我们可以写上作者，写作者等配置（可参考 demo）。 dev 环境配置开发环境需要配置的东西基本没有，这里仅仅介绍一下如何引用打包文件。此处有两种情况： 在开发包的阶段，我们直接引用 entry.ts 文件即可，当测试生成的包时，我们引用 lib 内的生成的文件。如： 1234// 开发时测试用import MyComponents from './entry';// 构建完测试用import MyComponents from '@lib/vue-cli-project-demo.umd'; 此时我们需要配置对应 js 文件的 module 扩展，如 demo 内的 global.d.ts 的声明： 12345declare module \"@lib/*\" &#123; import Vue, &#123; PluginFunction &#125; from 'vue'; const _default: PluginFunction&lt;Vue&gt;; export default _default;&#125; 项目开发相关的 ts 问题可查阅先前的一篇 ts 问题总结篇，配置开发包的 ts 问题看本文的问题汇总。 Test 测试配置demo 内使用的是 Mocha + chai，同时对 slot 部分做了一下测试，这个对着文档就能做出一些测试函数，其余的配置 vue-cli 都封装好了。测试的语法并非本文的重点，有机会可以补上一篇。 单文件打包配置要实现按需引入的话，我们还需配置多入口打包。先前规范的 package 文件夹的结构刚好就支持我们遍历需要打包的文件。 由于想稍微偷点懒，这里我就直接用 json 记录各需要的入口文件，同时配置 webpack.components.js 仅用于单独打包。webpack 的详细配置其实可以参考 vue-cli 的内部配置（vue inspect），在此我就不一一列举了，其它需要注意的部分就是如果 package 包内的组件如果用 TS 写的，那么尽量不要压缩代码，可能会出现 name 被压缩的问题了。 文档配置对于整个项目来说，文档的配置可以算是一个点缀项，能让整体更加完善。vuepress 文档已经十分详细了，这里仅仅记录一些比较困难的配置点。docs 文件的结构大致为： 123456789101112131415vue-cli-project-demo/docs├── .vuepress| ├── config.js| ├── enhanceApp.js| ├── public| | ├── favicon.ico| | └── logo.jpg| ├── router-config.js| ├── static-theme-config.js| └── utils| └── index.js├── components| ├── button.md| └── index.md└── index.md 注： docs 才是文档页面的根路径。 图片配置Vuepress 内分为文档图片资源和静态图片资源。公共图片资源就不用介绍了，一般相对路径的 markdown 写法能完全满足要求。但是对于页面的 favicon 和首页模板部分的 logo ，这个需要在 .vuepress 下的 public 文件内做存储。 项目包引入对于我们生成的 lib 包的引入，此需要在 .vuepress 文件夹下创建一个 enhanceApp.js 文件，在该文件内做额外包的引入。写法为： 1234567891011// 安装发布的包import MyComponents from '../../lib/vue-cli-project-demo.umd';export default (&#123; Vue, // VuePress 正在使用的 Vue 构造函数 options, // 附加到根实例的一些选项 router, // 当前应用的路由实例 siteData // 站点元数据&#125;) =&gt; &#123; Vue.use(MyComponents)&#125; 整体页面配置与 .vuepress 同级别的其余文件/文件夹为对应的页面模板，例如：默认进入显示的首页为 index.md 文件，对于各文件的路径配置需要在 .vuepress/config.js 文件内对应编写。 这里可能会遇到的问题是，将 config.js 文件拆分成多个文件时，页面会无法监听到其余 js 配置文件的修改。我们此时需要配置 extraWatchFiles 字段来额外监听需要监听的文件。 另外需要注意的是 base 属性，如果部署在服务器上的路径非根路径，那么此还需要对应设置一下。剩余的配置都为比较基础的配置了，demo 内都有较为详细的说明，在此就不一一列举了。 部署因为我的 github.io 上已经有我的博客了，此部分具体有什么坑我也没有踩过，仅能给大家抛个链接了。 Demo 地址传送门 问题汇总引入打包的 lib 文件报错在测试生成的包时，通过 import 引入报错，其原因是 webpack 对于 import 的文件会进行此处的 js 解析，然而对于已经打包好的文件我们预想的是直接引入就行了，因此需要将其从规则中去除掉，否则通过规则去解析就会报错。 两个 types 文件的目的项目内的 types 文件其实可以合并成一个，但是个人倾向分成两部分。与 src 同层的 types 文件仅用来声明 lib 默认导出的文件，而 src/types 文件则是项目开发时需要的文件声明。如果最终发布至 npm 上的包仅包含 lib 文件，那么建议使用 demo 的这种写法，层次会更清楚一点。 使用 lib 中的 umd.min.js 文件报错由于 lib 打包生成的 min 文件将组件的 Class 名压缩了，因此对应的 name 值就不是我们设置的值，即使将 name 显示至于 Component 内也不行，对此我发了一条 issue 补充： 最终的解决方案有两个，这里列举一下解决思路： 方法 1: 12345678// 对应包组件@Component(&#123; name: 'MyButton'&#125;)export default class MyButton extends Vue &#123;&#125;;// install 方法内的 component 注册部分Vue.component(MyButton.options.name, MyButton); 方法 2: 配置 terser 的代码压缩部分，令其不压缩 className，该部分在 vue.config.js 内配置如下内容。 12345configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; config.optimization.minimizer[0].options.terserOptions.keep_fnames = true &#125;&#125; 注意： vue-cli 使用的是 terser 而不是 uglify，此外虽然 vue 内有对应 terser 的命名，但是没法获取得到，使用 config.optimization.minimizer(‘terser’) 函数会使得 minimizer 部分的内容丢失，暂未找到比较好的解决方法。个人还是希望官方补充一下解决该问题的思路。 12345678910// 源码中的 production 环境的部分配置if (process.env.VUE_CLI_TEST) &#123; webpackConfig.optimization.minimize(false)&#125; else &#123; const TerserPlugin = require('terser-webpack-plugin') const terserOptions = require('./terserOptions') webpackConfig.optimization .minimizer('terser') .use(TerserPlugin, [terserOptions(options)])&#125; 源码请见 prod.js官方 terserOptions 配置 install 方法报错在对应包的 index.ts 内为导出的包设置 install 方法时报错，install 方法在 Vue 中是作为 Plugins 的一个内置函数而设置的，而我们导出的实例类型为 VueConstructor ，在 VueConstructor 上并没有 install 函数，因此按照 plugins 那种写法扩展声明一个即可。 引入包的项目构建页面不呈现使用 Components 语法编写的组件库可能会遇到这么一个问题，项目将组件通过 Vue.use 方法全量注册到项目中了，开发环节并没有遇到任何问题，可随处使用，但是一旦 build 构建后，页面却无法呈现出组件。 原因： Class 语法编写的组件编译时会经有 vue-cli 的 webpack 处理，默认的 terser 压缩配置中同样会将 ClassName 给压缩掉，这就导致引入的组件在生产环境找不到了。 解决方法：参考 使用 lib 中的 umd.min.js 文件报错 的 方法 2 参考文档 发布一个 vue 包 项目 ts 迁移的踩坑记录 typescript-eslint/typescript-eslint vue-cli 文档 vuepress 文档 TS 编译选项查询表 Chai.js 文档 Element/Component name with vue-class-component","categories":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/tags/Vue/"}]},{"title":"由 shims-vue.d.ts 引发的思考","slug":"由-shims-vue-d-ts-引发的思考","date":"2019-07-07T04:02:59.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/07/07/由-shims-vue-d-ts-引发的思考/","link":"","permalink":"https://monocy.site/2019/07/07/由-shims-vue-d-ts-引发的思考/","excerpt":"前言由于项目近期进行 ts 迁移，作为第一个吃螃蟹的人，踩过了不少坑。迁移过程中遇到的大大小小的问题基本上都解决了，但是对于 shims-vue.d.ts 文件的命名以及其内的模块声明始终找不到比较贴切的解释。沉下心来读了些外网资料，总算是有点“豁开云雾见青天”的感觉了。此处就记录我对于 ts 全局模块声明的一些思考以及一些 ts 项目迁移遇到的坑。","text":"前言由于项目近期进行 ts 迁移，作为第一个吃螃蟹的人，踩过了不少坑。迁移过程中遇到的大大小小的问题基本上都解决了，但是对于 shims-vue.d.ts 文件的命名以及其内的模块声明始终找不到比较贴切的解释。沉下心来读了些外网资料，总算是有点“豁开云雾见青天”的感觉了。此处就记录我对于 ts 全局模块声明的一些思考以及一些 ts 项目迁移遇到的坑。 Vue ts 声明文件在安装 @vue/typescript 之后，项目会生成两个新文件，分别是 shims-vue.d.ts 和 shims-jsx.d.ts，其内容分别是： 123456// shims-vue.d.tsdeclare module '*.vue' &#123; import Vue from 'vue'; export default Vue;&#125; 和 12345678910111213import Vue, &#123; VNode &#125; from 'vue';declare global &#123; namespace JSX &#123; // tslint:disable no-empty-interface interface Element extends VNode &#123; &#125; // tslint:disable no-empty-interface interface ElementClass extends Vue &#123; &#125; interface IntrinsicElements &#123; [elem: string]: any &#125; &#125;&#125; 那么这两个文档有什么作用呢？ shims-vue.d.ts前者为 Ambient Declarations(通称：外部模块定义) ,主要为项目内所有的 vue 文件做模块声明，毕竟 ts 默认只识别 .d.ts、.ts、.tsx 后缀的文件；（即使补充了 Vue 得模块声明，IDE 还是没法识别 .vue 结尾的文件，这就是为什么引入 vue 文件时必须添加后缀的原因，不添加编译也不会报错） shims-jsx.d.ts后者为 JSX 语法的全局命名空间，这是因为基于值的元素会简单的在它所在的作用域里按标识符查找（此处使用的是无状态函数组件 (SFC)的方法来定义），当在 tsconfig 内开启了 jsx 语法支持后，其会自动识别对应的 .tsx 结尾的文件，可参考官网 jsx。 产生的问题首先，官方文档的上并没有将 shims-xxx.d.ts 做为通用的模板，其仅仅给我们列举了以下模板样例： global-modifying-module.d.ts global-plugin.d.ts global.d.ts module-class.d.ts module-function.d.ts module-plugin.d.ts module.d.ts 那么该如何理解这两个文件？ 是否能够更改在统一规范的文件内？ 全局接口、命名空间、模块等声明又有那些写法来定义？该如何写？ … 对于产生的这么些问题，下面依次分析。 解惑理解并改造 shims-xxx.d.ts我们知道，xxx.d.ts 的文件表明，其内部的一些声明都为全局的声明，能够在项目各组件内都能获取到。因此 Vue 生成的两个 shims-xxx.d.ts 其实是为了表明，该两文件为 Vue 相关的全局声明文件。 但是从项目管理来说，随着引入的 npm 模块增多（比如公司内部 npm 源上的不带 types 的包），那么模仿 Vue 的声明文件写法，外部声明的文件也会越来越多，文件夹看起来就不是很舒服了。因此有没有一种比较好的方法来解决文件过多的问题呢？ 对于我来说，我更偏向将这些简单的声明维护在一个 .d.ts 文件内，正好官网也推荐维护在一个大的 module 内，因此我们可以维护一个 module.d.ts 来总体声明所有的外部模块。基于官方的例子，我做了两个文件来管理外部模块的声明，分别是 module.d.ts 和 declarations.d.ts。前者主要维护需要写的比较详细的外部模块，后者主要维护简写模式的模块（包括内部需要声明的 .js 文件，兼容历史遗留问题）。例如： 改造后的 module/index.d.ts 12345678910111213141516171819202122// This `declare module` is called ambient module, which is used to describe modules written in JavaScript.// 添加 vue-clipboard2 的 Vue 插件声明declare module 'vue-clipboard2' &#123; import &#123; PluginFunction &#125; from 'vue'; const clipboard: PluginFunction&lt;any&gt;; // 定义默认导出的类型 export default clipboard;&#125;// 添加 fe-monitor-sdk 的 Vue 插件声明declare module 'fe-monitor-sdk' &#123; import &#123; PluginObject &#125; from 'vue'; // 定义解构的变量类型 export const monitorVue: PluginObject&lt;any&gt;;&#125;// 添加所有 .vue 文件的声明declare module '*.vue' &#123; import Vue from 'vue'; export default Vue;&#125; 改造后的 module/declarations.d.ts 123// Shorthand ambient modules, All imports from this shorthand module will have the any type.declare module '@/cookie-set'; 附加：对于 global 声明可视情况分类，比如通用的放在 global.d.ts，其余可视情况（如果该类型比较多的话）按照对应类型分类，比如 table 的可全部放在 global-table.d.ts。 全局声明的写法另一个一直比较疑惑的问题是全局声明的写法，比如模块的“单文件单模块声明”的写法“单文件多模块合并声明”的写法不太一样，“无导入的全局声明文件”和“带导入声明的全局声明文件”的写法又有些不同，这里我一一列出其可行的写法以及其不同的原因。 注：这里的一些定义都是个人总结的便于记忆的说法，为非标准定义。 单文件单模块声明该文件支持两种写法，分别如下： 123456789101112// 写法一declare module '*.vue' &#123; import Vue from 'vue'; export default Vue;&#125;// 写法二import Vue from 'vue';declare module '*.vue' &#123; export default Vue;&#125; 注： 前者（写法一）主要为无 ts 声明的模块添加声明，后者（写法二）主要为已有 types 声明的模块进行声明扩展（可以参考 vue-router 源码部分） 单文件多模块合并声明仅有一种写法（需要关闭对应的多次引入重复模块的 lint 规则或者忽略此 types 文件夹内的所有内容） 1234declare module '*.vue' &#123; import Vue from 'vue'; export default Vue;&#125; 无导入的全局声明文件无导入即没有 import 声明，直接定义全局接口、函数等 12345interface TableRenderParam extends BasicObject &#123; row: BasicObject, key: string, index?: number,&#125; 带导入声明的全局声明文件带有 import 导入插件声明的必须显示定义 global，例如： 1234567891011import &#123; CreateElement &#125; from 'vue';// function 部分declare global &#123; interface TableRenderFunc &#123; (h: CreateElement, &#123; row, key, index &#125;: TableRenderParam): JSX.Element, &#125;&#125;// namespace 部分declare global &#123;&#125; 不同的原因如果在“单文件多模块合并声明”将 import 提出至最顶层时，会发现 ts 报错，说模块无法进一步扩大，为什么将 import 提出后会报错提示模块无法扩大？ 个人研究得出的结论是，当将 import 提出至模块外时，就已经表明该文件内的其它 declare 的模块已经是存在 ts 声明的模块，此时再对其进行 declare 声明即对其原本的声明上进行扩展（可参考 vue-router 对于 vue 的扩展），但是对于没有 ts 声明的模块，我们拿不到它的 ts 声明，因此也就没发进行模块扩展，所以就会报错。 而将 import 放至模块内时，因为 module 本来就表明自己为一个模块，其就可以作为模块的声明，为没有对应声明的模块添加声明了。 此外，对于多个 declare global 的写法，此是采用了声明合并)的方式，使得所有的模块声明都合并至同一个 global 全局声明中，因此，在对于将 import 提至外层的“带导入声明的全局声明文件”来说，分文件全局维护或者单文件声明合并式维护都是可行的。 TypeScript与ECMAScript 2015一样，任何包含顶级import或者export的文件都被当成一个模块。相反地，如果一个文件不带有顶级的import或者export声明，那么它的内容被视为全局可见的（因此对模块也是可见的）。 ts 踩坑记录已经维护至博文项目 ts 迁移的踩坑记录中了 参考文档 命名空间和模块 Clarify what “ambient” means Ambient Declarations TypeScript 入门教程 Typescript: IDE reports TS2307 typescript declare third party modules TypeScript 的两种声明文件写法的区别和根本意义 区分 TS 中的 namespace 和 module","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"关于 JS 中“继承”的写法","slug":"关于-JS-中“继承”的写法","date":"2019-06-28T05:01:15.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/06/28/关于-JS-中“继承”的写法/","link":"","permalink":"https://monocy.site/2019/06/28/关于-JS-中“继承”的写法/","excerpt":"前言在巩固继承这部分知识时，突然想到早期分享时同事提出的一些疑问，即实现 JS 继承具体有那些方法。在经过一番调研后，此篇便是我所总结出的比较全面的方法。当然，文中记录的仅是一些基础的继承方法以及它们之间的的区别，以供参考。","text":"前言在巩固继承这部分知识时，突然想到早期分享时同事提出的一些疑问，即实现 JS 继承具体有那些方法。在经过一番调研后，此篇便是我所总结出的比较全面的方法。当然，文中记录的仅是一些基础的继承方法以及它们之间的的区别，以供参考。 （原型）继承JavaScript 中有许多模拟类行为的方法，其中“继承”（更贴切的说法是委托）便是其中的一项，没有“继承”机制，JavaScript 中的类就是一个空架子。 假如我们以此例作为继承的模板，归结下来总共有 5 种继承的写法。 123456789101112131415161718// 父类function Father(age) &#123; this.age = age;&#125;Father.prototype.getAge = function () &#123; return this.age;&#125;// 子类function Child(age, size) &#123; Father.call(this, age); this.size = size;&#125;/* 继承的实现，看下例 */// 实例const child = new Child(28, 'small') 隐式链接法ES6 之前比较非常规的写法是手动更改 __proto__ 属性来最简化链式继承。 1Child.prototype.__proto__ = Father.prototype 优点：操作很简便直接 缺点：该方法并非标准，并且无法兼容所有浏览器，慎用。 直接引用法直接将子类的 prototype 对象指向父类的 prototype 对象。 1Child.prototype = Father.prototype; 优点：操作简单 缺点： Child 的 prototype 属性修改会直接影响到父类，此写法其实相当于直接在父类进行修改，新创建一个子类有些多此一举。 实例化方法子类的 prototype 属性为父类的实例对象，借由对象的 prototype 链来传递。 12Child.prototype = new Father();// Child.prototype.constructor = Chlid; 优点：能基本满足“继承”的需求 缺点： 需要创建一个新对象，然后将旧对象（原本存在的 prototype 对象，带有 constructor）抛弃掉，不能直接修改默认的 prototype 对象。 会产生副作用，比如：原型（prototype）上会有“脏”属性，本例的 prototype 上会有多余的 age 属性。 必要时还得自己重写一下 Child 的 constructor 指向，如“寄生组合式继承”。 “寄生组合式继承” 在 ES5 中为最佳写法，如果不考虑其稍微的复杂性。 对象构造法通过 Object.create 方法来构造一个合适的关联对象。 12Child.prototype = Object.create(Father.prototype)// Child.prototype.constructor = Chlid; 优点：在 ES6 之前的最佳之选，优于实例化方法。 缺点：与实例化方法基本相同，但没有副作用。此外，其隐式 __proto__ 链比实例化方法要多一层，链式查找方法相对会耗时长一点点，基本可忽略。 设置原型法使用 ES6 的原型设置方法，此法在 ES6 环境为最佳之选，没有之一。 1Object.setPrototypeOf(Child.prototype, Father.prototype) 优点：能覆盖所有需求，清晰易懂，可读性强。 缺点：性能比 Object.create 稍微差点，如果考虑性能的话可优先使用 Object.create 方法 参考文档 MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"层叠上下文","slug":"层叠上下文","date":"2019-06-18T02:43:12.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/06/18/层叠上下文/","link":"","permalink":"https://monocy.site/2019/06/18/层叠上下文/","excerpt":"前言在做项目布局回顾时，思考到了一个当初比较犹豫的问题「flex 布局能否产生层叠/堆叠上下文」。在网上也参考了国内外很多有价值的文章，此处小结一下，算是对层叠上下文这一部分做一次较为全面的总结。","text":"前言在做项目布局回顾时，思考到了一个当初比较犹豫的问题「flex 布局能否产生层叠/堆叠上下文」。在网上也参考了国内外很多有价值的文章，此处小结一下，算是对层叠上下文这一部分做一次较为全面的总结。 核心概念层叠上下文是什么这里先引用 MDN 上的一段对层叠上下文的介绍： 层叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的 z 轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。 简单来说，电脑屏幕给我们展现的是一个平面，此对应直角坐标系的 X、Y 轴，而垂直与电脑屏幕的这个不可见的轴（相当于直角坐标系的 Z 轴），其上面遍布着不同的堆叠层，而此堆叠层的层叠顺序就是我们所谓的层叠上下文了。 如果有设计经验的，那么这个堆叠层可以理解为 PS 中的画布，默认只有最初的一层（页面中的 html 元素） 层叠上下文的堆叠顺序这边借用一张图来描述一下堆叠顺序： 此处对图做简单说明： 层叠上下文部分：相当于该层叠区域的装饰，优先级最低，处于最底层 block 块状水平盒子：层叠区最为基础的布局方式，主要目的是为了控制呈现的样式 float 浮动盒子：float 默认的 display 属性就是 block ，只是脱离了文档流，其也是一种布局方式 inline/inline-block 水平盒子：层叠区默认的内容呈现部分，承载页面大多数内容部分（涉及到页面内容的标签基本上是 inline ，或者是隐式行内盒） z-index + position（和部分 CSS3 属性）：控制元素在其所在的层叠区 Z 轴上的顺序（默认 auto，相当于 0），有正负值 其中比较有趣的一点是，inline/inline-block 的层级顺序要高于 block 元素，具体的体现就在“文字环绕”式布局了。 其实这么排序也有其理由，我们知道，页面其主要目的是为了呈现内容的，而块级元素偏向于布局（设置宽高、内外边距、边框、行内元素的大多数配置等等），行内元素偏向于内容（与其它内容的间隔、字体大小等等），因此不难理解行内元素应该高于块级元素的层叠级别了。 此外，对于默认情况（什么都没有设置），后面的元素默认堆叠顺序会高于前面的元素，具体的体现为两个 button 按钮，如果将后者的 margin 值设为负值，其会覆盖掉先前的按钮。 注：在层叠上下文中，其子元素同样也按照上面解释的规则进行层叠。 特别值得一提的是，其子元素的 z-index 值只在父级层叠上下文中有意义。子级层叠上下文被自动视为父级层叠上下文的一个独立单元。 如何产生层叠上下文此处还是引用 MDN 上的介绍，文档中的层叠上下文由满足以下任意一个条件的元素形成（未做说明的会影响子元素的 fix 布局）： 根元素 (HTML) z-index 值不为 “auto” 的 绝对/相对定位（不影响子元素的 fix 布局） z-index 值不为 “auto” 的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex opacity 属性值小于 1 的元素（参考 the specification for opacity）（不影响子元素的 fix 布局） transform 属性值不为 “none” 的元素 mix-blend-mode 属性值不为 “normal” 的元素（不影响子元素的 fix 布局） filter 值不为 “none” 的元素 perspective 值不为 “none” 的元素 isolation 属性被设置为 “isolate” 的元素（不影响子元素的 fix 布局） position: fixed（不影响子元素的 fix 布局） will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值(参考这篇文章 -webkit-overflow-scrolling 属性被设置 “touch” 的元素（不影响子元素的 fix 布局） （补充）transform-style 为 preserve-3d 的元素 当然，这里仅仅只是列举了能够形成层叠上下文的一些情况，而其中也有部分翻译的的不是很准确（参考张鑫旭的文章，后面做了一些要点描述） 层叠上下文的层级是 HTML 元素层级的一个层级，因为只有某些元素才会创建层叠上下文。可以这样说，没有创建自己的层叠上下文的元素 将被父层叠上下文包含。 —— MDN 详解层叠上下文的形成z-index 不为 auto 的 flex 项目此指的是父元素的 display 属性为 flex/inline-flex ，其子元素的 z-index 值不为 auto，此时该子元素会形成堆叠区。 transform 属性值不为 “none” 的元素在做 position: fixed 定位时，其默认是基于页面窗口创建堆叠区（根元素有个最基础的堆叠区），然而父级元素的 transform 属性值非 none 时，其会生成一个堆叠层，使得内部的 fixed 布局不是以窗口为基本的堆叠层，而是此父级本身，从而产生很“酸爽”的 bug 体验。 不会影响 fix 布局的会生成自身层叠的例子此部分对于 -webkit-overflow-scrolling 属性未能尝试成功，可能只能手机端显现（未测试） 会影响 fix 布局的层叠的例子有人做了比较全的 demo，我 fork 了一份，删除了错误的 flex 布局例子，去掉不受影响的部分。 源码地址：传送门 总结对于层叠上下文，当发生层叠的时候，其覆盖关系遵循两条黄金准则： 谁大谁上：当具有明显的层叠水平标示的时候，如具体的 z-index 值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。 后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。 参考文章 The stacking context 层叠顺序与堆栈上下文知多少 深入理解CSS中的层叠上下文和层叠顺序 你不知道的CSS层叠上下文 深入研究 -webkit-overflow-scrolling: touch 及 ios 滚动","categories":[{"name":"CSS","slug":"CSS","permalink":"https://monocy.site/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://monocy.site/tags/CSS/"}]},{"title":"项目布局与 flex","slug":"项目布局与-flex","date":"2019-06-10T03:39:42.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/06/10/项目布局与-flex/","link":"","permalink":"https://monocy.site/2019/06/10/项目布局与-flex/","excerpt":"前言在做项目的整体框架布局时曾用了 3 个版本，由最开始兼容性最好的 position 布局，到中间过渡调整用的 calc 布局，再到目前使用的 flex 布局。因为不考虑兼容性问题，因此用最新的写法来多趟趟水，此篇就是对所写的布局的一些心得。","text":"前言在做项目的整体框架布局时曾用了 3 个版本，由最开始兼容性最好的 position 布局，到中间过渡调整用的 calc 布局，再到目前使用的 flex 布局。因为不考虑兼容性问题，因此用最新的写法来多趟趟水，此篇就是对所写的布局的一些心得。 整体布局项目的整体外框为品字形布局，顶部为 logo 、主题和用户信息（hover 展示 poper 详情）；底部左侧为对应主题的图片，以及其一、二级菜单；底部右侧为内容区。此外最右侧还有一个浮动的快捷栏。 内容区顶部有公告信息（可展示也可隐藏），底部则是自适应内容区。大致结构如下： 下面来说说如何来规划布局以及遇到的问题的处理。 历史版本及其问题position 版本早期项目并不是很复杂时，使用的是绝对定位的方式。当时顶部无主题、右侧无公告，同时也没有一直悬挂在右侧的浮动框和动画，因此处理比较简单。不过使用 position 来做定位，又一点不是很好的地方是左侧和顶部需要用 margin 撑开（防止内容被挡住），同时超出部分的滚动条展示，以及一部分切换动画的效果呈现最终让我下定决心来更改整体的布局。 calc 版本中期因为还在开发项目，因此采取了一个过渡方案 calc，将各部分的宽度计算出来，从而做到页面的布局展现。这个版本倒是没什么问题，在 chrome 上运行的很稳定，由于不清楚 calc 计算会不会影响页面的渲染速度，因此最后还是改成了 flex 布局。 flex 布局分析整体结构整体的结构可分为上下结构，而下半部分又拆分为左右结构，因此，在设置完顶层的 html 和 body 之后，给项目的最外层 container 元素设以下属性作为外层容器： 1234567.container &#123; height: 100%; width: 100%; display: flex; flex-direction: column; position: relative;&#125; 然后顶部设置固定高度 60px，底部默认 flex-grow: 1 撑开即可。然而在内容撑满后，这样设置出现了顶部固定高度部分被压缩了。 顶部结构顶部可分为三个部分：左侧的 logo、中间的主题列表以及右侧的用户头像部分。顶部基本太多问题，因为用户头像部分有多个不同的行内元素，而这块产生了行内元素无法对齐的问题（于是采用了最为方便的 flex 写法） 底部结构底部内容区域分为左右结构，左侧菜单展示（用 element-menu 很简单），右侧就是内容区了。这部分左侧收缩有做 transition 动画，对于页面图表渲染较多的情况会比较卡（动画去掉了），基本上没遇到什么麻烦；右侧有一个很头疼的问题，那就是页面顶部的公告，因为是可有可无的，而公告下面的内容区要一直保证能够占满内容区（如果内容超出则显示滚动条）。 有人会说：“（折中方案）这有什么难的，内容区 flex 布局，上侧公告区（flex-shrink: 0），下部分内容区默认添上 flex-grow: 1，然后溢出滚动就可以了～”。如果事情能这么简单就好了。需求却并不是上下结构，而是一个整体，因为滚动条区域包裹了顶部公告，同时还要兼容以前的页面，即： 当 “呈现的内容高度” + “公告高度（得考虑无公告的情况）” &lt; “内容区域高度” 时无滚动条；反之有滚动条。此外还需要做好老代码的兼容处理。 emmmmm，果然世界上没有产品所想不出来的主意啊，当然，在“折中方案”上线之后，慢慢的终于摸索出了最佳方案。 右侧悬浮框右侧悬浮框虽然并无太多内容，但是需要在 Vue 项目内支持拖拽，大致为：拖拽时颜色变浅，停止拖拽时恢复原样。由于 Vue 提供 drag 方法，因此比较容易想到的方式是在监听拖拽的起止动作，然后动态绑定 class 控制其 Visibility 显隐性，然而基本上每次开始拖拽后立马就结束拖拽了，最终定位的问题就在 Visibility 上。 遇到的问题固定高度内容收缩问题在 flex 布局的模式下，子项的默认值为： 1flex: 0 1 auto; 其分别表示 flex-grow 为 0，即不会参与多余部分的分配（不可扩张）；flex-shrink 为 1，即当整体空间无法装下所有的内容时，该部分会按照一定的规则来压缩；flex-basic 为 auto，即默认以内容区高度为基础高度。 那么问题就来了。因为 flex-basic 为 auto，内容区域高度是由内容来决定的，虽然我们通过设置 height: 60px 将高度固定撑开，但是对于 flex 来说，我的 basic 部分并没有这么高（内容没有达到 60px），同时我这部分又是可压缩的，因此我可以匀一点来尽量使得另一部分能够撑满溢出的内容。而结果可想而知（顶部被压缩了） 解决的思路有三种： 设置 flex-shrink: 0 来禁止其被压缩 设置 min-height: 60px 从而保证最低的高度 将其包裹的内容区高度设置为 60px 行内元素对齐问题这部分先前有写过浅谈行内元素，因为各部分默认对齐方式不同，此处仅写出两种最为快捷的方法： 设置父级为 flex，然后设置 align-items: center 修改各子元素的对齐方式为 vertical-align: center 内容区的智能滚动条问题问题简单的抽象为一个有固定宽高的 flex 布局的父容器（column 排序），其包含两个子节点： 第一个节点可有可无，呈现时为定高的状态； 第二个节点当内容不是很高时，其会自动填充剩余部分（剩余部分 + 此节点内容 + 第一个节点内容 = 父容器高度）；当内容有足够高时，父级会出现滚动条来显示溢出的内容。 老版本此部分的实现是： 12345.content &#123; height: 100%; width: 100%; position: relative;&#125; 理想中最完美的升级方案是在原有的基础上添加一个 flex-grow: 1 然后删除 height: 100%，但是由于要不影响原有的代码（仅使用 flex-grow 不知道为什么，某个页面会出现一个只滚动 1px 距离的滚动条，方案 pass），因此做了下改变即添加一项 min-height: calc(100% - 60px) 然后滚动条就没有了。 前后试了一下，发现必须动态计算的 min-height 值与固定值之和为 100% 时才生效，个人感觉应该是因为刚好占满整个屏幕，因此不会触发多余的 flex 的动态计算，因此也就没有额外的滚动条了；当顶部公告消失时， min-height &lt; height 值，使内容能自动充满屏幕。 如果并非需要兼容历史代码，建议直接 flex-grow: 1，删除 height: 100% 这样应该会好调整一些。 诡异的拖拽事件最开始写拖拽方法时添加的类为： 123.onDrag &#123; visibility: hidden;&#125; 在拖拽时隐藏元素，松开时显示元素（最开始实验阶段的 vue/cli3 时可以通过此方法实现），后来版本升级后，该方法失效了，会使得隐藏后会立即事情元素焦点，然后立即出发了 dragend 事件，此较好的解决方法目前是将 visibility: hidden 改成了 opacity: 0，但是更新后拖拽过程中设置元素 visibility: hidden; 会使得焦点丢失，这个原因目前不是很明确。 实例代码 参考例子 参考文章 flex设置成 1 和 auto 有什么区别 W3C flex","categories":[{"name":"CSS","slug":"CSS","permalink":"https://monocy.site/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://monocy.site/tags/CSS/"}]},{"title":"JavaScript 对象","slug":"JavaScript-对象","date":"2019-06-06T09:28:38.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/06/06/JavaScript-对象/","link":"","permalink":"https://monocy.site/2019/06/06/JavaScript-对象/","excerpt":"前言对象是 JavaScript 的七种主要类型中的一种（string、boolean、number、null、undefined、symbol、object），也是这七种主要类型中最为复杂的一种类型，了解对象对学习 JavaScript、了解 this和作用域链，以及之后的“类”的概念都十分重要，而此篇就从边边角角来介绍 JavaScript 中的对象。","text":"前言对象是 JavaScript 的七种主要类型中的一种（string、boolean、number、null、undefined、symbol、object），也是这七种主要类型中最为复杂的一种类型，了解对象对学习 JavaScript、了解 this和作用域链，以及之后的“类”的概念都十分重要，而此篇就从边边角角来介绍 JavaScript 中的对象。 基础内容基本语法对象写法有两种：声明（文字）形式和构造形式。（一般很少使用构造形式） 12345// 声明文字形式const obj = &#123;&#125;;// 构造形式const obj = new Object(); 写法区别：声明文字形式能传递更多的键/值，构造形式得一个个的添加。 类型为什么要单独强调类型？因为在最开始，我也是认为 JS 中万物接对象，其实不然，像我们所熟悉的简单基本类型（string、boolean、undefined、null和number）就并非对象（字面量形式）。函数就是对象的一个子类型（技术角度来说即“可调用的对象”）；同样的，数组也是，只不过是具备一些额外的行为。 typeof null === &#39;object&#39; 是语言本身的 bug，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object ，由于 null 的二进制表示是全 0，因此在做类型判读时会出现“误判”的问题。 基础类型与对象类型的主要区别就是对象的生存期，使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自基本类型则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型添加属性和方法。如： 123let name = 'ConardLi';name.color = 'red';console.log(name.color); // undefined 内置对象JavaScript 中还有一些内置对象，例如： String Boolean Number Object Function Array Date RegExp Error 它们可以类比为 Java 中的 Class（但从 JavaScript 角度来说，它们只是一些可以当作构造函数的内置函数）。但是在使用 JavaScript 时，更为常用的方式是直接声明一个字面量，如： 1234567891011const str1 = \"This is a string\";const str2 = new String(\"This is a object\");typeof str1 === 'string'; // truetypeof str2 === 'object'; // truestr1 instanceof String; // falsestr2 instanceof String; // trueObject.prototype.toString.call(str1); // [object String]Object.prototype.toString.call(str2); // [object String] 这里解释了字面量并非由 String 的构造函数得到的对象，实际上 str1 为何其表现形式和 str2 无任何不同（从字符串的操作的层面），是因为引擎会自动将字面量转换成其对应的对象类型，因此可以访问对应类型的属性和方法。 属性与方法对象的内容是由一些存储在特定命名位置的值组成的，我们称之为属性（可类比指针来理解）。对于基础类型来说，其所存储的值对应一块固定的空间，不会动态改变；而对于对象这样的较为复杂的类型来说，它们存储的为一块内存区域的引用。 通俗的来说，基础类型就像手机店货架上的手机壳，它们是实物，“所见即所得”；而复杂类型就像是手机店柜子内的高价手机，展示的是模型机，其象征这这一型号的所有手机，需要的时候通过此去对应仓库获取真机。 访问方式对象属性的访问方式分为两种，例如： 1234567const obj = &#123; name: 1 &#125;// 属性访问obj.name// 键访问obj['name'] 两种方式各有优劣，前者在写的时候较为方便，但是得满足标识符的命名规范，比较固定；后者的写法比较多样（ES6支持可计算属性名），缺点是没有前者直接。 需要注意的是，属性名永远都是字符串。如果使用字符串之外的值作为属性名，那么其会先转换成字符串，例如： 12345678const obj = &#123;&#125;;obj[true] = 'boolean';obj[&#123;&#125;] = 'object';obj[3] = 'number';obj['true']; // booleanobj['[object object]']; // objectobj['3']; // number 函数属性有时候对象中的属性为一个函数，我们习惯上称这样的属性为“函数的方法”（类比 C 语言）。然而从技术角度来说，在 JavaScript 中，函数永远也不会“属于”一个对象，因为 this 是动态绑定至对象上的（先前有写过这么一篇文章），函数与对象间的关系并不稳定，因此对象与函数最多也只能称作为间接关系。最为保险的说法可能是“函数”和“方法”在 JavaScript 中是可以互换的。 123456789101112131415const obj = &#123; foo: function() &#123; console.log(1) &#125;&#125;// 基本上可以等价于function foo() &#123; console.log(1);&#125;const obj1 = &#123; foo: foo&#125; 数组我们知道，在 JS 中数组也是“对象”，但是相对于对象来说，数组有一套更为结构化的值存储机制（通过索引的方式），例如： 123const arr = [1, 2, 3];arr[0]; // 1 由于数组也是一个对象，因此我们也可以给数组添加属性，如： 12// 沿用上例arr.bar = &apos;bar&apos;; 注意：如果试图像数组内添加一个属性，而属性“看起来”像一个数字（如字符串数子），那么它会变成一个数值下标 提升内容属性描述符最早接触到属性描述符的时候还是在读JS红宝书的时候，不过那时候不是很懂有啥用，随着接触的东西逐渐变多，源码也看了一部分，对属性描述符也有了一定的程度的理解。 自 ES5 以来，JS 的所有属性都具备了属性描述符，通过 Object.getOwnPropertyDescription(&lt;obj&gt;, &lt;prop&gt;) 能够拿到对应属性的描述，包含内容如下： 123456&#123; value: 'xxx', // 值 writable: true, // 是否可写（默认） enumerable: true, // 是否可枚举（默认） configurable: true // 是否可配置（默认）&#125; 当然，我们也可以通过 Object.defineProperty(&lt;obj&gt;, &lt;prop&gt;, {/* */}) 来修改属性描述符。 writablewritable 决定是否可以修改属性的值，如果设置为 false，那么修改属性值时会静默失效 123456789101112const obj = &#123;&#125;;Object.defineProperty(obj, 'a', &#123; enumerable: true, configurable: true, writable: false, value: \"static\"&#125;);obj.a = 'public';obj.a; // static（严格模式下会报错） 然而，当配置中有配置 getter/setter 时，这个属性会被定义为“访问描述符”（与“数据描述符”相对），对于访问描述符来说， JavaScript 会忽略其 value 和 writable 属性（具体来说此），例如： 12345678910111213const obj = &#123; a: 2&#125;;Object.defineProperty(obj, 'a', &#123; enumerable: true, configurable: true, get() &#123; return 3 &#125;&#125;);obj.a; // 3 configurableconfigurable 决定对象的属性是否可配置。与 writable 不同，writable 控制的是对象属性值能否改变，而 configurable 配置的是属性描述符能否改变，即后者是单向的（某个对象的 configurable 设置为 false 后就无法将其再设置为 true 了）。 除此以外，其还禁止删除此属性，如： 1234567891011121314151617181920const obj = &#123; a: 'static'&#125;;obj.a; // 2delete obj.a;obj.a; // undefinedObject.defineProperty(obj, 'a', &#123; enumerable: true, configurable: false, writable: true, value: \"static\"&#125;);obj.a; // 2delete obj.a;obj.a; // 2 注： delete 仅是一个删除对象属性的操作，并非一个释放内存的工具 特例：当 configurable 设置为 false 之后，writable 可由 true 更改为 false，但无法由 false 更改为 true。 Enumerable顾名思义，此描述符控制的事属性是否会在遍历对象时，将其枚举。例如： 123456789101112131415161718const obj = &#123; bar: 1, foo: 2&#125;Object.defineProperty(obj, 'c', &#123; enumerable: false, configurable: true, writable: true, value: 3&#125;);for (const key in obj) &#123; console.log(key, obj[key]); // 没有 [c 3]&#125;'c' in obj; // trueobj.hasOwnProperty('c'); // true for .. in 循环可以遍历对象的可枚举属性列表（包括[[Prototype]]链），而遍历属性的值我们通常用的是 for .. of，如： 12345const arr = [1, 2, 3];for (const value of arr) &#123; console.log(value) // 1, 2, 3&#125; for .. of 首选会向被访问的对象请求一个迭代器对象，然后通过迭代器对象的 next() 方法来遍历返回值，数组内默认会带有迭代器，因此我们可以直接将 for .. of 运用至数组中。但是对象却没有，我么可以这样造一个自定义迭代器。 123456789101112131415161718192021const obj = &#123; a: 1, b: 2&#125;;Object.defineProperty(obj, Symbol.iterator, &#123; enumerable: false, configurable: true, writable: false, value: function() &#123; const self = this; let idx = 0; const ks = Object.keys(self); return &#123; next: function() &#123; value: self[ks[idx++]], done: (idx &gt; ks.length ) &#125; &#125;; &#125;&#125;) 遍历数组下标使用的是数字顺序，但是遍历对象时其顺序是不确定的。因此在不同环境要想数据展现形式保持一致，那么一定不要相信任何观察到的顺序，因为它们是不可靠的。 不变性对象常量我们可以通过设置对象属性的 writable 来设置对象常量，这样能做到真正意义上的不可修改（类比 const 声明） 禁止扩展对象默认是可扩展的，加入想要禁止一个对象的扩展性，即不能后期新增属性，那么可以使用 Object.preventExtensions(&lt;obj&gt;) 密封Object.seal(&lt;obj&gt;) 会创建一个密封对象，其会在一个现有对象上调用 Object.preventExtensions() 并将所有的属性标记为 configurable: false。其不仅不能添加新属性，也不能重新配置或删除原有属性（可修改属性值）。 冻结Object.freeze(&lt;obj&gt;) 会创建一个冻结对象，其会在对象上调用 Object.seal() 并将所有的属性标记为 writable: false，这样就无法修改其值。 注意：对象中引用的对象无法被密封和冻结，只有非引用对象受影响最为全面，并且是浅操作。 参考文档 《你所不知道的 JavaScript》","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"markdown 语法","slug":"markdown-语法","date":"2019-05-30T05:13:20.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/05/30/markdown-语法/","link":"","permalink":"https://monocy.site/2019/05/30/markdown-语法/","excerpt":"前言由于写文章时经常会用到 Markdown 语法，但是除了基础的 Markdown 语法外，hexo 还支持一些语法扩展，因此为了方便查找扩展语法，写此篇以做记录。","text":"前言由于写文章时经常会用到 Markdown 语法，但是除了基础的 Markdown 语法外，hexo 还支持一些语法扩展，因此为了方便查找扩展语法，写此篇以做记录。 区块元素段落与换行一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行（此便是段落）。 Markdown 中多个空格表示换行，除此外 &lt;br /&gt; 标签也表示换行（回车会处理成空格）。 推荐的换行方式：两次回车，这样结构更清晰一些 标题标题使用 # 表示其层级（还有下等号或横线的形式，单不推荐） 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 由于 一、二、三级标题都有下划线，个人偏向从三级标题开始，下划线过多看区块划分不是很舒服。 区块引用区块引用只需要在没行前添加 &gt; 符号即可，可嵌套 markdown 语法，例如： 12&gt; &gt; 嵌套引用&gt; **嵌套加粗** 列表无序列表无序列表一般通过 -、* 或者 + 作为其语法，例如： 123- 项目一- 项目二- 项目三 有序列表有序列表用 阿拉伯数字 来表示，例如： 1231. 项目 A2. 项目 B3. 项目 C 列表段落列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 123* This is a list item with two paragraphs. &gt; This is the second paragraph in the list item.* Another item in the same list. 代码区块代码区块只要简单地缩进 4 个空格或是 1 个制表符就可以，此处推荐使用 ``` 来包裹代码块，如： 123`` html&lt;p&gt;这是 html 代码&lt;/p&gt;`` 注：为了能展示代码块的写法，此处省略了一个 ` 分割线一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。如： 1------ 表格表格写法稍微复杂一点，第二行中的 : 表示对齐方式，默认左对齐 1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 区段元素链接和图片链接的语法为： 1[中文提示](&lt;address&gt;) 图片语法为 1![中文提示](&lt;address&gt;) 强调Markdown 使用双星号（*）或双底线（_）作为标记强调字词的符号，例如： 1**强调部分** 斜体Markdown 使用单星号（*）或双底线（_）作为标记强调字词的符号，例如： 1*斜体部分* 其它反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，如 * 1\\*literal asterisks\\* 拓展语法引用块123&#123;% quote David Levithan, Wide Awake %&#125;Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.&#123;% endquote %&#125; Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 居中引用123&#123;% cq User Name%&#125; This is a center quoet list&#123;% endcq %&#125; This is a center quoet list 笔记块123&#123;% note default %&#125; Any content (support inline tags too.io).&#123;% endnote %&#125; Any content (support inline tags too.io). 笔记块有 2 参数：第一个为类型：[default | primary | success | info | warning | danger]第二个表面是否显示图标（写了右侧内容就没 icon 了）: no-icon 参考文章 Markdown 教程 hexo 标签插件 next Tag Plugins","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://monocy.site/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://monocy.site/tags/Markdown/"}]},{"title":"webpack 文件分离思想","slug":"webpack-文件分离思想","date":"2019-05-23T11:17:39.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/05/23/webpack-文件分离思想/","link":"","permalink":"https://monocy.site/2019/05/23/webpack-文件分离思想/","excerpt":"前言先前做 vue 项目时，对于代码分割做了一个 DllPlugin 的 demo ，项目内的收益也挺不错（编译时间减少了 20s 左右），但是今天在看文档时，无意间又扫到了 SplitChunksPlugin。那么问题就来了，先前用的是 DllPlugin ，它和这个 SplitChunksPlugin 又有什么区别呢。这里简单记录下调研所获得的一些收获。","text":"前言先前做 vue 项目时，对于代码分割做了一个 DllPlugin 的 demo ，项目内的收益也挺不错（编译时间减少了 20s 左右），但是今天在看文档时，无意间又扫到了 SplitChunksPlugin。那么问题就来了，先前用的是 DllPlugin ，它和这个 SplitChunksPlugin 又有什么区别呢。这里简单记录下调研所获得的一些收获。 SplitChunksPlugin自 webpack 4.0 上线之后，CommonsChunkPlugin 已被替换成 SplitChunksPlugin，旨在优化 chunk 的拆分。了解 SplitChunksPlugin 之前，我们需要知道为什么会弃用 CommonsChunkPlugin，CommonsChunkPlugin 的设计思路是什么，目前的 SplitChunksPlugin 在原来的思路上有什么改进。因此先看看 CommonsChunkPlugin 的设计思路 CommonsChunkPlugin 的设计思路原本的 CommonsChunkPlugin 的思路为： Create this chunk and move all modules matching minChunks into the new chunk 即： 满足 minChunks 的引用次数时，都会将对应的模块抽离如一个新的 chunk 文件中，这个文件为所有的业务文件的父级。 而这种设计思路带来了会造成模块打包冗余。总的来说会造成这么几个问题： 产出的 chunk 在引入时，会包含重复的代码； 无法优化异步 chunk； 高优的 chunk 产出需要的 minchunks 配置比较复杂。 让我们具体来看下面两种情况。 产生多余模块假如我们的文件是这么配置的： 12345minChunks: 2entryA: vuex vue AcomponententryB: vue axios BComponententryC: vue vuex axios CComponent 那么产出的文件为： 12vendor-chunk: vuex vue axioschunkA~chunkC: only the Component 带来的问题：entryB 并没有使用 vuex，entryA 并没有使用 axios ，但是从产出的文件上来看，entryA 与 entryB 都引入了部分“脏”模块，这并不太好。 异步支持差除此之外，CommonsChunkPlugin 对于异步的模块不是很友好。例如： 12345minChunks: 2entryA: vuex vue AcomponentasyncB: vue axios BComponententryC: vue vuex axios CComponent 产出的 chunk 为： 1234vendor-chunk：vue vuexchunkA: only the componentsasyncB: vue axios someComponentschunkC: axios someComponents 带来的问题：异步引入 asyncB 之后会引入过多的 module。 SplitChunksPlugin 的设计思路SplitChunksPlugin 优化了 webpack 的打包策略，使用自动重复算法，会自动计算出各页面公共的包引用以及部分页面公共的包引用，当然，对于那些部分共有但是阈值过小的文件其不会创建单独的输出文件，因为其大小不值得去新开一个请求。（缓存策略配置在 cacheGroup 中） 注：减少 maxInitial/AsyncRequest 会加大 module 的冗余，但是会进一步的减少请求。 SplitChunksPlugin 默认的分包策略基于以下 4 个条件： 新代码块可以被共享引用，或这些模块都是来自 node_modules; 新产出的 vendor-chunk 的大小得大于 30kb; 按需加载的代码块（vendor-chunk）并行请求的数量不多于 5 次； 初始加载的代码块，并行请求的数量不多于 3 次。 SplitChunksPlugin 配合使用 RuntimeChunk 对运行时的 hash 变动做优化（相当于 CommonsChunkPlugin 的两次使用） DllPluginDLLPlugin 这个插件是在一个额外独立的 webpack 设置中创建一个只有 dll 的 bundle，也就是说，除了 webpack.config.js，项目中还会新建一个 webpack.dll.config.js 文件来配置 dll 的打包。webpack.dll.config.js 作用是把所有的第三方库依赖打包到一个 bundle 的 dll 文件里面，还会生成一个名为 manifest.json 文件。 该 manifest.json 的作用是用来让 DllReferencePlugin 映射到相关的依赖上去的。（可类比 CommonsChunkPlugin 的两次打包或者 RuntimeChunk 的运行包配置） DllPlugin 的设计思路SplitChunksPlugin 虽然也是将公共模块抽离，但是其每次打包的时候还是会去处理一些第三方依赖库，只是它能把第三方库文件和我们的代码分开掉，生成一个独立的 js 文件。但是它还是不能提高打包的速度。 DLLPlugin 它则是提前将公共的包构建出来，使得在 build 时过滤掉这些构建过的包，使得在正是构建时的速度缩短。所以其相对来说打包速度会更快。 总结总的来说，两种打包的方式各有优劣。 如果开发的项目是锁定版本的，同时想要提升构建速度，这时候可以考虑使用 DllPlugin 的分包策略，提前将不变的一些依赖构建好，每次构建时仅构建业务代码即可。 如果项目会升级，同时想要减少后期对于打包步骤的操作（构建时间不考虑），那么优先使用 SplitChunksPlugin 来配置分包策略，毕竟 DllPlugin 得走两步。 对于两者一起使用的情况，目前查阅过两者一起使用的例子（貌似会打包重复，有冲突）不过网上的结论比较陈旧，笔者暂未做测试，之后空闲下来再做补充。 参考文档 webpack4：连奏中的进化 webpack 的自动重复数据删除算法示例 webpack4 tree-shaking 与 side-effect webpack 、manifest 、runtime 、缓存与 CommonsChunkPlugin vue-cli 中的 CommonsChunkPlugin 都做了些啥 Webpack4 之 SplitChunksPlugin 规则 深入浅出的webpack构建工具—DllPlugin DllReferencePlugin提高构建速度(七) webpack4中， splitchunks 和 dllplugin 可以并存吗？","categories":[{"name":"Webpack","slug":"webpack","permalink":"https://monocy.site/categories/webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://monocy.site/tags/Webpack/"}]},{"title":"深入了解 this","slug":"深入了解-this","date":"2019-05-19T13:33:54.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/05/19/深入了解-this/","link":"","permalink":"https://monocy.site/2019/05/19/深入了解-this/","excerpt":"前言在 JavaScript 学习过程中，除了作用域与闭包之外，困扰我们的难点还有 this，甚至可以说是前端 JS 学习的噩梦。实际上 this 并没有想象中的那么复杂，只是开发者往往会将理解过程复杂化，在缺乏清楚认识的情况下，this 对我们来说就完全是一种魔法了。而此篇就来揭开 this 神秘的面纱。 注：此篇为学习《你所不知道的 JS》时的心得总结","text":"前言在 JavaScript 学习过程中，除了作用域与闭包之外，困扰我们的难点还有 this，甚至可以说是前端 JS 学习的噩梦。实际上 this 并没有想象中的那么复杂，只是开发者往往会将理解过程复杂化，在缺乏清楚认识的情况下，this 对我们来说就完全是一种魔法了。而此篇就来揭开 this 神秘的面纱。 注：此篇为学习《你所不知道的 JS》时的心得总结 示例分析工作中我们常常遇到 this 指向问题，看个简单的代码： 12345678910111213141516171819202122function foo(num) &#123; console.log(`foo: $&#123;num&#125;`); this.count++;&#125;foo.count = 0;// case 1:for (var i = 0; i &lt; 10; i++) &#123; if (i &gt; 5) &#123; foo(i); &#125;&#125;console.log(foo.count); // 0// case 2:for (var i = 0; i &lt; 10; i++) &#123; if (i &gt; 5) &#123; foo.call(foo, i); &#125;&#125;console.log(foo.count); // 4 了解比较深入的会一眼看出为什么加一个 call 就没问题（强绑定指向），了解的一般的就会通过声明一个全局变量来缓存对应的值来绕过 this，虽然用这种其它变量替代 this 能够绕过这个问题，但是这样永远也了解不到 this 的真谛。回过头来思考，为什么必须强绑定才能正确指向？如果不进行强绑定，this 默认又指向什么呢？要深入了解到 this 的原理，首先我们得认识到自己的理解误区。 理解误区学习 this 时常见的错误理解大致有两种： this 指向函数自身 this 指向函数作用域 可能因为我们最早接触的语言是 C 语言，而 C 语言的编译顺序大致为： 词法分析 语法分析 语义分析 中间代码生成 代码优化（可不要） 目的代码生成 因此在学习 JS 是会自然而然的套用此方法来理解函数。我们可以试想一下，如果 JS 也走这么一套流程来处理，那么网页的加载得多慢啊。因此在编译这部分我们得抛弃 C 语言的那一套逻辑，这样才方便理解 this 的指向。 与 C 语言编译不同，JS 的编译为运行时编译，其会先从头到尾“过”一遍待解析的文件，粗略的提取其中的变量声明，然后逐行解析编译（解释了为什么会变量提升），因此 this 的状态就并非那种能够生成中间代码的存储态，而是动态的。也就是说，当函数执行时，this 才会真正的进行绑定，而并不是在最开始（遍历 JS 语法）时绑定，毕竟没有听说过什么“ this 提升”对吧？ 简而言之，因为 this 是在函数调用时才进行绑定，所以 this 并不是指向其所在的函数自身，也不指向函数所在的词法作用域，它的指向完全取决于函数在哪里被调用的。 this 全面解析调用位置前面有提到 this 指向取决于函数是在哪里调用的，即找到函数的调用位置，相当于我们就定位了 this。而寻找函数的调用位置，首先得找到函数所在的栈的位置，该栈所在的环境即 this 的指向。举个例子： 123456789101112131415function foo() &#123; // 当前所在的栈为 foo // 因此，当前调用位置是 全局作用域（this = window） console.log('foo'); bar(); // bar 调用位置&#125;function bar() &#123; // 当前所在的栈为 foo -&gt; bar // 因此当前的调用位置是在 foo 中 (this = this(foo) = window) console.log('bar')&#125;foo(); // foo 调用的位置 既然我们已经找到了 this 调用位置，那么 this 的值此时到底是什么，它所绑定的内容又是什么呢，而这就涉及到 this 的绑定规则。 绑定规则找到 this 的调用位置之后，我们可以按照以下四条规则来判断 this 绑定的对象。 如果由 new 调用，那么 this 绑定到新创建的对象。 如果由 call 或者 applay（或者 bind）调用，那么绑定到其指定的对象。 如果由上下文对象调用，则绑定到该上下文对象。 默认：严格模式下绑定至 undefined，否则绑定至 window。 接下来就让我们自下而上，由面到点的了解这些绑定规则以及其排序来由。 注：上下文对象绑定即所谓的隐式绑定 默认绑定举个很简单的例子： 1234567function foo() &#123; console.log(this.a);&#125;var a = 2;foo(); // 2 调用 this 的调用栈在 foo 中，当前所处的位置是全局作用域，因此 this 指向全局的 window。 回头看先前调用位置时列举的例子，通过默认绑定规则，再加上引用传递，因此各部分的 this 指向都指向全局的 window 对象。 隐式绑定隐式绑定，即规则的调用位置是否拥有其上下文（默认为全局的 window 对象）。例如： 12345678910function foo() &#123; console.log(this.name);&#125;const obj = &#123; name: \"test\", foo: foo&#125;;obj.foo(); // test 在非严格模式下，全局环境的 this.name === window.name，此时所处的上下文环境为全局环境，而此例的 foo 调用是通过 obj.foo 来调用的，this 的调用位置为 foo，但是 foo 的引用落脚点此时不是 window 了，而是 obj 了，因此通过隐式绑定，this 此时之乡的是 obj，即此时的 this.name === obj.name。 此处需注意的一点是 obj.foo 的 this 绑定的是 obj（隐士绑定），这是因为，对象属性的引用链只有最顶层会影响调用位置（或者是说最后一层），例如： 123456789101112131415function foo() &#123; console.log(this.name);&#125;const obj1 = &#123; name: \"test1\", obj2: obj2&#125;;const obj2 = &#123; name: \"test2\", foo: foo&#125;;obj1.obj2.foo(); // test2 而在隐式调用的情况下，最容易出现的问题是隐式丢失，例如： 12345678910111213141516171819202122function foo() &#123; console.log(this.name);&#125;const obj = &#123; name: \"test\", getName: foo&#125;;// Case 1: 解构const &#123; getName &#125; = obj;getName(); // undefined// Case 2: 直接取引用（类比解构）const linkFunc = obj.getName;linkFunc(); // undefined// Case 3: 引用传递（类比 setTimeout)function linkPassFunc(fn) &#123; fn()&#125;linkPassFunc(obj.getName) 注：参数传递就是一种隐式传递，其取得是对象的引用 显示绑定JS 提供一种显示更改 this 绑定的函数：apply、call，例如： 123456789function foo() &#123; console.log(this.name);&#125;const obj = &#123; name: 'test'&#125;foo.call(obj); // test 通过 foo.call 可以显示的将 this 绑定在 obj 上，显示绑定无法解决隐式绑定中的引用传递问题（上面的 Case 3），而通过一种变形“硬绑定”可以解决。 硬绑定与显示绑定不同的是，硬绑定会提前将 this 的指向在过渡函数内提前绑定上，这样当传入这个过渡函数时，this 就不会被隐式修改了，例如： 12345678910111213141516function foo() &#123; console.log(this.name);&#125;const obj = &#123; name: 'test'&#125;// 过渡函数，内部提前显示绑定 thisfunction bar() &#123; foo.call(obj)&#125;bar(); // testsetTimeout(bar, 100); // test 其实这种方式特别常见（如大多数源码中），将上例稍微变化一下，如： 123456789101112131415161718function foo(otherContent) &#123; return `$&#123;this.prefix&#125;-$&#123;otherContent&#125;`;&#125;function bar(fn, obj) &#123; // 此处的 arguments 为此无名函数的 arguments，硬绑定函数 this 指向 return function () &#123; return fn.apply(obj, arguments) &#125;&#125;const obj = &#123; prefix: 'my'&#125;const prefixFunc = bar(foo, obj);const prefixStr = prefixFunc('age'); 绕是绕了点，根据函数式编程的带入思想，其实就相当于 1const prefixStr = foo.apply(obj, ['age']); 注： 硬绑定会大大降低函数的灵活性，使用硬绑定后就无法使用隐式绑定或者显示绑定来改变 this 了。 new 绑定JavaScript 中所谓的“构造函数”其实与其它语言的类的构造函数不同，它并不属于某一个类，也不会去实例化一个类。在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。使用 new 来调用函数时，会执行以下操作： 创建（或者说构造）一个全新的对象 这个新对象会被执行 [[原型]] 连接 这个新对象会绑定到函数调用的 this 如果函数没有返回其它对象，那么 new 表达式中的函数调用会自动返回这个新对象 面试题中可能会遇到这么一个题： 12345678910111213function foo1(a) &#123; this.a = a;&#125;function foo2(a) &#123; this.a = a; return &#123; a: 2 &#125;;&#125;const f1 = new foo1(1);const f2 = new foo2(1);console.log(f1.a === f2.a); 知道这个 new 返回对象的“魔术”之后，我们就很清楚答案是 false 了，因为 foo2 有返回对象。而 foo1 因为没有函数返回值，因此会构造一个新对象并将 this 绑定至该新对象上。 new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。 提示： f1.a 为 1; f2.a 为 2 优先级现在规则我们已经比较清楚了，那么剩下的就是找到函数的调用位置，然后该使用那种规则去匹配。“默认绑定”毫无疑问是四条规则中优先级最低的，那么另外三条规则的优先级又该如何排序呢？那么我们一一来分析～ 先给出结论： new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 隐式绑定和显示绑定举个很简单的例子： 123456789101112131415161718192021function foo() &#123; console.log(this.a);&#125;const obj1 = &#123; a: 2, foo: foo&#125;;const obj2 = &#123; a: 3, foo: foo&#125;;// 隐式绑定obj1.foo(); // 2obj2.foo(); // 3// 显示绑定尝试更改obj1.foo.call(obj2); // 3obj2.foo.call(obj1); // 2 通过对比可以看到，显示绑定优先级更高。那么隐式绑定和 new 绑定的优先级顺序呢？ 隐式绑定和 new 绑定12345678910111213141516function foo(a) &#123; this.a = a;&#125;const obj1 = &#123; foo: foo&#125;;// 隐式绑定为 obj1 绑定 a 属性obj1.foo(2);console.log(obj1.a); // 2// new 绑定尝试更改返回对象中的 this 指向（隐式原理应该 this 指向链尾的 obj1）const bar = new obj1.foo(4);console.log(obj1.a); // 2console.log(bar.a); // 4 可以看到 new 绑定比隐式绑定优先级高，接下来就只剩 new 绑定和显示绑定的优先级了。 new 绑定和显示绑定由于 new 和 call/apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接进行测试。但是我们可以用硬绑定来测试它们的优先级。举个例子： 123456789101112131415function foo(a) &#123; this.a = a;&#125;const obj1 = &#123;&#125;;// 为 foo 显示绑定 this 为 obj1const bar = foo.bind(obj1);bar(2);console.log(obj1.a); // 2// new 尝试修改返回对象的 this 指向const baz = new bar(3);console.log(obj1.a); // 2console.log(baz.a); // 3 在 new 中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用 new 进行初始化时就可以只传入其余的参数。bind(…)的功能之一就是可以把除了第一个参数（第一个参数用于绑定 this）之外的其他参数都传递给下层的函数（这种技术称为“部分应用”，是“柯里化”的一种）。举例来说： 1234567891011function foo(p1, p2) &#123; this.val = p1 + p2;&#125;// 之所以使用 null 是因为在本例中我们并不关心硬绑定的 this 是什么// 反正使用 new 时 this 会被修改const bar = foo.bind(null, 'p1');const baz = new bar('p2');baz.val; // p1p2 注意，这种通过 null 的绑定其实会使用“默认绑定”规则，将 this 绑定至全局对象，这在使用第三方库时会存在风险，更为稳妥的方法是创建一个真正意义上的空对象，如： let ø = object.create(null)，然后将此 ø 作为绑定的作用域（const bar = foo.bind(ø, ‘p1’);） 绑定例外被忽略的 thiscall、apply、bind 接受绑定的对象为 undefined、null 时，在调用时会被忽略，使用的是默认绑定规则，严格来说最好使用一个真正的 ø 元素来作为绑定对象（前面已经提到）。 12345678function foo() &#123; console.log(this.a);&#125;var a = 2;// 其实绑定的还是 window，可能造成全局污染foo.call(null); // 2 间接引用这个就不难说明了，间接引用会使得隐式绑定最顶端的对象改变，造成 this 的指向非我们所想象的对象，例如： 123456789101112const test = &#123; a: 2, foo: function() &#123; console.log(this.a); &#125;&#125;;var a = 3;// test 已经不是绑定顶端的对象，变成了 window 了const func = test.foo;func(); // 3 箭头函数ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据外层作用域来决定 this。例如： 123456function foo() &#123; setTimeout(() =&gt; &#123; // 此处的 this 在词法上继承自 foo console.log(this.a); &#125;);&#125; 因此，我们在使用这种 ES6 的“胖箭头”时，就可以抛弃 ES5 中的 var self = this 的“词法作用域”式的代码了。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"}]},{"title":"vue-cli3 的快速插件开发","slug":"vue-cli3-的快速插件开发","date":"2019-05-09T08:20:08.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/05/09/vue-cli3-的快速插件开发/","link":"","permalink":"https://monocy.site/2019/05/09/vue-cli3-的快速插件开发/","excerpt":"前言不久前组内有大佬发布了一个 vue-cli3 的 dll 包，作为一个在 vue 项目内摸爬滚打的萌新，是时候该学习点儿新的技术了，于是在闲暇之余，我拷贝了一份代码，同时研究该如何从“零”开始编写一个 dll 包（该部分以 webpack 的 dllPlugin 作为例子）。","text":"前言不久前组内有大佬发布了一个 vue-cli3 的 dll 包，作为一个在 vue 项目内摸爬滚打的萌新，是时候该学习点儿新的技术了，于是在闲暇之余，我拷贝了一份代码，同时研究该如何从“零”开始编写一个 dll 包（该部分以 webpack 的 dllPlugin 作为例子）。 了解文档通篇读完官网的文档，因为知识点比较多，并且没有详细的例子（指“傻瓜式教学式”），因此开发这第三方包的学习成本还是有一些的，特别是 webpack-chain 和 node 的部分知识，这里记录总结了一些关键的点。 插件命名最开始命名文件夹时我并没有使用 vue-cli-plugin- 作为文件名前缀，结果可想而知，vue invoke 一直提示找不到该包的信息。于是我去看了看源码…… 在 @vue/cli/lib/invoke.js 内，其有一个关键的获取包 Id 的方法 resolvePluginId，该方法在 @vue/cli-shared-utils/lib/pluginResolution.js，源码如下： 1234567891011121314151617181920exports.resolvePluginId = id =&gt; &#123; // already full id // e.g. vue-cli-plugin-foo, @vue/cli-plugin-foo, @bar/vue-cli-plugin-foo if (pluginRE.test(id)) &#123; return id &#125; // scoped short // e.g. @vue/foo, @bar/foo if (id.charAt(0) === '@') &#123; const scopeMatch = id.match(scopeRE) if (scopeMatch) &#123; const scope = scopeMatch[0] const shortId = id.replace(scopeRE, '') return `$&#123;scope&#125;$&#123;scope === '@vue/' ? `` : `vue-`&#125;cli-plugin-$&#123;shortId&#125;` &#125; &#125; // default short // e.g. foo return `vue-cli-plugin-$&#123;id&#125;`&#125; 很明显，使用 vue invoke 时其只会寻找含有 vue-cli-plugin- 作为前缀的包，官网内在文档的最后部分有做对应的说明（这个是后来才看到的），原文如下： 为了让一个 CLI 插件能够被其它开发者使用，你必须遵循 vue-cli-plugin-&lt;name&gt; 的命名约定将其发布到 npm 上。 因此 package.json 的 name 字段符合规则即可。 creator 和 service官网开篇就介绍了两个主要的部分：@vue/cli 和 @vue/cli-service，首先是 @vue/cli 部分，这里介绍了插件的目录结构，因此我们可以根据此来搭一个插件框架： 123456789101112vue-cli-plugin-xxx ├── README.md ├── generator | └── index.js ├── index.js ├── package.json ├── prompts | └── index.js ├── service | ├── config-file.js | └── regist-command.js └── yarn.lock 接下来就详细分析一下各部分的作用。 generator文档分析文档中有提到，插件内的 generator 将会在两种场景下被调用： 在一个项目的初始化创建过程中，如果 CLI 插件作为项目创建 preset 的一部分被安装 插件在项目创建好之后通过 vue invoke 独立调用时被安装 由于开发的第三方插件使用场景多数在于更改已安装的项目配置，preset 使用场景不是很多（创建项目时一般还是手动配置，大多数情况不会选择去生成一个 ~/.vuerc），因此这边仅处理使用手动调用 generator 的情况。 触发 generator 的方法有两种： vue invoke vue add 下面就简单介绍一下这两个命令的区别。 vue invoke 指令此指令的适用情况为已经通过 yarn 或者 npm 将包安装至项目内，此时仅需要调用 vue invoke 即可。 注意：这里的 packageName 为不包含 vue-cli-plugin- 部分的剩余包名，比如：发布的包名为 vue-cli-plugin-xxx，那么此时使用命令即 vue invoke xxx vue add此指令的使用情况为项目内还没有安装对应的包，使用方式同 vue invoke 注：如果包的源不对的话，请自己在后面加上包所在的 npm 源地址（ –registry ） 内容编写分析了这么多，重点还是 generator 内我们应该写点什么，它影响的是什么。好了，让我们来继续看文档(● ˃̶͈̀ロ˂̶͈́)੭ꠥ⁾⁾ generator 有三个参数，这里就不细赘了，因为这里不关注 preset 的配置，所以对我们来说，有用的部分就只有第一个参数 api。首先我们需要改动的部分便是项目内的 package.json 了，使用方法 extendPackage 即可，例子如下： 123456789101112131415161718192021222324// 修改 `package.json` 里的字段// vue 部分的内容可以不要module.exports = (api, options, rootOptions) =&gt; &#123; // 修改 `package.json` 里的字段 api.extendPackage(&#123; scripts: &#123; test: &apos;vue-cli-service test&apos; &#125;, vue: &#123; pluginOptions: &#123; test: &#123; // 需要预打包的部分 vendors: [], // 输出文件名 outputName: &apos;vendor.dll.js&apos;, // 输出地址 outputPath: &apos;./public/vendor&apos;, // 是否调用 cleanWebpackPlugin cleanCache: true &#125; &#125; &#125; &#125;);&#125; 关于此处添加的 vue 字段在 invoke 后会自动补充至 vue.config.js 或者 package.json 内。 如果你配置了 promots 并且需要该部分的内容，那么可以使用第二个 options 参数去获取配置的内容。（配置 .vuerc 的方法没有尝试，因为解构 + 默认值 + prompts 已经足够了） 如果需要配置模板方面的参考官方源码，感觉配合 prompts 写个模板插件也不错。 友情提示：render() 函数内为你的 template 模板基于当前文件夹所在的路径。 prompts该部分其实在这个项目内并没有涉及，但还是要提一下。官方文档对于此部分在内建插件有详细的说明（官方插件），第三方插件提到过一点： 这个文件应该导出一个用于 Inquirer.js 的问题的数组。这些被解析的答案对象会作为选项被传递给插件的 generator。 因此，如果需要的情况下，我们得通过数组的形式编写问答。例如： 12345678module.exports = [ &#123; name: 'entry', message: \"What's the output file's name?\", type: 'input', default: 'vendor' &#125;] 此部分的配置结果会在 generator 部分的第二个参数捕捉到。 service这部分就是配置的重点了,还是根据官网来吧，官网有提到 3 个命令： chainWebpack、configureWebpack、registerCommand。直接更改原有项目的配置并不是很好（除非你很有信心），因此我们可以使用 configureWebpack 来合并变更。 这部分总的来说做三件事： 更改用户的 webpack 配置文件（也就是 vue.config.js） 向 cli-service 内注册指令 为注册的指令指定模式 这里从简单的部分开始一一说明吧～（顺序：3、1、2） 指定模式嗯，这个最简单了，毕竟官网文档内有，理由也就不赘述了，代码如下： 123module.exports.defaultModes = &#123; &lt;your direct&gt;: &lt;target mode&gt;&#125; 其中 your direct 部分即先前的 generator 部分注册的 script 脚本内，在 vue-cli-service 后面的那个指，比如，先前写的是 test，那么这里注册的指令也是 direct，mode 就根据实际情况处理即可，一般使用 production 生产模式就没啥问题。 更改用户的配置文件这里就需要有 webpack-chain 的知识了。先看看 pluginAPI 内有些啥（传送门）,可能会用到的一些方法包括： getCwd：获取当前的工作目录 resolve：相当于 path.resolve registerCommand：注册指令（有三个参数！） chainWebpack：链式调用 webpack configureWebpack：用于合并 webpack resolveChainableWebpackConfig：用于解析 webpack 此处我们使用 configureWebpack 来更改配置，同时使用 registerCommand 来注册我们的命令。这里刚好对应的就是我们的两个文件 config-file 和 regist-command.js 了，对应开发即可。 configureWebpack参考源码的写法，我们可以通过 options 参数获取 invoke 生成的 vue.config.js 里面的 pluginOptions 字段内的对应配置内容，配合 api.configureWebpack 来注入我们的 webpack 配置。粗略的写法为： 123456api.configureWebpack(config =&gt; &#123; // 增一个 plugins config.plugins.push( /* plugin 配置 */ )&#125;); registerCommand查看源码的写法，发现参数有三个，分别是： api: pluginAPI 实例 options: 用来添加配置说明 fn: 回调函数，用于触发执行的内容（比如运行一个 webpack 配置） 官方的写法如下，我们可以据此模仿12345678910111213api.registerCommand( \"test\", &#123; description: \"此为指令的说明\", // 指令意义 usage: \"vue-cli-service test\", // 命令怎么用 options: &#123; /* 参数说明 */ &#125; &#125;, async args =&gt; &#123; /* 可以写个 chain-webpack 然后调用，或者干点其它的 */ &#125;); 部分问题总结1. demo 内的 dll 打包位置问题使用默认的打包位置： public/vendor 会产生一个问题，就是 build 文件内会包含此 vendor 文件夹（public 文件夹内的内容默认会带至 dist 文件夹内），我们注入的一些配置不生效。 解决方法：将默认的 public/vendor 打包位置改改，只要不是生成在 public 文件夹内的都没问题，可看 vue-cli 官网的 public 部分的解释。 2. webpack 函数目前第二个回调参数的使用场景不是很明确（其实不用回调也可以，外层关闭对应的 log 即可） 3. configureWebpack 只能用 push?我尝试过自己新创建一个 webpack-chain 然后返回（源码上好像会对返回值进行判断，如果有那么会调用 merge 方法），按理来说返回一个 config.toConfig() 应该 没问题，但是行不通，目前仍然用的是 push 方法 demo传送门 参考文档 插件开发指南 Vue CLI 3使用：插件和 Preset（二） 使用 Webpack-chain 链式生成 webpack 配置 如何使用 vue-cli 3 的 preset 打造基于 git repo 的前端项目模板 vuetify webpack 函数参数 webpack chain 中文文档","categories":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://monocy.site/tags/Webpack/"}]},{"title":"提升项目的构建速度","slug":"提升项目的构建速度","date":"2019-05-08T02:29:11.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/05/08/提升项目的构建速度/","link":"","permalink":"https://monocy.site/2019/05/08/提升项目的构建速度/","excerpt":"前言随着项目的增大，越来越多的插件引入项目，使得项目的构建时间越来越长，而这很影响开发的效率。因此有没有一种方法能够优化构建的内容，提前构建好不怎么改动的插件依赖，而仅仅构建我们所写的业务代码呢？webpack 早已为我们考虑到了这个问题。","text":"前言随着项目的增大，越来越多的插件引入项目，使得项目的构建时间越来越长，而这很影响开发的效率。因此有没有一种方法能够优化构建的内容，提前构建好不怎么改动的插件依赖，而仅仅构建我们所写的业务代码呢？webpack 早已为我们考虑到了这个问题。 DllPlugin简介DllPlugin 的主要思想在于将项目内的一些不经常更改的依赖（比如 lodash）提前打包，使得项目构建时忽略这些打包文件，从而减少构建时间，提升构建速度。 参数与使用1new webpack.DllPlugin(options); 其中 options 含有如下参数： context (optional): manifest 文件中请求的上下文(context)(默认值为 webpack 的上下文(context)) name: 暴露出的 DLL 的函数名 (TemplatePaths: [hash] &amp; [name] ) path: manifest json 文件的绝对路径 (输出文件) DllReferencePlugin简介简而言之，DllReferencePlugin 就是将 DllPlugin 打包的文件获取，在主 webpack 文件配置后，会让其在构建包时忽略掉 DllPlugin 内配置打包的文件，其依赖 DllPlugin 打包出的 manifest 文件。 参数与使用1new webpack.DllReferencePlugin(options); 其中 options 含有如下参数： context: (绝对路径) manifest (或者是内容属性)中请求的上下文 manifest: 包含 content 和 name 的对象，或者在编译时(compilation)的一个用于加载的 JSON manifest 绝对路径 content (optional): 请求到模块 id 的映射 (默认值为 manifest.content) name (optional): dll 暴露的地方的名称 (默认值为 manifest.name) (可参考 externals) scope (optional): dll 中内容的前缀 sourceType (optional): dll 是如何暴露的 (libraryTarget) 注：与 output.library 保持 name 的一致性。 AddAssetHtmlPlugin简介将 dll 拆分的两个 plugin 配置好后，每次构建项目，推送远端之前都需要将我们的 dll 文件的引用动态添加到生成的 html 文件内，此插件就是实现该手动插入的过程 参数与使用123const AddAssetHtmlPlugin = require('add-asset-html-webpack-plugin');new AddAssetHtmlPlugin(options) 我们所关注的 options 配置： filepath: 文件所在的地址，此处配置 dll 构建出的 .js 文件 outputPath: 在构建时，引用的文件最终打包至的位置 publicPath: script 脚本引用该文件时的绝对位置 注：此插件依赖 html-webpack-plugin，由于预构建项目内并不需要生成中间 html 文件，因此我们可以不用像示例那样配置 HtmlWebpackPlugin 来生成 .html 文件 配置示例使用方法初配置好或者依赖的内容有变动（比如：版本升级）使用此命令更新预打包的依赖，否则即使升级了包，最终打包后也不会有任何变化。1yarn dll dllPlugins 部分配置创建一个 webpack.dll.config.js 文件 123456789101112131415161718192021222324252627282930313233343536const path = require('path');const webpack = require('webpack');const CleanWebpackPlugin = require('clean-webpack-plugin');// 配置公共请求路径function resolve(dir) &#123; return path.join(__dirname, dir);&#125;// dll文件存放的目录const dllPath = '&lt;target-file&gt;';module.exports = &#123; mode: 'production', // 需要提取的依赖 entry: &#123; vendor: ['lodash'] &#125;, output: &#123; path: resolve(dllPath), filename: '[name].dll.js', // vendor.dll.js 中暴露出的全局变量名 // 保持与 webpack.DllPlugin 中名称一致 library: '[name]_[hash]' &#125;, plugins: [ // manifest.json 描述动态链接库包含了哪些内容 new webpack.DllPlugin(&#123; path: path.join(__dirname, dllPath, 'manifest.json'), // 保持与 output.library 中名称一致 name: '[name]_[hash]' &#125;), // 清除之前打包的 dll 文件 new CleanWebpackPlugin(&#123;&#125;) ]&#125;; 主 webpack 打包文件配置此处以 vue-cli3 来说明 12345678910111213141516171819const AddAssetHtmlPlugin = require('add-asset-html-webpack-plugin');module.exports = &#123; chainWebpack: config =&gt; &#123; // 设置忽略打包的 vender 文件，添加已打包文件 config.plugin('dll').use(new webpack.DllReferencePlugin(&#123; manifest: require('./vendor/manifest.json') &#125;)); // 将 dll 生成的 vender 自动注入到 html 文件中 config.plugin('insert').use(new AddAssetHtmlPlugin(&#123; // dll文件位置 filepath: path.resolve(__dirname, './vendor/*.js'), // dll 引用 dist 路径 publicPath: 'js', // dll最终打包到的 dist 目录位置 outputPath: 'js' &#125;)); &#125;&#125; package.json 配置123\"scripts\": &#123; \"dll\": \"webpack --progress --config webpack.dll.config.js\"&#125; 参考文档 DllPlugin vue-cli3 DllPlugin 提取公用库 如何十倍提高你的webpack构建效率","categories":[{"name":"Webpack","slug":"webpack","permalink":"https://monocy.site/categories/webpack/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://monocy.site/tags/Webpack/"}]},{"title":"浅谈 BFC","slug":"浅谈-BFC","date":"2019-05-03T11:38:12.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/05/03/浅谈-BFC/","link":"","permalink":"https://monocy.site/2019/05/03/浅谈-BFC/","excerpt":"前言CSS 中除了垂直居中之外，另外一个常见的问题就是 BFC 问题。BFC 全称为 Block Fromatting Context，即“块级格式化上下文”，对于前端开发来说，了解这个还是非常必要的，因为对于 To C 类的产品对于前端 CSS 要求还是挺高的，了解这个能够更为方便的把握住页面的结构层次以及会产生的问题。","text":"前言CSS 中除了垂直居中之外，另外一个常见的问题就是 BFC 问题。BFC 全称为 Block Fromatting Context，即“块级格式化上下文”，对于前端开发来说，了解这个还是非常必要的，因为对于 To C 类的产品对于前端 CSS 要求还是挺高的，了解这个能够更为方便的把握住页面的结构层次以及会产生的问题。 创建 BFC下列方式会创建块格式化上下文（此部分由 MDN 总结）： 根元素或包含根元素的元素 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML 表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML 表格标题默认为该值） 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、row、tbody、thead、tfoot 的默认属性或 inline-table）overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content或 strict 的元素 弹性元素（display 为 flex 或 inline-flex 元素的直接子元素） 网格元素（display 为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1） column-span 为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 很多博客对于 BFC 这部分的知识有很详细的讲解了，但是好记性不如烂笔头对吧，我自己也试着研究了下，BFC 无外乎两个问题：高度塌陷和外边距重叠。 高度塌陷这个现象在使用浮动布局时会时常遇到，用一下代码来说明： 123&lt;div class=\"container\"&gt; &lt;p class=\"float-content\"&gt;This is a float element&lt;/p&gt;&lt;/div&gt; 123456789.container &#123; background-color: bisque; width: 100%;&#125;.float-content &#123; float: left; background-color: antiquewhite; width: 30%;&#125; 由于子元素为浮动元素，脱离了文档流，因此父元素的内容为“空”，因此父元素的高度最终计算为 0。 解决这个的方法也有很多，这里就不做全量总结了，最为推荐的方法为添加伪元素法： 1234567.container::after &#123; content: \"\"; clear: both; display: block; height: 0; visibility: hidden;&#125; 外边距折叠外边距折叠问题用图不是很好描述，这里先简单的用字符画来描述一下（两种情形）。 第一种情形是，当你在一个 div 元素内插入一个块级子元素，然后设置其 margin-top 值，这是你会发现并不是子元素在父元素内撑开了一段距离，而是父元素向上撑开了一段距离。 123456789101112原以为： 实际上：------- body ------- ------- body ------- * --- parent --- | 50px * * | 50px --- parent --- * child child --- parent --- --- parent ---------- body ------- ------- body ------- 另一种情况是，当你在 div 元素内插入多个块级元素，你给其中相邻的两个设置 margin-top 和 margin-bottom ，你会发现，他们之间的距离为相对应的 margin-top 和 margin-bottom 中的最大值，当设置第一个块级元素的 margin-top 属性则会像第一种情形那样，父级框移动了。 1234567891011121314151617181920212223242526原以为：-------- parent ----------- | 10px childA 10px | | ===&gt; 30px 20px | childB | 20px |-------- parent ----------实际上：-------- body --------- | 10px ---- parent ---- childA | | max(10px, 20px) ==&gt; 20px childB ---- parent ---- | | 20px-------- body --------- 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 这里有个比较通俗易懂的例子： 第一种情形A 与 B 并排站，A 说：我站在距离前方 1m 的地方，接下来该你站位子了。由于 A 与 B 之间没有明显的分割线，B 想了想没有动，说到：我现在和你在一条线上，那么我也应该站在距离前方 1m 的地方吧！ 第二种情形A 与 B 相对站，A 说：我站在距离你 1m 的地方，该你了。B 说：我应该站在距离你 2m 的地方，通过相对原理，我们应该间隔 2m 吧~ 从例子可以分析出，只要给予一个界限，即两者不是互相比对，基于某一个定点来决定位置，也就是我们说的形成 BFC 了 奇怪的布局当在 div 元素内插入多个行内块级元素，你给其中任意一个或者多个设置 margin-top 想要使得它/它们表现得与众不同，可是，到头来所有元素都会移动，而且唯一准确的只有所设值最大的那个子元素，其他子元素则混淆。 12345678910111213141516（注：所有子元素高度为 height: 100px）原以为： parent---------------------------------------------------- | 50px childB | 25px childA childC---------------------------------------------------- parent实际上： parent---------------------------------------------------- | 50px | 50px + 25px | 50px - 25px childA childB childC---------------------------------------------------- parent 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;CSS外边距塌陷&lt;/title&gt;&lt;/head&gt;&lt;style type=\"text/css\"&gt; .parent &#123; background-color: black; height: 500px; overflow: hidden; width: 500px; &#125; .parent div &#123; display: inline-block; /*包含了 wrapper */ &#125; .childA &#123; background-color: greenyellow; height: 100px; margin: 50px 0; width: 100px; &#125; .childB &#123; background-color: aliceblue; height: 100px; width: 100px; &#125; .childC &#123; background-color: orangered; height: 100px; margin: 25px 0; width: 100px; &#125; /* 此为解决办法 */ /* .wrapper &#123; height: 100%; overflow: hidden; &#125; */&lt;/style&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"childA\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"childB\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"childC\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 提示点： 默认对齐方式：基线对齐 空元素的基线位置：底部 block 元素的 inline 内容默认位置：block 元素的顶部 盒子的默认类型： content-box 可基于此 4 点，结合代码看页面呈现效果，应该提示的很清晰了，脑补一下即可~ 参考文档 W3C MDN 盒模型 BFC 神奇背后的原理 什么是BFC、IFC、GFC和FFC 从概念到业务来看 To B 和 To C 产品区别在哪 附录此篇同样为原写的文章的一次改版，更新原有的错误，记录新的体会！","categories":[{"name":"CSS","slug":"CSS","permalink":"https://monocy.site/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://monocy.site/tags/CSS/"}]},{"title":"水平垂直居中","slug":"水平垂直居中","date":"2019-04-27T05:34:53.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/04/27/水平垂直居中/","link":"","permalink":"https://monocy.site/2019/04/27/水平垂直居中/","excerpt":"前言在面试中，面试官考察 CSS 方面的内容时，比较常见的一个问题就是水平垂直居中问题。其实不仅仅是面是，在工作中也常常会遇到这样的布局，因此对于一些常见的水平垂直居中的方法，在此做了一番总结，以作备忘。","text":"前言在面试中，面试官考察 CSS 方面的内容时，比较常见的一个问题就是水平垂直居中问题。其实不仅仅是面是，在工作中也常常会遇到这样的布局，因此对于一些常见的水平垂直居中的方法，在此做了一番总结，以作备忘。 块级元素的水平垂直居中定位对于块级元素的垂直居中定位，我们处理的方法有很多，就以下公共模板做讨论： 123&lt;div class=\"parent parent-special\"&gt; &lt;div class=\"child child-common\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.parent &#123; background-color: black; position: relative; height: 400px; width: 400px;&#125;.parent-special &#123;&#125;.child &#123;&#125;.child-common &#123; background-color: red;&#125; position + margin定位配合 margin 来实现的方法比较简单粗暴，由于子元素有定宽定高的限制，因此适用于一些简单的布局，比如弹框之类的（这里仅讨论绝对定位）。 12345678.child &#123; height: 100px; width: 100px; position: absolute; left: 50%; top: 50%; margin: -50px 0 0 -50px;&#125; position + transform前面的方法对于子元素大小固定的情况可以适用，但是对于子元素大小不固定的情况却没法处理，好在 CSS3 的新属性 transform 能帮我们解决这个问题 12345678.child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); height: 30%; width: 30%;&#125; 注：虽然 transform 能解决问题，但是当 width 和 height 百分比计算后的值为非偶数时，通过 translate 补正会造成页面字体模糊以及抖动问题（抖动可用 3d 校正，模糊无解），因此这个得视情况使用。 table-cell回顾比较”久远”的解决方法那就是传统的 table-cell 布局了，父级的 display 属性为 table，子元素设置为 table-cell，配合 vertical-align，就能实现垂直居中，不过此处的居中偏向于行内元素。 12345678910.parent-special &#123; display: table; /* 为了表现得更鲜明一点 */ padding: 30px;&#125;.child &#123; display: table-cell; vertical-align: middle;&#125; 注： 这种情况比较适合于子元素内容呈现形式为为行内的情况，子元素此时会占满整个父元素。 margin: auto我们知道 margin: auto 会自动补充左右两侧的内容，如果能够实现自动补充上下两端的内容那不就能够实现垂直居中了么！因此我们通过定位来“提示”自动补全。 12345678910.child &#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; height: 30%; width: 30%;&#125; 然而这种写法会让子元素撑满整个父级，适用于仅包含一个元素的情况；如果只想要垂直居中（子元素的上下 margin 会被填满），那么可以这么修改： 12345678910.child &#123; position: absolute; top: 0; bottom: 0; margin: auto 0; height: 30%; width: 30%; /* 取其一 */ left/right: 0;&#125; flexflex 属性就不做过多说明，这个很好理解，阮一峰的博客有很详细的实例，我就不赘述了（grid 可类比）。 12345678910.parent-special &#123; display: flex; justify-content: center; align-items: center;&#125;.child &#123; height: 30%; width: 30%;&#125; 行内元素的垂直居中定位行内元素的垂直居中面试中不是特别常见（水平居中谁都会，此处 pass），但工作中还是遇到不少，先前的《浅谈行内元素》一文中也有简单介绍，此处以以下公共模板做讨论： 1&lt;span class=\"inline\"&gt;行内元素内容&lt;/span&gt; line-height + font-size + vertical-align此为在不改变行内元素属性的情况下，通用的居中方式 12345.inline &#123; font-size: 12px; line-height: 20px; vertical-align: middle;&#125; 注，当该行内元素有同级的行内元素位于其左右时， vertical-align 需统一一下，因为默认的值为 baseline inline-block + 伪元素另外比较“骚气”的处理方法就是改变盒子的 display 状态，然后给予一个定位的中心点（默认没有的），以此中心点来影响其余的匿名行盒子的定位。 123456789101112.inline &#123; height: 100px; display: inline-block; vertical-align: middle;&#125;.inline::before &#123; height: 100%; content: \"\"; display: inline-block; vertical-align: middle;&#125; 注：此方法可行是可行，但是浏览器在渲染空节点时，仍然会占一个空格，也就是说，水平居中总会差那么一点点，如果不是特别挑剔那么就没什么大问题。 参考文章 Flex 布局语法篇 Flex 布局实例篇 一些面试时关于 CSS 的问题 附录本篇为我的 segmentfault 中的文章的一部分，因为刚好温故 CSS 时又看到了布局这部分内容，因此再总结一次，记录下一些新的收获，同时修改一下当时学习记录的一些错误点。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://monocy.site/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://monocy.site/tags/CSS/"}]},{"title":"浅谈行内元素","slug":"浅谈行内元素","date":"2019-04-18T10:11:34.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/04/18/浅谈行内元素/","link":"","permalink":"https://monocy.site/2019/04/18/浅谈行内元素/","excerpt":"前言最近在工作中遇到很多奇怪的样式错位问题，解决问题之余，有重新温习了一下样式方面的知识。一般块级元素的问题都比较好解决，而行内元素的问题还总是得试试，可能是理解的不够透彻，因此此篇算是我对行内元素做的一个简短的笔记吧。","text":"前言最近在工作中遇到很多奇怪的样式错位问题，解决问题之余，有重新温习了一下样式方面的知识。一般块级元素的问题都比较好解决，而行内元素的问题还总是得试试，可能是理解的不够透彻，因此此篇算是我对行内元素做的一个简短的笔记吧。 基础知识什么是行内元素行内元素，顾名思义，就是指在在一行内不换行的元素。通俗来讲，行内元素相当于“句子”，其内可以包含数据与其它行内元素。 一个行内元素只占据它对应标签的边框所包含的空间。MDN —— 行内元素 常见的行内元素 b, big, i, small, tt abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var a, bdo, br, img, map, object, q, script, span, sub, sup button, input, label, select, textarea 行盒子与浮动文字环绕特效word 文档内有“文字环绕”一表格属性，能够实现图片周围环绕文字，例如： 当然，上图是 html 实现的，实现方法也很简单，代码如下（例 1-1）： 1234&lt;figure class=\"test-figure\"&gt; &lt;img class=\"test-img\" src=\"./cat.jpg\" alt=\"\"&gt; &lt;span&gt;Lorem, ipsum dolor sit amet consectetur adipisicing elit. Alias, dolore qui obcaecati fuga ratione nobis dolor veniam soluta sequi rem voluptatem quo similique quis doloribus fugit autem! Quas, ipsum reiciendis?&lt;/span&gt;&lt;/figure&gt; 1234567.test-figure &#123; width: 300px;&#125;.test-img &#123; width: 100px; float: left;&#125; 文字环绕原理代码很简单，实现难度也不大，但是为什么这么写能够实现呢？它实现的原理又是什么呢？ 其实，在我们所知的盒子模型中，除了基础的块级盒子和行内盒子，我们还有一个比较隐秘的匿名盒子。参考一个例子（例 1-2）： 1234&lt;p&gt; 我在块级盒子的匿名行内盒中 &lt;span&gt;我在行内盒子的匿名行内盒中&lt;/span&gt;&lt;/p&gt; 回忆一下 CSS 选择器，其中有两个用的不是很多的伪元素选择器：::first-letter、::first-line，在此例中，它们选中的其实就是盒子模型中的匿名盒子的内容。那这个和我们所说的“文字环绕”又有什么关系呢？ 我们知道，浮动会让元素脱离文档流，因此它不会再向非浮动元素影响其它元素的布局，因此在例 1-1 中，我们的 img 标签已经脱离了文档流，span 标签 此时在层级上会置于其下，如图： 但是！float 元素内的内容，也就是 img 的内容，它并不会跟随 img 标签一起浮动，而是仍然会存在于正常的文档流中，同时也会记住 img 标签的大小，因此在后面的匿名行盒子（span 中的）在计算其应该所在的位置时，会给 float 元素留出它所需要的空间，也就出现了“文字环绕”的样式。 常用伪元素： ::before、::after 知识拓展因为浮动并不算是完全脱离文档流，因此在开发中还会出现不少 bug，比如：“高度塌陷”，在处理这类问题时，我们经常用到的方法是 clear: both; ，例如（例 1-3）： 12345&lt;!-- 这里就用类名表示相应效果 --&gt;&lt;div&gt; &lt;p class=\"float\"&gt;&lt;/p&gt; &lt;div class=\"clear-both\"&gt;&lt;/div&gt;&lt;/div&gt; 但是浏览器在对这做处理时，会为浮动元素留下足够大的空间，也就是给我们的元素加隐性的 padding，从而实现换行的效果（注意： span 标签不生效，display: block 才生效）。 行内元素的排版行盒子的构造处理行内元素时，比较令人头疼的就是它们的对齐方式了。虽然对应的知识都比较了解，在项目中遇到多个行内元素没有对齐时，稍微多几次尝试基本上也能够搞定对齐，万一实在弄不定，一个 flex 布局基本能解决所有的痛苦。但是，仅仅这样也就止步于此了，不明白的点最终也弄不明白，因此，我稍微花了些时间去了解了一下行盒子到底是什么东西。 此处引用《精通 CSS，高级 Web 解决方案》里面的一张图： 这里将行内格式化模型描述很清晰。由于行内盒子不能显示的设置高度，因此决定行内元素的高度那就剩下：内容高度。而影响内容高度的有两属性，分别是： line-height 与 font-size（当然 font-family 也会有一定影响）。 行盒子的行高计算方法是：行盒子的整体高度减去font-size，剩余的值再平均分成两份，也就是图内的“半铅空”。例如： 1234.inline-box &#123; line-height: 28px; font-size: 12px;&#125; 那么“半铅空”为 8px。加入 line-height 值为数字，如： line-height: 1.5，则表明当前 line-height 为当前 font-size 的 1.5 倍，计算方法不变。 因此在编写样式时，如果发现和设计稿不一致的情况时，若是行内元素，那么就可以考虑下是否是行高造成的问题了。 行内元素的对齐方式除了 line-height 之外，影响行内元素对齐的属性那就是 vertical-align 了。它的默认对齐属性值为 baseline。除了 baseline 之外，其实还有很多对齐方式，如： middle, text-top, bottom 等等（更多的可参阅 MDN），举个例子： 1234567&lt;style&gt; span &#123; vertical-align: \"middle\" &#125;&lt;/style&gt;&lt;span&gt;This is a paragraph, and this is a &lt;em&gt;special&lt;/em&gt; word.&lt;/span&gt; 行内元素对齐比较常见的问题在于图片的对齐，一般的行内元素对齐要么令其行高一致，要么 vertical-align 统一配置同一值即可，但是图片比较特殊，对齐大概分为这么几种： top、text-top middle baseline bottom、text-bottom、sub 除了 middle 之外，其余的对齐方式会以图片的顶部或者底部来与其余行内元素对齐，因此设置图片对齐方式一般用 vertical-align: middle；又因为默认的行内元素对齐方式为 vertical-align: baseline，因此会出现图片与行内元素无法对齐的情况，了解清楚了这一点那么问题就很好解决了，即：统一行内元素的 vertical-align 的对齐方式为 middle 即可。 注：line-height 设置后会影响 top、bottom 位置，全部保留原来的不变则效果一样，详见 MDN 参考文档 MDN 行内元素 匿名行内盒 浮动定位: float 属性 伪类与伪元素 MDN vertical-align","categories":[{"name":"CSS","slug":"CSS","permalink":"https://monocy.site/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://monocy.site/tags/CSS/"}]},{"title":"发布一个 vue 包","slug":"发布一个-vue-包","date":"2019-04-14T02:24:49.000Z","updated":"2020-08-21T03:36:39.318Z","comments":true,"path":"2019/04/14/发布一个-vue-包/","link":"","permalink":"https://monocy.site/2019/04/14/发布一个-vue-包/","excerpt":"前言文章用来纪录我如何从零开始，通过 webpack4 发布一个 vue 的 npm 包，同时使用的是 es6 语法。涉及到的知识点包括： webpack4 npm 包的发布 babel 配置 vue 配置","text":"前言文章用来纪录我如何从零开始，通过 webpack4 发布一个 vue 的 npm 包，同时使用的是 es6 语法。涉及到的知识点包括： webpack4 npm 包的发布 babel 配置 vue 配置 准备工作了解相关知识首先需要了解相关基础知识，由简单到难，依次列举如下： 如何发布一个 npm 包，需要准备些什么？ webpack 简单的打包配置需要哪些 如何配置 babel 的 es6 支持 如何配置 vue 的支持 如何配置 vue 的 @、@src 等引用 包内的 vue 的组件该如何编写 如何优化打包的体积 发包前的准备创建账号发布 npm 包首先需要一个 npm 账号。npm 添加账号的方法： 12345npm adduser## 之后会提示你输入 userName 和 password## ...## 保存后登陆npm login 创建待发布的包创建包的方法也十分简单，此处用 yarn 来创建一个 npm 包 123# 首先进入对应文件夹，然后yarn init# 之后根据提示输入项目名称、版本等内容即可 规范化 package.json 内容当然，要发布一个比较规范的包，仅默认的一些配置还是不够的，package.json 的详细配置可见「中文文档」，总结过后，我们可以配置这么一些字段： name: 项目名称 version: 当前包的版本 keywords: 关键词，方便搜索 description: 项目描述 repository: 项目地址 author: 作者 contributors: 项目开发人员 files: 项目包括的文件 scripts: webpack 打包会用到 style: 项目样式所存放的地址 license: 许可证（一般 MIT 即可） 安装时常用的有此三种依赖： dependencies: 必须依赖的包，会在用户安装此包时，将该部分的包一并装上，会更新版本（如果版本过低） peerDependencies: 会在用户安装此包时，如果该模块内的包没有或者用户安装的对应包版本过低，会用 warning 提示用户安装（不会自动安装） devDependencies: 开发时会用到的包，打包至项目的或者 webpack 配置需要的等等，不会帮用户安装或者给予提示 它们依次对应的指令是： 12345678# dependenciesyarn add xxx# peerDependenciesyarn add xxx -P# devDependenciesyarn add xxx -D 初始化包的配置两种安装方式 12345# 全局安装npm i -g webpack webpack-cli# 项目安装yarn add webpack webpack-cli -D 在先前创建的项目内新建一个 webpack.config.js 文件，并写入以下基础内容 12345678910const path = require('path');// 处理路径function resolve(dir) &#123; return path.join(__dirname, dir);&#125;module.exports = &#123; mode: 'production'&#125; 注：webpack4 版本这两个是分开的，都得装 配置 webpack出入口文件配置1234567891011121314// 在 module.exports 文件内添加 entry 和 output 两字段module.exports = &#123; // ... entry: &#123; &lt;自定义名&gt;: &lt;文件地址&gt; &#125;, output: &#123; path: &lt;输出地址&gt;, publicPath: &lt;虚拟路径，server 路径有关&gt;, filename: &lt;输出的文件名&gt;, library: &lt;包名&gt;, libraryTarget: &lt;库的支持，一般用 umd 即可&gt;, &#125;&#125; 12345678910111213// 例子module.exports = &#123; entry: &#123; 'test': './src/index.js' &#125;, output: &#123; path: resolve('lib'), publicPath: '/lib/', filename: '[name].js', library: 'test', libraryTarget: 'umd' &#125;,&#125; loader 配置vue-loader由于项目是关于 vue 的，因此可参考「vue-loader 官网」，跟着对应内容配置即可，解析 vue 的 loader 配置 1234567891011121314151617181920212223// rules 部分&#123; test: /\\.vue$/, loader: 'vue-loader'&#125;// plugins 部分plugins: [ new VueLoaderPlugin()]// resolve 部分resolve: &#123; // 设置别名 alias: &#123; vue$: 'vue/dist/vue.esm.js', '@': resolve('./src'), '@mixins': resolve('./src/mixins'), '@base': resolve('./src/base'), &#125;, // 文件后缀扩展识别（导入时自动加后缀） extensions: ['*', '.js', '.vue']&#125;, es6 支持首先在 webpack 配置文件的 rules 部分(vue-loader 配置的部分)添加 js 的语法转译 123456789// ...rules: [ &#123; test: /\\.js$/, loader: 'babel-loader', include: [resolve('src')], exclude: [resolve('node_modules')] &#125;] 然后在项目内添加 .babelrc 文件，并在内部添加 es 支持 1234&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; 此处使用的是最新版本的 babel 配置，官网有详细的讲解 @babel/preset-env @babel/plugin-transform-runtime 需要安装的一些依赖： 123456789// devDependencies 部分\"@babel/core\": \"^7.4.3\",\"@babel/plugin-transform-runtime\": \"^7.4.3\",\"@babel/preset-env\": \"^7.4.3\",\"babel-core\": \"^7.0.0-bridge.0\",\"babel-loader\": \"^7.1.2\"// dependencies 部分\"@babel/runtime\": \"^7.4.3\" 注意： babel-core 默认安装的是 6.x 版本，装 7 版本的命令是： yarn add babel-core@^7.0.0-bridge.0 -D css 样式支持由于 vue 项目中用的较多的是 less 或者是 sass，因此打包时需要对样式进行转译，此时需要样式相关的 loader。webpack 的配置例子如下： 1234567891011121314151617181920// rules 部分&#123; test: /\\.(le|sc|sa|c)ss$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'less-loader' ], include: [ resolve('src') ]&#125;// plugins 部分plugins: [ // 提取 CSS 至单一文件夹 new MiniCssExtractPlugin(&#123; filename: 'css/[name].[hash].css', chunkFilename: '[id].[hash].css', &#125;)] 这里注意到最顶部配置的不是 style-loader/vue-style-loader，当我们使用的是开发环境即：&quot;mode&quot;: &quot;development&quot; 时，使用 style-loader/vue-style-loader，当使用生产环境即：&quot;mode&quot;: &quot;production&quot; 时，我们使用此处的配置，以达到最小化压缩 其余资源支持参考官方文档总结的配置如下： 1234567891011&#123; test: /\\.(png|jpeg|jpg|gif|svg)$/i, loader: 'url-loader', options: &#123; limit: 8192, fallback: 'file-loader', name: '[name].[ext]?[hash]', outputPath: 'images/', publicPath: '' &#125;&#125; url-loader 转为 base64 格式，对于小文件类型用这种方法处理更优，但是大文件最好还是用 file-loader 处理，因此对此 loader 设定一个限制，大于阈值 8K 的自动用 file-loader 处理 文档传送门 optimization 配置此部分是最后对文件进行压缩优化一下体积，webpack4 中生产环节相对较好的 devtool 模式是 cheap-module-source-map，但是压缩出的文件内会包含 source-map，如果想将其去掉需要额外的一些配置。webpack 配置例子： 123456789101112optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; uglifyOptions: &#123; // 最快压缩模式 compress: false, mangle: true &#125; &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;) ],&#125; 此处使用的是 UglifyJsPlugin 压缩 js 代码，删除 map 部分的内容， OptimizeCssAssetsPlugin 则是压缩 CSS 部分的内容，具体配置可参考对应的 npm 插件文档 uglify 部分 css 部分 注：css 部分有推荐配合使用 cssnano，因为本项目 css 内容就 2 属性，因此不做过多的配置了，有需要的可查阅相关知识配置即可 附带的配置 clean-webpack-plugin: 放在 plugins 的最后面，可每次自动清除对应的生成文件 webpack-bundle-analyzer: 对压缩的文件的依赖树的可视化分析，方便分析是否有多余依赖 vue 的配置发布一个 vue 组件时需要为组件添加 install 方法，每个组件的文件目录树大致为 1234fileName |-- index.js |-- src | -- component 这是一个组件的文件结构，其中的 component 就是我们的 vue 组件，index.js 为向外侧暴露该组件的一个入口文件，其内容基本格式一致，例如： 12345678import myComponent from './src/component';// 添加单独引用的 install 方法myComponent.install = function(Vue, options = &#123;&#125;) &#123; Vue.component(myComponent.name, myComponent);&#125;;export default myComponent; 整体的配置可以参考 elementUI 的组件写法，原理一样，本质是如何添加 install 方法 开发时的一些疑问关于 devtool 的选用开发环境推荐： cheap-module-eval-source-map 生产环境推荐：cheap-module-source-map 理由： 大部分情况我们调试并不关心列信息，而且就算 sourcemap 没有列，有些浏览器引擎（例如 v8） 也会给出列信息，所以我们使用 cheap 模式可以大幅提高 souremap 生成的效率 使用 module 可支持 babel 这种预编译工具（在 webpack 里做为 loader 使用） 使用 eval 方式可大幅提高持续构建效率，参考 webapck devtool 速度对比列表，这对经常需要边改边调的前端开发而言非常重要 直接将 sourceMap 放入打包后的文件，会明显增大文件的大小，不利于静态文件的快速加载；而外联 .map 时，.map 文件只会在 F12 开启时进行下载（ sourceMap 主要服务于调试），故推荐使用外联 .map 的形式 升级 babel 的问题依照官方文档的介绍，安装了 @babel/core 等插件，并更新了 .babelrc 的配置，但是 build 的时候报错表示 babel-core 版本过低（直接 yarn add babel-core 装的是 6.x 版本），需要 7.0.0.0 版本，因此需要更新 babel-core 1yarn add babel-core@^7.0.0-bridge.0 -D 本地调试包一般通过 yarn link 来调试编写的包，但是除此之外还有另外一个方法，通过相对路径来安装对应的包 1\"target-file\": \"file:&lt;relative-path&gt;\" 但是缺点是，每次更新后都需要删除后重新安装此包，或者将包升级一下版本，然后再次安装才能调试，比较麻烦。 最好的配置方法还是通过 yarn link 来调试。 按需引入比解构引入打包的体积要大？分析了一下打包后的代码，就用以下的例子来解释 1234// 按需import debouce from 'lodash/debounce'// 解构import &#123; debounce &#125; from 'lodash'; 通过 webpack-bundle-analyzer 分析打包后的内容，发现前者有 lodash 的模块，后者没有，后者没有的原因时在压缩的代码内有 require(&#39;lodash&#39;) 即，我们需要配置 package.json 的 lodash 的 dependencies 依赖，需要引用此包的项目有对 lodash 的依赖，也就是说，解构获取的 debouce 不会将对应的内容连同代码一起打包，而是需要用户安装对应的包的依赖，因此体积相对会变小。 为什么要用 library？使用 umd 是为了兼容 commonjs 和 amd 的方式，一般发包用 umd 可保证不会出啥问题，兼容性也很棒，而使用 umd 则需要配置 library。 path 和 publicPath一般我们配置好 path 其实就能万事大吉了，那 publicPath 究竟有什么用呢？其实简单理解， path 至当前的项目的根目录（本地），publicPath 指的是服务器的根目录（服务器）,比如：将资源放在 CDN 上时，把 publicPath 设置为 CDN 的值就行了。 参考文档 webpack devtool配置对比 webpack 文档 webpack 配置详情文档 webpack externals详解 webpack 配置 publicPath的理解 babel 文档 babel-bridge vue-loader 附录完整样例","categories":[{"name":"Webpack","slug":"webpack","permalink":"https://monocy.site/categories/webpack/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://monocy.site/tags/Webpack/"}]},{"title":"node 环境配置（windows）","slug":"windows-node-环境配置","date":"2019-04-06T04:24:35.000Z","updated":"2020-08-21T03:32:09.940Z","comments":true,"path":"2019/04/06/windows-node-环境配置/","link":"","permalink":"https://monocy.site/2019/04/06/windows-node-环境配置/","excerpt":"前言window 上安装 node，其默认的包安装地址在 C 盘，然而从长期来看这并不是很好（如果你 C 盘特别大就当我没说），因此写此篇用于记录 windows 上 node 部分的安装配置，以便今后的查阅。","text":"前言window 上安装 node，其默认的包安装地址在 C 盘，然而从长期来看这并不是很好（如果你 C 盘特别大就当我没说），因此写此篇用于记录 windows 上 node 部分的安装配置，以便今后的查阅。 环境配置下载安装 nodenode 下载地址 注： 除配置目录外，其余一直点击 next 即可 设置 cache 和 global 安装位置在安装 node 的文件夹内添加 node_cache 和 node_modules 两个空文件夹，分别表示 cache 的存储和全局 npm 包的存储地址，然后在 cmd 中输入以下指令： 123# &lt;your file path&gt; 替换成 node 安装的地址npm config set prefix \"&lt;your file path&gt;\"npm config set cache \"&lt;your file path&gt;\\node_cache\" 之后所有的安装包都会在安装 Node 的文件夹下的 node_modules 文件内了。 设置系统环境变量（右击）我的电脑 -&gt; 属性 -&gt; 高级系统环境 -&gt; 环境变量 -&gt; 选择系统环境的 Path -&gt; 配置 Node 的安装地址 附：在命令行中输入 npm list -g --depth=0 会提示当前的 npm 包的安装地址 安装 npm 包nrmnrm 是更换源的包 123npm i -g nrm# 使用 taobao 源nrm use taobao nvmnvm 是更换 node 版本的包，可自行更改当前 node 版本 1npm i -g nvm yarn包管理工具，在项目中使用比 npm 更为方便且更快 1npm i -g yarn 系统变量和用户变量网上有很多都是在系统环境中先声明一个 NODE_ENV 的变量，然后在用户环境中在配置 npm 包的位置，其区别是： 系统环境：对全部用户起作用 用户环境：仅对当前用户起作用 如果 windows 需要配置多用户的话可以根据情况适当配置，但是如果仅仅个人使用的话配一个全局的环境变量即可，无需根据当前用户做适当配置。","categories":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/categories/环境/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://monocy.site/tags/Node/"}]},{"title":"git 环境配置","slug":"git-环境配置","date":"2019-03-31T05:01:22.000Z","updated":"2020-08-16T09:34:09.000Z","comments":true,"path":"2019/03/31/git-环境配置/","link":"","permalink":"https://monocy.site/2019/03/31/git-环境配置/","excerpt":"前言git 的环境安装已经有很多次了，虽然简单，但是文章的重点却并不在此，此篇是用来记录学习 git 的一些好的规范、方便的工具、常用的命令以及遇到的坑。","text":"前言git 的环境安装已经有很多次了，虽然简单，但是文章的重点却并不在此，此篇是用来记录学习 git 的一些好的规范、方便的工具、常用的命令以及遇到的坑。 环境配置下载安装 gitgit 下载地址 git 环境配置1234# 设置用户名git config --global user.name \"yourname\"# 设置邮箱git config --global user.email \"youremail@example.com\" git commit 规范用于说明 commit 的类型只允许一下 7 种： feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 git 常用命令 git 使用的一些问题总结如何取消文件跟踪.gitignore 文件会忽略其中记录的文件，不对其进行状态跟踪，但是对于已经跟踪的文件（即先前未添加至该文件内，后期再加入的）即使之后将其加入此 .gitignore 文件也不生效。 原因： git 缓存使其继续追踪 解决方法：12345## 单文件git rm --cache &lt;fileName&gt;## 全部git rm --cache . 本地远程 tag 版本冲突问题当自己打的 tag 标签与远程 tag 标签不同步时，无法正常使用 git pull –tags，此会报错提示 xxx 版本的 tag 本地与远程不统一，此 tag 拒绝被拉取覆盖（不影响其余的 tag），这回造成 VSCode 编辑器的 git 插件无法正常使用。 解决方法：1234git pull --tags -p -f## 补充本次仅做了强制本地覆盖并合并 tagsgit fetch --tags -h 有对应的指令详细说明 git 学习推荐 可视化学习 git 相关引用 git 命令图片源自 https://github.com/DickyQie/Tool-use","categories":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/categories/环境/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://monocy.site/tags/Git/"}]},{"title":"博客搭建","slug":"博客搭建","date":"2019-03-31T03:35:41.000Z","updated":"2020-08-17T15:03:55.002Z","comments":true,"path":"2019/03/31/博客搭建/","link":"","permalink":"https://monocy.site/2019/03/31/博客搭建/","excerpt":"前言最近想着使用 github.io 来存放个人博客，因此参考一些博客搭建的文章，我也照着搭建了一个，这里记录一些搭建的配置，以便于主题替换升级时的参考。","text":"前言最近想着使用 github.io 来存放个人博客，因此参考一些博客搭建的文章，我也照着搭建了一个，这里记录一些搭建的配置，以便于主题替换升级时的参考。 需要的环境 个人的 github 账号 系统环境 git（需要 sshkey 绑定关联 github） node &amp; npm（需全局安装 hexo-cli） vscode 生成 ssh 命令： ssh-keygen -t rsa -C &quot;邮箱地址&quot; 博客配置 这里分为两部分的配置，一部分为 hexo init 生成项目时的根目录里的 config.yml，这里描述为“用户信息”；另外一个是安装了 hexo 主题时，theme/next 文件夹内的 config.yml，这里描述为“主题信息”。 用户信息配置网站配置配置中文和中国时区 123# Sitelanguage: zh-CNtimezone: Asia/Shanghai 关联 Github发布地址关联，需要在 github 中创建 github.io 仓库 1234deploy: type: git repository: git@github.com:githubName/githubName.github.io.git branch: master 主题选用这里选用的是 hexo-theme-next 主题 1234# 进入博客项目创建 theme 文件mkdir themes# 拷贝主题git clone https://github.com/theme-next/hexo-theme-next themes/next 之后修改主题 1theme: next 所有主题仓库传送门 字数统计安装插件 1yarn add hexo-symbols-count-time 用户信息添加如下配置： 12345678# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: symbols: true time: true total_symbols: true total_time: true exclude_codeblock: true 注：需要清空缓存重启：hexo clean &amp; hexo g &amp; hexo s 主题信息配置页面样式1234567# schema 更改选中值scheme: Gemini## next 插件扩展vendors:# ...# Some contents... 注： plugin 得自己添加，theme-config 中的插件添加参考 https://theme-next.org/docs/getting-started/ 菜单扩展123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive schedule: /schedule/ || calendar sitemap: /sitemap.xml || sitemap # commonweal: /404/ || heartbeat 注意：将未启用的启用需要先创建对应的文件夹，例如： 1234hexo new page \"about\"## 此会在 source 文件夹内创建一个 about 文件夹，默认有一个 index.md## 修改此 index.md，在顶部的 data 下面新增一行 type: \"about\"## 其余的可类比 注：type 与文件夹保持一致，about、categories、tags 需要 type tag 云添加背景色更改 tag 云配置 12345678# TagCloud settings for tags page.tagcloud: # All values below are same as default, change them by yourself. min: 14 # Minimun font size in px max: 14 # Maxium font size in px start: \"#fff\" # Start color (hex, rgba, hsla or color keywords) end: \"#fff\" # End color (hex, rgba, hsla or color keywords) amount: 200 # Amount of tags, change it if you have more than 200 tags 在 theme/next/layout 文件夹中添加文件 tag-color.swig，并输入一下内容： 123456789101112131415161718192021222324252627282930313233&lt;script type=\"text/javascript\"&gt; var alltags = document.getElementsByClassName('tag-cloud-tags'); var tags = alltags[0].getElementsByTagName('a'); var lastPos = tags.length - 1; for (var i = lastPos; i &gt;= 0; i--) &#123; var r = Math.floor(Math.random()*75+130); var g = Math.floor(Math.random()*75+100); var b = Math.floor(Math.random()*75+80); tags[i].style.background = \"rgb(\"+r+\",\"+g+\",\"+b+\")\"; &#125;&lt;/script&gt;&lt;style&gt; .tag-cloud-tags &#123; font-family: Helvetica, Tahoma, Arial; text-align: center; counter-reset: tags; &#125; .tag-cloud-tags a &#123; border-radius: 6px; padding-right: 5px; padding-left: 5px; margin: 8px 5px 0px 0px; &#125; .tag-cloud-tags a:hover &#123; border: none; box-shadow: 0px 5px 15px 0px rgba(0,0,0,.4); transform: scale(1.1); /*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*/ transition-duration: 0.15s; &#125;&lt;/style&gt; 然后修改同级文件 page.swig，找到 class=&quot;tag-cloud&quot;，将该部分底部引入改配置文件 12345678910111213141516&lt;div class=\"tag-cloud\"&gt; &lt;div class=\"tag-cloud-title\"&gt; &#123;&#123; _p('counter.tag_cloud', site.tags.length) &#125;&#125; &lt;/div&gt; &lt;div class=\"tag-cloud-tags\"&gt; &#123;&#123; tagcloud(&#123; min_font : theme.tagcloud.min, max_font : theme.tagcloud.max, amount : theme.tagcloud.amount, color : true, start_color: theme.tagcloud.start, end_color : theme.tagcloud.end&#125;) &#125;&#125; &lt;/div&gt; &#123;% include 'tag-color.swig' %&#125;&lt;/div&gt; 其它扩展官网以有详细的配置，详见 next-theme 官网配置，传送门 文档 hexo 官网 next-theme Counter 配置 Hexo-Next 主题博客个性化配置超详细，超全面(两万字) 为Hexo添加Gitalk评论插件 解决配置gitalk插件后初始化登录时跳转回首页","categories":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/categories/环境/"}],"tags":[{"name":"Env","slug":"环境","permalink":"https://monocy.site/tags/环境/"}]}],"categories":[{"name":"Node","slug":"Node","permalink":"https://monocy.site/categories/Node/"},{"name":"Markdown","slug":"Markdown","permalink":"https://monocy.site/categories/Markdown/"},{"name":"React","slug":"React","permalink":"https://monocy.site/categories/React/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://monocy.site/categories/TypeScript/"},{"name":"Env","slug":"环境","permalink":"https://monocy.site/categories/环境/"},{"name":"Other","slug":"Other","permalink":"https://monocy.site/categories/Other/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/categories/JavaScript/"},{"name":"Linux","slug":"Linux","permalink":"https://monocy.site/categories/Linux/"},{"name":"Mysql","slug":"Mysql","permalink":"https://monocy.site/categories/Mysql/"},{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/categories/Vue/"},{"name":"Docker","slug":"Docker","permalink":"https://monocy.site/categories/Docker/"},{"name":"Skill","slug":"Skill","permalink":"https://monocy.site/categories/Skill/"},{"name":"Webpack","slug":"webpack","permalink":"https://monocy.site/categories/webpack/"},{"name":"Git","slug":"Git","permalink":"https://monocy.site/categories/Git/"},{"name":"CSS","slug":"CSS","permalink":"https://monocy.site/categories/CSS/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://monocy.site/tags/Node/"},{"name":"Markdown","slug":"Markdown","permalink":"https://monocy.site/tags/Markdown/"},{"name":"React","slug":"React","permalink":"https://monocy.site/tags/React/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://monocy.site/tags/TypeScript/"},{"name":"Env","slug":"环境","permalink":"https://monocy.site/tags/环境/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://monocy.site/tags/JavaScript/"},{"name":"Linux","slug":"Linux","permalink":"https://monocy.site/tags/Linux/"},{"name":"Mysql","slug":"Mysql","permalink":"https://monocy.site/tags/Mysql/"},{"name":"Vue","slug":"Vue","permalink":"https://monocy.site/tags/Vue/"},{"name":"Docker","slug":"Docker","permalink":"https://monocy.site/tags/Docker/"},{"name":"Skill","slug":"Skill","permalink":"https://monocy.site/tags/Skill/"},{"name":"Webpack","slug":"Webpack","permalink":"https://monocy.site/tags/Webpack/"},{"name":"Git","slug":"Git","permalink":"https://monocy.site/tags/Git/"},{"name":"CSS","slug":"CSS","permalink":"https://monocy.site/tags/CSS/"}]}