<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker 安装笔记</title>
    <url>/2019/12/14/Docker-%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不知不觉已经快过 2 个月了，这期间由于项目变更，再加上遇到了一些生活上的波折，基本上没太多心思花在博文的编写了。好不容易稍微有点时间了，立马开始写上一篇，记录一下最近折腾配置的环境。</p>
<blockquote>
<p>仅记录 Mac 环境的配置</p>
</blockquote>
<a id="more"></a>
<h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><p>Docker 安装很简单，有两种方式（基本上网上都有），分别为：</p>
<ul>
<li>brew 安装</li>
<li>安装包安装</li>
</ul>
<h4 id="brew-安装"><a href="#brew-安装" class="headerlink" title="brew 安装"></a>brew 安装</h4><p>brew 安装很简单，命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 等待的时间会有点长</span></span><br><span class="line">brew cask install docker</span><br></pre></td></tr></table></figure>
<h4 id="手动下载安装"><a href="#手动下载安装" class="headerlink" title="手动下载安装"></a>手动下载安装</h4><p>docker 手动下载安装也不是特别复杂，但是为了更为方便快捷，最好还是去<a href="https://hub.docker.com/" target="_blank" rel="noopener">官网注册</a>一个 ID（迟早会去注册账号的），然后再 download 桌面版。</p>
<blockquote>
<p>虽然不知道能不能打开此链接，但是还是奉上 download <a href="https://hub.docker.com/?overlay=onboarding" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<p>此外，还有其它的安装途径，比如 <a href="http://get.daocloud.io/#install-docker-for-mac-windows" target="_blank" rel="noopener">Docker 极速下载</a> 网站（该版本比较低，因此需要自己升级）</p>
<h3 id="Docker-镜像加速"><a href="#Docker-镜像加速" class="headerlink" title="Docker 镜像加速"></a>Docker 镜像加速</h3><p>Docker 默认使用的是国外的源，而国外的源有时会有网络的问题，在后续的拉取中会比较缓慢。</p>
<p>Mac 上的更改操作比较简单，步骤为：</p>
<p>点击 Docker 图标 -&gt; Perferences -&gt; Daemon 标签页 -&gt; Registry mirrors</p>
<p><img data-src="/images/docker-registry.jpg" alt="Docker 镜像"></p>
<p>可添加源有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 国内官方</span></span><br><span class="line">https://registry.docker-cn.com</span><br><span class="line"><span class="comment"># 网易源</span></span><br><span class="line">https://hub-mirror.c.163.com</span><br><span class="line"><span class="comment"># 阿里云</span></span><br><span class="line">https://registry.aliyuncs.com</span><br><span class="line"><span class="comment"># 中科大</span></span><br><span class="line">https://docker.mirrors.ustc.edu.cn</span><br></pre></td></tr></table></figure>
<p>之后点击 <code>Apply &amp; Restart</code> 等待片刻即可。</p>
<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><h4 id="拉取远程镜像"><a href="#拉取远程镜像" class="headerlink" title="拉取远程镜像"></a>拉取远程镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull [registry[:port]/]packages[:tags]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认拉取的为 <a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">Docker Hub</a> 的 latest 版本的包</p>
</blockquote>
<h4 id="镜像列举与空间占用"><a href="#镜像列举与空间占用" class="headerlink" title="镜像列举与空间占用"></a>镜像列举与空间占用</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前下载的镜像资源（压缩的）</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 查看镜像、容器、卷宗占用体积</span></span><br><span class="line">docker system df</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>docker image prune</code> 删除无用镜像</p>
</blockquote>
<h4 id="删除镜像与容器"><a href="#删除镜像与容器" class="headerlink" title="删除镜像与容器"></a>删除镜像与容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi &lt;image&gt; [others...]</span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm &lt;container-hash/container-name&gt;</span><br></pre></td></tr></table></figure>
<h4 id="运行与操作容器"><a href="#运行与操作容器" class="headerlink" title="运行与操作容器"></a>运行与操作容器</h4><p>创建并运行容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run</span><br><span class="line">  [--name &lt;container-name&gt;]</span><br><span class="line">  [-p &lt;image-port&gt;:&lt;<span class="built_in">local</span>-port&gt;]</span><br><span class="line">  [-v &lt;<span class="built_in">local</span>-path&gt;:&lt;container-path&gt;]</span><br><span class="line">  [-e &lt;container-env&gt;=&lt;params&gt;]</span><br><span class="line">  [-d]</span><br><span class="line">  &lt;image-name&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>name 为容器别名； p 为端口映射； v 为卷宗地址映射； e 为环境变量声明； d 为后台运行容器</p>
</blockquote>
<p>启动容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start &lt;container-name/container-hash&gt;</span><br></pre></td></tr></table></figure>
<p>重新启动容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart &lt;container-name/container-hash&gt;</span><br></pre></td></tr></table></figure>
<p>终止容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop &lt;container-name/container-hash&gt;</span><br></pre></td></tr></table></figure>
<p>进入容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以 bash 的方式，进入伪终端； -it： 支持 stdin 切推出不会停止容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;container-name&gt; bash</span><br></pre></td></tr></table></figure>
<h3 id="拷贝镜像内容"><a href="#拷贝镜像内容" class="headerlink" title="拷贝镜像内容"></a>拷贝镜像内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker cp &lt;container&gt;:&lt;path&gt; &lt;<span class="built_in">local</span>-path&gt;</span><br></pre></td></tr></table></figure>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://www.runoob.com/docker/macos-docker-install.html" target="_blank" rel="noopener">MacOS Docker 安装</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">Docker — 从入门到实践</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安装 nginx</title>
    <url>/2020/03/11/Docker-%E5%AE%89%E8%A3%85-nginx/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自学 Docker 系列，了解常用包的使用和配置安装，此篇记录 nginx 的安装</p>
<a id="more"></a>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>下载 nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure>
<p>普通运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name nginx -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>
<p>如果需要挂载在本地，则需要设置虚拟卷宗</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name nginx -p 80:80 -v /Users/saitane/Docker/nginx/nginx.conf:/etc/nginx/nginx.conf -v /Users/saitane/Docker/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf -v /Users/saitane/Docker/nginx/html:/usr/share/nginx/html -d nginx</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处我将 <code>nginx.conf</code>、<code>default.conf</code> 和 <code>html</code>静态文件夹 映射到本地的 nginx 文件夹内，之后就不用进入容器内配置文件以及繁琐的 <code>docker cp</code> 拷贝代码了，<strong>但得注意生成容器后需要将文件拷贝到本地</strong></p>
</blockquote>
<h3 id="服务器-nginx-安装"><a href="#服务器-nginx-安装" class="headerlink" title="服务器 nginx 安装"></a>服务器 nginx 安装</h3><p>除了 Docker 的安装方式，此处记录一下我在 centos 装 nginx 遇到的一些问题和解决方法。</p>
<h4 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h4><p>centos 装 ngixn 先查看下是否有安装 nginx 的源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum repolist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有安装会有这么一行信息</span></span><br><span class="line"><span class="comment"># 源标识                                               源名称</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># nginx/x86_64                                         nginx repo</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>若没有安装源，则安装一下 nginx 的源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure>
<h4 id="启动-nginx"><a href="#启动-nginx" class="headerlink" title="启动 nginx"></a>启动 nginx</h4><p>配置前先看一看是否有历史遗留的 nginx 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -lntp | grep nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如我这里就有一些安装的，但是部分没用却没有停止的服务，根据情况 kill 掉部分</span></span><br><span class="line"><span class="comment"># tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      14514/nginx: master</span></span><br><span class="line"><span class="comment"># tcp        0      0 0.0.0.0:440             0.0.0.0:*               LISTEN      3451/nginx: master</span></span><br><span class="line"><span class="comment"># tcp        0      0 0.0.0.0:8099            0.0.0.0:*               LISTEN      24166/nginx: master</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要深度清理残留 nginx 文件，<code>find / -name nginx</code> 根据情况来处理即可</p>
</blockquote>
<p>处理完成后，注册 nginx 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注册开机启动 nginx</span></span><br><span class="line">systemctl <span class="built_in">enable</span> nginx</span><br><span class="line"><span class="comment"># 启动 nginx</span></span><br><span class="line">service start nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启指令： `service restart nginx`</span></span><br><span class="line"><span class="comment"># 停止指令： `service stop nginx`</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，更新 nginx 文件后需要重启 nginx</p>
</blockquote>
<p>然后 nginx 就启动成功了</p>
<h4 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h4><p>yum 安装的 nginx 配置文件一般在 <code>/etc/nginx</code> 内，配置 <code>nginx.conf</code> 或者 <code>conf.d/default.conf</code> 即可，更多配置可以翻查下文档，这里就不介绍了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是在记不住就用这个命令查找，它会列举处所有地址</span></span><br><span class="line">whereis nginx</span><br></pre></td></tr></table></figure>
<p>此处仅仅改了 root 文件夹的位置，方便项目构建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># conf.d/default.conf</span></span><br><span class="line">location / &#123;</span><br><span class="line">  root   &lt;target-path&gt;;</span><br><span class="line">  index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>便捷指令记录：</p>
<ul>
<li>查看服务器 IP 地址命令： <code>ifconfig -a</code></li>
<li>查看端口是否占用： <code>lsof -i:&lt;端口&gt;</code></li>
</ul>
</blockquote>
<h4 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h4><h5 id="nginx-反向代理替换规则"><a href="#nginx-反向代理替换规则" class="headerlink" title="nginx 反向代理替换规则"></a>nginx 反向代理替换规则</h5><p>代理地址是否添加尾部 ‘/‘ 会影响到路径的匹配，总结的规律如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ^~ /xxx/ &#123;</span><br><span class="line">  proxy_set_header Host             $host;</span><br><span class="line">  proxy_set_header X-Real-IP        $remote_addr;</span><br><span class="line">  proxy_pass http://127.0.0.1:1234/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 此最终会被替换成： http://127.0.0.1:1234/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ^~ /xxx/ &#123;</span><br><span class="line">  proxy_set_header Host             $host;</span><br><span class="line">  proxy_set_header X-Real-IP        $remote_addr;</span><br><span class="line">  proxy_pass http://127.0.0.1:1234;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 此最终会被替换成： http://127.0.0.1:1234/xxx/</span><br></pre></td></tr></table></figure>
<h5 id="nginx-的-nginx-pid-丢失问题"><a href="#nginx-的-nginx-pid-丢失问题" class="headerlink" title="nginx 的 nginx.pid 丢失问题"></a>nginx 的 <code>nginx.pid</code> 丢失问题</h5><p>nginx 重启时有时候会丢失 pid 文件，特别是被强制杀掉进程的情况，这种情况下我们需要进入 nginx 的安装目录的 sbin 下重新启动 nginx：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd &lt;nginx-dir&gt;/sbin</span></span><br><span class="line">./nginx -c &lt;nginx.conf path&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>防止此丢失问题发生，在更新 nginx 时尽量使用 nginx reload 来平滑重启，重载配置。</p>
</blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://www.cnblogs.com/larryzq/p/11009045.html" target="_blank" rel="noopener">CentOS 7 yum 安装 Nginx</a></li>
<li><a href="https://www.jianshu.com/p/c1ce9eec5fb2" target="_blank" rel="noopener">Linux 彻底卸载 Nginx</a></li>
<li><a href="https://www.runoob.com/linux/linux-comm-kill.html" target="_blank" rel="noopener">Linux kill 命令</a></li>
<li><a href="https://www.cnblogs.com/happySmily/p/6003579.html" target="_blank" rel="noopener">nginx 重启报找不到 nginx.pid 的解决方法</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安装 mysql</title>
    <url>/2020/03/11/Docker-%E5%AE%89%E8%A3%85-mysql/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自学 Docker 系列，了解常用包的使用和配置安装，此篇记录 mysql 的安装</p>
<a id="more"></a>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>下载 mysql（8 版本和 7 版本不太一样）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql:latest</span><br><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>
<ol>
<li>安装 mysql57</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mysql57 -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql:5.7</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时直接通过 tomcat 或者 workbench 连接上即可</p>
</blockquote>
<ol start="2">
<li>安装 mysql:latest</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果用 tomcat 连接不上 mysql，那么请参阅参考文章</p>
</blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://www.cnblogs.com/feipeng8848/p/10470655.html" target="_blank" rel="noopener">Docker 安装 mysql</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 模块</title>
    <url>/2019/08/11/ES6-%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为 JS 中最重要的代码组织模式，了解 ES6 模块也是很有必要的。在最近的阅读学习过程中，对于模块这部分也略有心得，在此记录一下习得的知识。</p>
<blockquote>
<p>知识点来自《你所不知道的 JavaScript 下卷》</p>
</blockquote>
<a id="more"></a>
<h3 id="旧方法"><a href="#旧方法" class="headerlink" title="旧方法"></a>旧方法</h3><p>在程序编写过程中，我们有时候需要一个包含内部变量和函数的外层函数，来实现面向接口式的编程。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标功能</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span> + name + <span class="string">'!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公共 API</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    greeting: greeting</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一次调用 Hello 我们都会生成一个新的实例，如果我们仅需要单例的话，此常见的变形便是闭包（IIFE）了，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = (<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span> + name + <span class="string">'!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公共 API</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    greeting: greeting</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="string">'katty'</span>);</span><br><span class="line"></span><br><span class="line">hello.greeting(); <span class="comment">// hello katty !</span></span><br></pre></td></tr></table></figure>
<h3 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h3><p>“新方法”其实有很多，比如 UMD、AMD和CommonJS等，但是此处仅仅介绍 ES6 的模块方法，毕竟基于语言官方推荐的模块导出引入，必将成为未来的主流方法。</p>
<p>支撑起 ES6 模块的两个主要关键字是 export 和 import，此两方法必须出现在所有代码块和函数的外面（如：不能放在 if 方法内），下面详细介绍一下。</p>
<h4 id="导出方法"><a href="#导出方法" class="headerlink" title="导出方法"></a>导出方法</h4><p>export 关键字即表示模块的导出。导出的方式有很多种，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrPos = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个 ES6 模块来说，没有 export 表示的任何变量或者函数，其都是作用域内部私有的。</p>
<p>此外，一个模块内（即一个 js 文件内）只有一个默认导出方法，但是可以有多个命名导出的方法，下面就介绍一下“命名导出”。</p>
<h5 id="命名导出"><a href="#命名导出" class="headerlink" title="命名导出"></a>命名导出</h5><p>首先我们得注意的是，命名导出导出的是变量的引用，而非值的拷贝。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> num = <span class="number">2</span>;</span><br><span class="line">num = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>对于之后引用 bar.js 文件的 num 属性时，我们获得的 num 值为 3。</p>
<p>此外，命名导出还有许多变体，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的简略写法</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo, baz &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改导出名称</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> bar, baz &#125;</span><br></pre></td></tr></table></figure>
<p>既然有更改导出的名称的写法，那么我们能不能更改默认导出的绑定内容呢？答案是可以的。我将其称之为“动态默认导出”。</p>
<h5 id="动态默认导出"><a href="#动态默认导出" class="headerlink" title="动态默认导出"></a>动态默认导出</h5><p>所谓动态默认导出，即它能够动态的改变默认导出的内容而不影响其余代码的更改。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">foo = <span class="number">10</span>;</span><br><span class="line">bar = <span class="string">"cool"</span>;</span><br></pre></td></tr></table></figure>
<p>当倒入这个模块时， default 和 bar 会默认绑定到局部变量 foo 和 bar，即它们会暴露更新后的值 10 和 “cool”。</p>
<blockquote>
<p>注：导出时刻的值是无关紧要的，导入时候的值也是，绑定是活连接，所以重要的是访问这个绑定时刻的当前值。</p>
</blockquote>
<p>导出内容能够动态改变，那么这样能否减少我们对模块导入时的代码量呢？那么看看“动态模块导出”吧。</p>
<h5 id="动态模块导出"><a href="#动态模块导出" class="headerlink" title="动态模块导出"></a>动态模块导出</h5><p>对于公共文件夹内文件来说，初期文件不多的情况我们经常会这么引用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ModuleA <span class="keyword">from</span> <span class="string">'./common/module-a'</span>;</span><br></pre></td></tr></table></figure>
<p>然而，当文件越来越多时，这种写法就比较笨拙了，因此我们可以维护一个公共 index.ts 文件来中心化文件导出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> ModuleA <span class="keyword">from</span> <span class="string">'./module-a'</span>;</span><br><span class="line"><span class="keyword">import</span> ModuleB <span class="keyword">from</span> <span class="string">'./module-b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  ModuleA,</span><br><span class="line">  ModuleB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  ModuleA,</span><br><span class="line">  ModuleB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这种写法基本能解决模块引入问题，然而缺点是每次新增文件后，都需要改 3 处，变动的点相对太多了。因此为了减少改变的代码量，我们可以使用“动态模块导出”法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态模块导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> ModuleA &#125; <span class="keyword">from</span> <span class="string">'./module-a'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> ModuleB &#125; <span class="keyword">from</span> <span class="string">'./module-b'</span>;</span><br></pre></td></tr></table></figure>
<p>这样每次变动后，我们只需要新增一行即可，代码的改变量就很少了。</p>
<h4 id="导入方法"><a href="#导入方法" class="headerlink" title="导入方法"></a>导入方法</h4><p>与 export 相同，import 导入同样也有相应的变体，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全量导入</span></span><br><span class="line"><span class="keyword">import</span> ModuleA <span class="keyword">from</span> <span class="string">'./module-a'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> ModuleA &#125; <span class="keyword">from</span> <span class="string">'./module-a'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./module-a'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变名导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar <span class="keyword">as</span> foo &#125;  <span class="keyword">from</span> <span class="string">'./module-a'</span>;</span><br></pre></td></tr></table></figure>
<p>当然，我们还可以将默认导入和其他命名导入一起导入。加入我们有这么一个导出的模块，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>那么导入这个模块的默认导出和它的命名导出的写法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foo, &#123; bar &#125; <span class="keyword">from</span> <span class="string">'./module-a'</span>;</span><br></pre></td></tr></table></figure>
<p>ES6 模块这些强烈建议的方法是，只从模块导入需要的具体绑定。如果一个模块提供了 10 个 API 方法，但是你只需要其中的 2 个，有些人坚信将所有的 API 绑定都导入进了是一种浪费。</p>
<p>因此他们提倡的是“窄导入”（没有 export default），这样除了代码更加清晰外，其另一个好处是使得静态分析和错误检测（比如意外使用了错误的绑定名称）更加健壮。</p>
<p>然而这种方法的缺点是比较繁复、每次新增东西时都得更新 import 方法（特别是需要全量导入的情况），因此 import 又有一种语法变体可以支持这种模块的导入，称为“命名空间导入”</p>
<h5 id="命名空间导入"><a href="#命名空间导入" class="headerlink" title="命名空间导入"></a>命名空间导入</h5><p>命名空间导入就是将模块内所有的导出内容（包括默认导出的内容）都归纳在一个命名空间内，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导出模块</span></span><br><span class="line"><span class="comment">// foo.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"myName"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">"foo"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果对应的导出模块有 default 导出时，使用 * as xxx 全量引入时，我们可以通过 xxx.default 来获取/使用默认导出的内容。</p>
</blockquote>
<h4 id="模块依赖环"><a href="#模块依赖环" class="headerlink" title="模块依赖环"></a>模块依赖环</h4><p>模块部分最令人疑惑的是 A 导入 B，然后 B 导入 A，这种情况是如何工作的。</p>
<p>首先“模块A”：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A 模块</span></span><br><span class="line"><span class="keyword">import</span> bar <span class="keyword">from</span> <span class="string">"B"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">10</span>) <span class="keyword">return</span> bar(x - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是“模块B”：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// B 模块</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">"A"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">5</span>) <span class="keyword">return</span> foo(y / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> y * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ES6 的模块下，改两声明处于不同的作用域内，因此其需要额外的工作来支持这样的循环引用。下面是粗略概念的意义上循环的 import 依赖如何生效和解析的过程：</p>
<ul>
<li>如果先加载“模块A”，第一步是扫描这个文件分析所有的导出，这样就可以注册所有可以导入的绑定。然后处理 import … from “B”。</li>
<li>引擎加载“模块B”之后，会对它的导出绑定进行同样的分析。当看到 import … from “A”，它已经了解 “A” 的 API，所以可以验证 import 是否有效。现在它了解 “B” 的 API，就可以验证等待的 “A” 模块中 import … from “B” 的有效性。</li>
</ul>
<p>现在让我们验证一下这两个模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用 foo</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">"A"</span>;</span><br><span class="line">foo(<span class="number">25</span>); <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用 bar</span></span><br><span class="line"><span class="keyword">import</span> bar <span class="keyword">from</span> <span class="string">"bar"</span>;</span><br><span class="line">bar(<span class="number">25</span>); <span class="comment">// 11.5</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>IntersectionObserver 与延迟加载</title>
    <url>/2019/09/10/IntersectionObserver-%E4%B8%8E%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着项目图表使用的复杂程度的提升，“大数据”与多图表渲染带来的影响是页面响应慢、用户体验随时间越来越糟。通过 chrome 的 performance 分析出的原因是：接口耗时基本可忽略不计，页面渲染耗时才是对用户体验的真正影响。因此如何更“智能”的加载渲染的图表才是问题解决的关键，而这就要聊到“延迟加载”了。</p>
<a id="more"></a>
<h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>延迟加载比较通俗的说法为“懒加载”，其使用的场景都是在页面加载时优先加载关键资源（比如整体的页面轮廓等），非关键资源则在需要时才进行加载。</p>
<p>那为什么需要延迟加载呢？有需必有求，首先看看直接加载所导致的一些问题：</p>
<ul>
<li>加载过多无用内容，造成数据流量的浪费，增加浏览器压力。</li>
<li>渲染时间增长，用户等待时间增长，会造成部分用户流失。</li>
<li>浪费处理时间、电池电量和其它系统资源</li>
</ul>
<p>为了增强用户体验，因此我们需要进行延迟加载。</p>
<h4 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h4><p>早期还没有 IntersectionObserver 时，为了支持延迟加载，我们常使用的方法是 <code>Element.getBoundingClientRect()</code>。通过该方法来获取目标元素的大小以及其相对于视口的位置，从而来判断是否加载需要渲染的内容。</p>
<p>其语法为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> targetElement = <span class="built_in">document</span>.getElementById(<span class="string">'id'</span>);</span><br><span class="line"><span class="keyword">const</span> rectObject = targetElement.getBoundingClientRect();</span><br><span class="line"></span><br><span class="line">rectObject.top    <span class="comment">// 元素上边到视窗上边的距离;</span></span><br><span class="line">rectObject.right  <span class="comment">// 元素右边到视窗左边的距离;</span></span><br><span class="line">rectObject.bottom <span class="comment">// 元素下边到视窗上边的距离;</span></span><br><span class="line">rectObject.left   <span class="comment">// 元素左边到视窗左边的距离;</span></span><br><span class="line">rectObject.width  <span class="comment">// 是元素自身的宽</span></span><br><span class="line">rectObject.height <span class="comment">// 是元素自身的高</span></span><br></pre></td></tr></table></figure>
<p>例子：</p>
<iframe id="cp_embed_yLBKvKJ" src="//codepen.io/kazehaiya/embed/yLBKvKJ?height=300&theme-id=dark&slug-hash=yLBKvKJ&default-tab=css,result" scrolling="no" frameborder="no" height="300" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe>
<p>既然有了 <code>getBoundingClientRect</code> 方法，那么为什么还需要 <code>IntersectionObserver</code> 方法呢？这里引用 MDN 上的一段话：</p>
<div class="note info">
            <p>过去，交集检测通常需要涉及到事件监听，以及对每个目标元素执行 Element.getBoundingClientRect() 方法以获取所需信息。可是这些代码都在主线程上运行，所以任何一点都可能造成性能问题。当网页遍布这些代码时就显得比较丑陋了。</p>
          </div>
<p>简而言之，<code>getBoundingClientRect</code> 方法对于需要监听大量对象的情况，其处理并不是特别完美（比如无限滚动，scroll 事件发生过于密集，容易造成性能问题），而这种情况下 <code>IntersectionObserver</code> 可以比较完美的解决这个问题。</p>
<h3 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h3><p>首先 IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发（即我们不用监听 scroll 事件了）。此外，该观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。</p>
<p>这里再一次引用 MDN 上的解释：</p>
<div class="note info">
            <p>Intersection Observer API 会注册一个回调方法，每当期望被监视的元素进入或者退出另外一个元素的时候(或者浏览器的视口)该回调方法将会被执行，或者两个元素的交集部分大小发生变化的时候回调方法也会被执行。通过这种方式，网站将不需要为了监听两个元素的交集变化而在主线程里面做任何操作，并且浏览器可以帮助我们优化和管理两个元素的交集变化。</p>
          </div>
<p>少了对滚动事件的处理，在不考虑兼容性的情况下，性能方面肯定优于 <code>getBoundingClientRect</code>。那么它具体该如何使用呢？Demo 如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 observer</span></span><br><span class="line"><span class="keyword">const</span> io = <span class="keyword">new</span> IntersectionObserver(callback, options);</span><br><span class="line"><span class="comment">// 监听目标元素</span></span><br><span class="line">io.observe(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止目标元素的监听</span></span><br><span class="line">io.unobserve(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止对所有目标元素可见性变化的观察</span></span><br><span class="line">io.disconnect();</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>callback</code> 是触发可见行变化时的回调函数，<code>options</code> 是配置对象。</p>
<h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><p>首先看看 options 配置，其总共有三个属性：<code>root</code>、<code>rootMargin</code> 和 <code>threshold</code>。</p>
<p><code>root</code> 指选定的目标容器，默认为浏览器的视窗。</p>
<p><code>rootMargin</code> 定义元素的 <code>margin</code>，<code>viewport + rootMargin</code> 为最终计算的视窗大小，这里引用一张图</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4060631-ae60b52ea8a52184.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt></p>
<p><code>threshold</code> 属性决定了什么时候触发回调函数。它是既可以是一个单一的 number 也可以是一个 number 数组，其表示目标元素和 root 元素相交程度达到该值的时候，callback 回调函数将会被执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> IntersectionObserver(</span><br><span class="line">  (entries, observer) =&gt; &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 在相交程度为 0、25%、50%、75%、100% 时触发回调</span></span><br><span class="line">    threshold: [<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h4><p>当目标元素可见行变化时，其会触发 <code>callback</code> 函数，一般情况该函数会触发<strong>2次</strong>（进入和离开）。该函数有两个参数： <code>IntersectionObserverEntry 对象</code> 和 <code>观察者</code> 的列表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">entries, observers</span>) </span>&#123;</span><br><span class="line">  entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Each entry describes an intersection change for one observed</span></span><br><span class="line">    <span class="comment">// target element:</span></span><br><span class="line">    <span class="comment">//   entry.rootBounds</span></span><br><span class="line">    <span class="comment">//   entry.boundingClientRect</span></span><br><span class="line">    <span class="comment">//   entry.intersectionRect</span></span><br><span class="line">    <span class="comment">//   entry.intersectionRatio</span></span><br><span class="line">    <span class="comment">//   entry.isIntersecting</span></span><br><span class="line">    <span class="comment">//   entry.target</span></span><br><span class="line">    <span class="comment">//   entry.time</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">🔽[IntersectionObserverEntry]</span><br><span class="line">    time: <span class="number">3893.92</span></span><br><span class="line">  🔽rootBounds: ClientRect</span><br><span class="line">      bottom: <span class="number">920</span></span><br><span class="line">      height: <span class="number">1024</span></span><br><span class="line">      left: <span class="number">0</span></span><br><span class="line">      right: <span class="number">1024</span></span><br><span class="line">      top: <span class="number">0</span></span><br><span class="line">      width: <span class="number">920</span></span><br><span class="line">  🔽boundingClientRect: ClientRect</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  🔽intersectionRect: ClientRect</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    intersectionRatio: <span class="number">0.54</span></span><br><span class="line">  🔽target: div#observee</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><code>rootBounds</code>： root 元素调用 getBoundingClientRect() 函数的返回值（默认是 viewport 视口）</p>
<p><code>boundingClientRect</code>： 目标 observer 调用 getBoundingClientRect() 函数的返回值</p>
<p><code>intersectionRect</code>： 上述两矩形的交集，并且有效的告诉你观测到的元素的哪一部分是可见的</p>
<p><code>intersectionRect</code>： 该属性告诉你元素目前有多少是可见的，比率是多少</p>
<p><code>isIntersecting</code>： 目标元素在 root 元素中可见性是否发生了变化（至少得达到 thresholds 数组中的一个阈值）</p>
<p><code>target</code>：  被观测的目标 DOM 元素</p>
<p><code>time</code>： 可见行发生变化的时间（单位： ms）</p>
<p>再次引用一张图片来解释上述部分参数：</p>
<p><img data-src="https://developers.google.com/web/updates/images/2016/04/intersectionobserver/intersectratio.png" alt></p>
<blockquote>
<p>请留意，你注册的回调函数将会在主线程中被执行。所以该函数执行速度要尽可能的快。如果有一些耗时的操作需要执行，建议使用 Window.requestIdleCallback() 方法。</p>
</blockquote>
<h4 id="实战：无限滚动"><a href="#实战：无限滚动" class="headerlink" title="实战：无限滚动"></a>实战：无限滚动</h4><iframe id="cp_embed_YzKLNBz" src="//codepen.io/kazehaiya/embed/YzKLNBz?height=300&theme-id=dark&slug-hash=YzKLNBz&default-tab=css,result" scrolling="no" frameborder="no" height="300" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe>
<h3 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h3><ul>
<li><a href="https://developers.google.com/web/updates/2019/02/intersectionobserver-v2" target="_blank" rel="noopener">Trust is Good, Observation is Better—Intersection Observer v2</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/" target="_blank" rel="noopener">延迟加载图像和视频</a></li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://developers.google.com/web/updates/2016/04/intersectionobserver" target="_blank" rel="noopener">IntersectionObserver’s Coming into View</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">Intersection Observer API</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noopener">getBoundingClientRect</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html" target="_blank" rel="noopener">IntersectionObserver API 使用教程</a></li>
<li><a href="https://www.jianshu.com/p/84a86e41eb2b" target="_blank" rel="noopener">谈谈 IntersectionObserver 懒加载</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Github 无法登陆问题</title>
    <url>/2020/03/09/Github-%E6%97%A0%E6%B3%95%E7%99%BB%E9%99%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>从过年回家到现在（肺炎封城），github 就从来没有登陆成功，原先一直以为是家里网的问题，知道今天偶然间用手机登上了 github，发现事情并没有那么简单，重新配置了一下 <code>/etc/hosts</code> 文件后，终于能登上 github 官网了。</p>
<a id="more"></a>
<h3 id="hosts-文件"><a href="#hosts-文件" class="headerlink" title="hosts 文件"></a>hosts 文件</h3><p>Hosts 是一个没有扩展名的系统文件，其作用就是将一些常用的网址域名与其对应的 IP 地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从 Hosts 文件中寻找对应的 IP 地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交 DNS 域名解析服务器进行 IP 地址的解析。</p>
<blockquote>
<p>注意：Hosts 文件配置的映射是静态的，如果目标域名对应的 ip 更改了，但 hosts 文件的映射没有及时更新，会导致页面无法访问。</p>
</blockquote>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>解决方法非常简单，将 <code>/etc/host</code> 文件内的 <code>github.com</code> 的映射注释掉即可，或者是更新对应的 ip。</p>
<p>一般在 <a href="https://www.ipaddress.com/" target="_blank" rel="noopener">IPAddress</a> 里面进行 IP 查询。</p>
<blockquote>
<p>补充：更新 IP 的方法好像不行</p>
</blockquote>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://baike.baidu.com/item/hosts/10474546?fr=aladdin" target="_blank" rel="noopener">hosts</a></li>
</ul>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Env</tag>
      </tags>
  </entry>
  <entry>
    <title>JSX 语法总结</title>
    <url>/2019/09/01/JSX-%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近着手编写 JSON 可视化部分的内容，由于此部分需要基于基础组件进行封装，Vue 的 JSX 的写法用的比较频繁，此处就记录我目前所能总结出的 JSX 的写法，以做备忘。</p>
<a id="more"></a>
<h3 id="基础写法"><a href="#基础写法" class="headerlink" title="基础写法"></a>基础写法</h3><p>Vue 官网对于 JSX 语法和 Template 语法已经做了很详细的对比了，在此我就不做赘述，此处就仅仅引用一下 JSX 的写法。</p>
<h4 id="创建一个-VNode-的写法"><a href="#创建一个-VNode-的写法" class="headerlink" title="创建一个 VNode 的写法"></a>创建一个 VNode 的写法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @returns &#123;VNode&#125;</span></span><br><span class="line">createElement(</span><br><span class="line">  <span class="comment">// &#123;String | Object | Function&#125;</span></span><br><span class="line">  <span class="comment">// 一个 HTML 标签名、组件选项对象，或者</span></span><br><span class="line">  <span class="comment">// resolve 了上述任何一种的一个 async 函数。必填项。</span></span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;Object&#125;</span></span><br><span class="line">  <span class="comment">// 一个与模板中属性对应的数据对象。可选。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// (详情见下一代码块)</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;String | Array&#125;</span></span><br><span class="line">  <span class="comment">// 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，</span></span><br><span class="line">  <span class="comment">// 也可以使用字符串来生成“文本虚拟节点”。可选。</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">'先写一些文字'</span>,</span><br><span class="line">    createElement(<span class="string">'h1'</span>, <span class="string">'一则头条'</span>),</span><br><span class="line">    createElement(MyComponent, &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        someProp: <span class="string">'foobar'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="VNode-中的数据对象的写法"><a href="#VNode-中的数据对象的写法" class="headerlink" title="VNode 中的数据对象的写法"></a>VNode 中的数据对象的写法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// @params &#123; String, Object &#125;</span></span><br><span class="line">  <span class="comment">// 与 `v-bind:class` 的 API 相同，</span></span><br><span class="line">  <span class="comment">// 接受一个字符串、对象或字符串和对象组成的数组</span></span><br><span class="line">  <span class="string">'class'</span>: &#123;</span><br><span class="line">    foo: <span class="literal">true</span>,</span><br><span class="line">    bar: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// @params &#123; String, Object &#125;</span></span><br><span class="line">  <span class="comment">// 与 `v-bind:style` 的 API 相同，</span></span><br><span class="line">  <span class="comment">// 接受一个字符串、对象，或对象组成的数组</span></span><br><span class="line">  style: &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="string">'14px'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 普通的 HTML 特性</span></span><br><span class="line">  attrs: &#123;</span><br><span class="line">    id: <span class="string">'foo'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 组件 prop</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    myProp: <span class="string">'bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// DOM 属性</span></span><br><span class="line">  domProps: &#123;</span><br><span class="line">    innerHTML: <span class="string">'baz'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 事件监听器在 `on` 属性内，</span></span><br><span class="line">  <span class="comment">// 但不再支持如 `v-on:keyup.enter` 这样的修饰器。</span></span><br><span class="line">  <span class="comment">// 需要在处理函数中手动检查 keyCode。</span></span><br><span class="line">  on: &#123;</span><br><span class="line">    click: <span class="keyword">this</span>.clickHandler</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 仅用于组件，用于监听原生事件，而不是组件内部使用</span></span><br><span class="line">  <span class="comment">// `vm.$emit` 触发的事件。</span></span><br><span class="line">  nativeOn: &#123;</span><br><span class="line">    click: <span class="keyword">this</span>.nativeClickHandler</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 自定义指令。注意，你无法对 `binding` 中的 `oldValue`</span></span><br><span class="line">  <span class="comment">// 赋值，因为 Vue 已经自动为你进行了同步。</span></span><br><span class="line">  directives: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'my-custom-directive'</span>,</span><br><span class="line">      value: <span class="string">'2'</span>,</span><br><span class="line">      expression: <span class="string">'1 + 1'</span>,</span><br><span class="line">      arg: <span class="string">'foo'</span>,</span><br><span class="line">      modifiers: &#123;</span><br><span class="line">        bar: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 作用域插槽的格式为</span></span><br><span class="line">  <span class="comment">// &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span></span><br><span class="line">  scopedSlots: &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">props</span> =&gt;</span> createElement(<span class="string">'span'</span>, props.text)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 如果组件是其它组件的子组件，需为插槽指定名称</span></span><br><span class="line">  slot: <span class="string">'name-of-slot'</span>,</span><br><span class="line">  <span class="comment">// 其它特殊顶层属性</span></span><br><span class="line">  key: <span class="string">'myKey'</span>,</span><br><span class="line">  ref: <span class="string">'myRef'</span>,</span><br><span class="line">  <span class="comment">// 如果你在渲染函数中给多个元素都应用了相同的 ref 名，</span></span><br><span class="line">  <span class="comment">// 那么 `$refs.myRef` 会变成一个数组。</span></span><br><span class="line">  refInFor: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模板修饰符的一些兼容写法"><a href="#模板修饰符的一些兼容写法" class="headerlink" title="模板修饰符的一些兼容写法"></a>模板修饰符的一些兼容写法</h4><div class="note success">
            <p>假设此处已经配置了 Babel 插件</p>
          </div>
<h5 id="v-if-和-v-for-的实现"><a href="#v-if-和-v-for-的实现" class="headerlink" title="v-if 和 v-for 的实现"></a><code>v-if</code> 和 <code>v-for</code> 的实现</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v-if 的实现</span></span><br><span class="line">props: &#123;</span><br><span class="line">  isSection: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;,</span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.isSection ? <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v-for 的实现</span></span><br><span class="line">props: &#123;</span><br><span class="line">  pList: &#123; <span class="attr">type</span>: <span class="built_in">Array</span>, <span class="attr">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> [] &#125;</span><br><span class="line">&#125;,</span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123; <span class="keyword">this</span>.pList.map(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> methods = &#123;</span><br><span class="line">          props: config</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span> &#123;<span class="attr">...methods</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">      &#125;) &#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="v-model-的实现"><a href="#v-model-的实现" class="headerlink" title="v-model 的实现"></a><code>v-model</code> 的实现</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  value: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">default</span>: <span class="string">''</span> &#125;</span><br><span class="line">&#125;,</span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> methods = &#123;</span><br><span class="line">    domProps: &#123;</span><br><span class="line">      value: <span class="keyword">this</span>.value</span><br><span class="line">    &#125;,</span><br><span class="line">    on: &#123;</span><br><span class="line">      input: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, e.target.value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...methods</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">前缀</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.passive</td>
<td style="text-align:center">&amp;</td>
</tr>
<tr>
<td style="text-align:center">.capture</td>
<td style="text-align:center">!</td>
</tr>
<tr>
<td style="text-align:center">.once</td>
<td style="text-align:center">~</td>
</tr>
<tr>
<td style="text-align:center">.capture.once 或 .once.capture</td>
<td style="text-align:center">~!</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">on: &#123;</span><br><span class="line">  <span class="string">'!click'</span>: <span class="keyword">this</span>.doThisInCapturingMode,</span><br><span class="line">  <span class="string">'~keyup'</span>: <span class="keyword">this</span>.doThisOnce,</span><br><span class="line">  <span class="string">'~!mouseover'</span>: <span class="keyword">this</span>.doThisOnceInCapturingMode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其余的修饰符如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">处理函数中的等价操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.stop</td>
<td style="text-align:center">event.stopPropagation()</td>
</tr>
<tr>
<td style="text-align:center">.prevent</td>
<td style="text-align:center">event.preventDefault()</td>
</tr>
<tr>
<td style="text-align:center">.self</td>
<td style="text-align:center">if (event.target !== event.currentTarget) return</td>
</tr>
<tr>
<td style="text-align:center">按键： .enter, .13</td>
<td style="text-align:center">if (event.keyCode !== 13) return (对于别的按键修饰符来说，可将 13 改为<a href="http://keycode.info/" target="_blank" rel="noopener">另一个按键码</a>)</td>
</tr>
<tr>
<td style="text-align:center">修饰键： .ctrl, .alt, .shift, .meta</td>
<td style="text-align:center">if (!event.ctrlKey) return (将 ctrlKey 分别修改为 altKey、shiftKey 或者 metaKey)</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">on: &#123;</span><br><span class="line">  keyup (event) &#123;</span><br><span class="line">    <span class="comment">// 如果触发事件的元素不是事件绑定的元素</span></span><br><span class="line">    <span class="comment">// 则返回</span></span><br><span class="line">    <span class="keyword">if</span> (event.target !== event.currentTarget) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 如果按下去的不是 enter 键或者</span></span><br><span class="line">    <span class="comment">// 没有同时按下 shift 键</span></span><br><span class="line">    <span class="comment">// 则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!event.shiftKey || event.keyCode !== <span class="number">13</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 阻止 事件冒泡</span></span><br><span class="line">    event.stopPropagation()</span><br><span class="line">    <span class="comment">// 阻止该元素默认的 keyup 事件</span></span><br><span class="line">    event.preventDefault()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简化写法"><a href="#简化写法" class="headerlink" title="简化写法"></a>简化写法</h3><p>简化写法需要项目引入对应的 <a href="https://github.com/vuejs/jsx" target="_blank" rel="noopener">Babel 支持</a>，简化后我们可以直接返回对应的 html 写法，其又有两种编写方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 行内属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">props</span>=<span class="string">&#123;&#123;</span> <span class="attr">propName:</span> <span class="attr">123</span> &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 解构属性 --&gt;</span></span><br><span class="line">const methods = &#123; propName: 123 &#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> &#123;<span class="attr">...methods</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于第二种写法更助于逻辑与结构分离，个人更偏向于第二种写法风格。</p>
</blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">渲染函数 &amp; JSX</a></li>
<li><a href="https://forum.vuejs.org/t/scoped-slots-in-jsx/31935" target="_blank" rel="noopener">Scoped Slots in JSX</a></li>
<li><a href="https://github.com/vuejs/jsx" target="_blank" rel="noopener">Babel Preset JSX</a></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 防火墙的使用和配置（转载）</title>
    <url>/2020/07/09/Linux-%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>文章转载自 <a href="https://www.cnblogs.com/shawhe/p/9485746.html" target="_blank" rel="noopener">linux防火墙使用以及配置</a>，使用方法大同小异，在此转载一篇做个笔记。</p>
<a id="more"></a>
<h4 id="Centos-7-firewall-："><a href="#Centos-7-firewall-：" class="headerlink" title="Centos 7 firewall ："></a>Centos 7 firewall ：</h4><h5 id="1-firewalld的基本使用"><a href="#1-firewalld的基本使用" class="headerlink" title="1. firewalld的基本使用"></a>1. firewalld的基本使用</h5><ul>
<li>启动： <code>systemctl start firewalld</code></li>
<li>关闭： <code>systemctl stop firewalld</code></li>
<li>查看状态： <code>systemctl status firewalld</code></li>
<li>开机禁用  ： <code>systemctl disable firewalld</code></li>
<li>开机启用  ： <code>systemctl enable firewalld</code></li>
</ul>
<h5 id="2-systemctl-是-CentOS7-的服务管理工具中主要的工具，它融合之前-service-和chkconfig-的功能于一体。"><a href="#2-systemctl-是-CentOS7-的服务管理工具中主要的工具，它融合之前-service-和chkconfig-的功能于一体。" class="headerlink" title="2. systemctl 是 CentOS7 的服务管理工具中主要的工具，它融合之前 service 和chkconfig 的功能于一体。"></a>2. systemctl 是 CentOS7 的服务管理工具中主要的工具，它融合之前 service 和chkconfig 的功能于一体。</h5><ul>
<li>启动一个服务：<code>systemctl start firewalld.service</code></li>
<li>关闭一个服务：<code>systemctl stop firewalld.service</code></li>
<li>重启一个服务：<code>systemctl restart firewalld.service</code></li>
<li>显示一个服务的状态：<code>systemctl status firewalld.service</code></li>
<li>在开机时启用一个服务：<code>systemctl enable firewalld.service</code></li>
<li>在开机时禁用一个服务：<code>systemctl disable firewalld.service</code></li>
<li>查看服务是否开机启动：<code>systemctl is-enabled firewalld.service</code></li>
<li>查看已启动的服务列表：<code>systemctl list-unit-files|grep enabled</code></li>
<li>查看启动失败的服务列表：<code>systemctl --failed</code></li>
</ul>
<h5 id="3-配置firewalld-cmd"><a href="#3-配置firewalld-cmd" class="headerlink" title="3. 配置firewalld-cmd"></a>3. 配置firewalld-cmd</h5><ul>
<li>查看版本：<code>firewall-cmd --version</code></li>
<li>查看帮助：<code>firewall-cmd --help</code></li>
<li>显示状态：<code>firewall-cmd --state</code></li>
<li>查看所有打开的端口：<code>firewall-cmd --zone=public --list-ports</code></li>
<li>更新防火墙规则：<code>firewall-cmd --reload</code></li>
<li>查看区域信息： <code>firewall-cmd --get-active-zones</code></li>
<li>查看指定接口所属区域：<code>firewall-cmd --get-zone-of-interface=eth0</code></li>
<li>拒绝所有包：<code>firewall-cmd --panic-on</code></li>
<li>取消拒绝状态：<code>firewall-cmd --panic-off</code></li>
<li>查看是否拒绝：<code>firewall-cmd --query-panic</code></li>
</ul>
<p><strong>那怎么开启一个端口呢？</strong></p>
<ul>
<li>添加： <code>firewall-cmd --zone=public --add-port=80/tcp --permanent</code>  （–permanent永久生效，没有此参数重启后失效）</li>
<li>重新载入：<code>firewall-cmd --reload</code></li>
<li>查看：<code>firewall-cmd --zone= public --query-port=80/tcp</code></li>
<li><p>删除：<code>firewall-cmd --zone= public --remove-port=80/tcp --permanent</code></p>
</li>
<li><p>调整默认策略（默认拒绝所有访问，改成允许所有访问）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --<span class="built_in">set</span>-target=ACCEPT</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>对某个IP开放多个端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">"rule family="</span>ipv4<span class="string">" source address="</span>10.159.60.29<span class="string">" port protocol="</span>tcp<span class="string">" port="</span>1:65535<span class="string">" accept"</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Centos-6-iptables："><a href="#Centos-6-iptables：" class="headerlink" title="Centos 6 iptables："></a>Centos 6 iptables：</h4><h5 id="1-iptables的基本使用"><a href="#1-iptables的基本使用" class="headerlink" title="1. iptables的基本使用"></a>1. iptables的基本使用</h5><ul>
<li>启动：<code>service iptables start</code></li>
<li>关闭：<code>service iptables stop</code></li>
<li>查看状态：<code>service iptables status</code></li>
<li>开机禁用：<code>chkconfig iptables off</code></li>
<li>开机启用：<code>chkconfig iptables on</code></li>
</ul>
<h5 id="2-开放指定的端口"><a href="#2-开放指定的端口" class="headerlink" title="2. 开放指定的端口"></a>2. 开放指定的端口</h5><p><code>-A</code> 和 <code>-I</code> 参数分别为添加到规则末尾和规则最前面。</p>
<ul>
<li>允许本地回环接口(即运行本机访问本机)：<code>iptables -A INPUT -i lo -j ACCEPT</code></li>
<li>允许已建立的或相关连的通行：<code>iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</code></li>
<li><p>允许所有本机向外的访问：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT ACCEPT</span><br><span class="line">iptables -A OUTPUT -j ACCEPT</span><br></pre></td></tr></table></figure>
</li>
<li><p>允许访问 22 端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -s 后可以跟 IP 段或指定 IP 地址</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp -s 10.159.1.0/24 --dport 22 -j ACCEPT</span><br></pre></td></tr></table></figure>
</li>
<li><p>允许访问 80 端口：<code>iptables -A INPUT -p tcp --dport 80 -j ACCEPT</code></p>
</li>
<li><p>允许FTP服务的 21 和 20 端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 21 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 20 -j ACCEPT</span><br><span class="line"><span class="comment"># 如果有其他端口的话，规则也类似，稍微修改上述语句就行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>允许 ping：<code>iptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT</code></p>
</li>
<li>禁止其他未允许的规则访问：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注：如果 22 端口未加入允许规则，SSH 链接会直接断开。</span></span><br><span class="line">iptables -A INPUT -j REJECT</span><br><span class="line">iptables -A FORWARD -j REJECT</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-屏蔽IP"><a href="#3-屏蔽IP" class="headerlink" title="3. 屏蔽IP"></a>3. 屏蔽IP</h5><blockquote>
<p>注：如果只是想屏蔽 IP 的话，上述 “2. 开放指定的端口” 可以直接跳过。</p>
</blockquote>
<ul>
<li>屏蔽单个 IP 的命令是：<code>iptables -I INPUT -s 123.45.6.7 -j DROP</code></li>
<li>封整个段(即从 123.0.0.1 到 123.255.255.254)的命令：<code>iptables -I INPUT -s 123.0.0.0/8 -j DROP</code></li>
<li>封 IP 段(即从 123.45.0.1 到 123.45.255.254)的命令：<code>iptables -I INPUT -s 124.45.0.0/16 -j DROP</code></li>
<li>封 IP 段(即从 123.45.6.1 到 123.45.6.254)的命令是：<code>iptables -I INPUT -s 123.45.6.0/24 -j DROP</code></li>
</ul>
<h5 id="4-iptables-的规则"><a href="#4-iptables-的规则" class="headerlink" title="4. iptables 的规则"></a>4. iptables 的规则</h5><h6 id="查看已添加的规则"><a href="#查看已添加的规则" class="headerlink" title="查看已添加的规则"></a>查看已添加的规则</h6><p><code>iptables -L -n</code></p>
<blockquote>
<p>只显示 IP 地址和端口号，不将 IP 解析为域名</p>
</blockquote>
<h6 id="删除已添加的iptables的规则"><a href="#删除已添加的iptables的规则" class="headerlink" title="删除已添加的iptables的规则"></a>删除已添加的iptables的规则</h6><p>将所有iptables以序号标记显示，执行：</p>
<p><code>iptables -L -n --line-numbers</code></p>
<p>比如要删除 INPUT 里序号为 8 的规则，执行：</p>
<p><code>iptables -D INPUT 8</code></p>
<h5 id="5-可以直接编辑配置文件，添加-iptables-防火墙规则："><a href="#5-可以直接编辑配置文件，添加-iptables-防火墙规则：" class="headerlink" title="5. 可以直接编辑配置文件，添加 iptables 防火墙规则："></a>5. 可以直接编辑配置文件，添加 iptables 防火墙规则：</h5><p>iptables 的配置文件为 <code>/etc/sysconfig/iptables</code></p>
<p>编辑配置文件：</p>
<p><code>vi /etc/sysconfig/iptables</code></p>
<p>文件中的配置规则与通过的 iptables 命令配置，语法相似：</p>
<p>如，通过 iptables 的命令配置，允许访问 80 端口：</p>
<p><code>iptables -A INPUT -p tcp --dport 80 -j ACCEPT</code></p>
<p>那么，在文件中配置，只需要去掉句首的 iptables，添加如下内容：</p>
<p><code>-A INPUT -p tcp --dport 80 -j ACCEPT</code></p>
<p>保存退出。</p>
<p>有两种方式添加规则</p>
<p><code>iptables -A 和iptables -I</code></p>
<p><code>iptables -A</code> 添加的规则是添加在最后面。如针对 INPUT 链增加一条规则，接收从 eth0 口进入且源地址为 192.168.0.0/16 网段发往本机的数据。</p>
<p><code>iptables -A INPUT -i eth0 -s 192.168.0.0/16 -j ACCEPT</code></p>
<p><code>iptables -I</code> 添加的规则默认添加至第一条。</p>
<p>如果要指定插入规则的位置，则使用 <code>iptables -I</code> 时指定位置序号即可。</p>
<p>删除规则</p>
<p>如果删除指定则，使用 <code>iptables -D</code> 命令，命令后可接序号。效果请对比上图。</p>
<p>或 <code>iptables -D</code> 接详细定义；</p>
<p>如果想把所有规则都清除掉，可使用 <code>iptables -F</code>。</p>
<p>备份 iptabes rules</p>
<p>使用 <code>iptables-save</code> 命令，如：</p>
<p><code>iptables-save &gt; /etc/sysconfig/iptables.save</code></p>
<p>恢复 iptables rules</p>
<p>使用 <code>iptables</code> 命令，如：</p>
<p><code>iptables-restore &lt; /etc/sysconfig/iptables.save</code></p>
<p>iptables 配置保存</p>
<p>以上做的配置修改，在设备重启后，配置将丢失。可使用 <code>service iptables save</code> 进行保存。</p>
<p>重启 iptables 的服务使其生效：</p>
<p><code>service iptables save</code></p>
<p>添加规则后保存重启生效。</p>
<p><code>service iptables restart</code></p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>关于更多的 iptables 的使用方法可以执行：</p>
<p><code>iptables --help</code></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 对象</title>
    <url>/2019/06/06/JavaScript-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对象是 JavaScript 的七种主要类型中的一种（string、boolean、number、null、undefined、symbol、object），也是这七种主要类型中最为复杂的一种类型，了解对象对学习 JavaScript、了解 <code>this</code>和作用域链，以及之后的“类”的概念都十分重要，而此篇就从边边角角来介绍 JavaScript 中的<strong>对象</strong>。</p>
<a id="more"></a>
<h3 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>对象写法有两种：声明（文字）形式和构造形式。（一般很少使用构造形式）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明文字形式</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造形式</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>写法区别：声明文字形式能传递更多的键/值，构造形式得一个个的添加。</p>
</blockquote>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>为什么要单独强调<strong>类型</strong>？因为在最开始，我也是认为 JS 中万物接对象，其实不然，像我们所熟悉的简单基本类型（string、boolean、undefined、null和number）就并非对象（字面量形式）。函数就是对象的一个子类型（技术角度来说即“可调用的对象”）；同样的，数组也是，只不过是具备一些额外的行为。</p>
<blockquote>
<p><code>typeof null === &#39;object&#39;</code> 是语言本身的 bug，在 JavaScript 中二进制前三位都为 0 的话会被判断为 <code>object</code> ，由于 null 的二进制表示是全 0，因此在做类型判读时会出现“误判”的问题。</p>
</blockquote>
<p>基础类型与对象类型的主要区别就是对象的生存期，使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自基本类型则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型添加属性和方法。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'ConardLi'</span>;</span><br><span class="line">name.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.color); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h5 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h5><p>JavaScript 中还有一些内置对象，例如：</p>
<ul>
<li>String</li>
<li>Boolean</li>
<li>Number</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
</ul>
<p>它们可以类比为 Java 中的 Class（但从 JavaScript 角度来说，它们只是一些可以当作构造函数的内置函数）。但是在使用 JavaScript 时，更为常用的方式是直接声明一个字面量，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">"This is a string"</span>;</span><br><span class="line"><span class="keyword">const</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"This is a object"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> str1 === <span class="string">'string'</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> str2 === <span class="string">'object'</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// false</span></span><br><span class="line">str2 <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(str1); <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(str2); <span class="comment">// [object String]</span></span><br></pre></td></tr></table></figure>
<p>这里解释了字面量并非由 String 的构造函数得到的对象，实际上 str1 为何其表现形式和 str2 无任何不同（从字符串的操作的层面），是因为引擎会自动将字面量转换成其对应的对象类型，因此可以访问对应类型的属性和方法。</p>
<h4 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h4><p>对象的内容是由一些存储在特定命名位置的值组成的，我们称之为属性（可类比指针来理解）。对于基础类型来说，其所存储的值对应一块固定的空间，不会动态改变；而对于对象这样的较为复杂的类型来说，它们存储的为一块内存区域的引用。</p>
<p>通俗的来说，基础类型就像手机店货架上的手机壳，它们是实物，“所见即所得”；而复杂类型就像是手机店柜子内的高价手机，展示的是模型机，其象征这这一型号的所有手机，需要的时候通过此去对应仓库获取真机。</p>
<h5 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h5><p>对象属性的访问方式分为两种，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性访问</span></span><br><span class="line">obj.name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键访问</span></span><br><span class="line">obj[<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure>
<p>两种方式各有优劣，前者在写的时候较为方便，但是得满足标识符的命名规范，比较固定；后者的写法比较多样（ES6支持可计算属性名），缺点是没有前者直接。</p>
<p>需要注意的是，属性名永远都是字符串。如果使用字符串之外的值作为属性名，那么其会先转换成字符串，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="literal">true</span>] = <span class="string">'boolean'</span>;</span><br><span class="line">obj[&#123;&#125;] = <span class="string">'object'</span>;</span><br><span class="line">obj[<span class="number">3</span>] = <span class="string">'number'</span>;</span><br><span class="line"></span><br><span class="line">obj[<span class="string">'true'</span>]; <span class="comment">// boolean</span></span><br><span class="line">obj[<span class="string">'[object object]'</span>]; <span class="comment">// object</span></span><br><span class="line">obj[<span class="string">'3'</span>]; <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
<h5 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h5><p>有时候对象中的属性为一个函数，我们习惯上称这样的属性为“函数的方法”（类比 C 语言）。然而从技术角度来说，在 JavaScript 中，函数永远也不会“属于”一个对象，因为 this 是动态绑定至对象上的（先前有写过这么一篇文章），函数与对象间的关系并不稳定，因此对象与函数最多也只能称作为间接关系。最为保险的说法可能是“函数”和“方法”在 JavaScript 中是可以互换的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本上可以等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>我们知道，在 JS 中数组也是“对象”，但是相对于对象来说，数组有一套更为结构化的值存储机制（通过索引的方式），例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>]; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>由于数组也是一个对象，因此我们也可以给数组添加属性，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 沿用上例</span><br><span class="line">arr.bar = &apos;bar&apos;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果试图像数组内添加一个属性，而属性“看起来”像一个数字（如字符串数子），那么它会变成一个数值下标</p>
</blockquote>
<h3 id="提升内容"><a href="#提升内容" class="headerlink" title="提升内容"></a>提升内容</h3><h4 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h4><p>最早接触到属性描述符的时候还是在读JS红宝书的时候，不过那时候不是很懂有啥用，随着接触的东西逐渐变多，源码也看了一部分，对属性描述符也有了一定的程度的理解。</p>
<p>自 ES5 以来，JS 的所有属性都具备了属性描述符，通过 <code>Object.getOwnPropertyDescription(&lt;obj&gt;, &lt;prop&gt;)</code> 能够拿到对应属性的描述，包含内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  value: <span class="string">'xxx'</span>, <span class="comment">// 值</span></span><br><span class="line">  writable: <span class="literal">true</span>, <span class="comment">// 是否可写（默认）</span></span><br><span class="line">  enumerable: <span class="literal">true</span>, <span class="comment">// 是否可枚举（默认）</span></span><br><span class="line">  configurable: <span class="literal">true</span> <span class="comment">// 是否可配置（默认）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们也可以通过 <code>Object.defineProperty(&lt;obj&gt;, &lt;prop&gt;, {/* */})</code> 来修改属性描述符。</p>
<h5 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h5><p>writable 决定是否可以修改属性的值，如果设置为 false，那么修改属性值时会静默失效</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">"static"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.a = <span class="string">'public'</span>;</span><br><span class="line"></span><br><span class="line">obj.a; <span class="comment">// static（严格模式下会报错）</span></span><br></pre></td></tr></table></figure>
<p>然而，当配置中有配置 getter/setter 时，这个属性会被定义为“访问描述符”（与“数据描述符”相对），对于访问描述符来说， JavaScript 会忽略其 value 和 writable 属性（具体来说此），例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.a; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h5 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h5><p>configurable 决定对象的属性是否可配置。与 writable 不同，writable 控制的是对象属性值能否改变，而 configurable 配置的是属性描述符能否改变，即后者是单向的（某个对象的 configurable 设置为 false 后就无法将其再设置为 true 了）。</p>
<p>除此以外，其还禁止删除此属性，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="string">'static'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.a; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.a;</span><br><span class="line">obj.a; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="string">"static"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.a; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.a;</span><br><span class="line">obj.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： delete 仅是一个删除对象属性的操作，并非一个释放内存的工具</p>
</blockquote>
<blockquote>
<p>特例：当 configurable 设置为 false 之后，writable 可由 true 更改为 false，但无法由 false 更改为 true。</p>
</blockquote>
<h5 id="Enumerable"><a href="#Enumerable" class="headerlink" title="Enumerable"></a>Enumerable</h5><p>顾名思义，此描述符控制的事属性是否会在遍历对象时，将其枚举。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  bar: <span class="number">1</span>,</span><br><span class="line">  foo: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'c'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, obj[key]); <span class="comment">// 没有 [c 3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'c'</span> <span class="keyword">in</span> obj; <span class="comment">// true</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">'c'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>for .. in 循环可以遍历对象的可枚举属性列表（包括[[Prototype]]链），而遍历属性的值我们通常用的是 for .. of，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for .. of 首选会向被访问的对象请求一个迭代器对象，然后通过迭代器对象的 next() 方法来遍历返回值，数组内默认会带有迭代器，因此我们可以直接将 for .. of 运用至数组中。但是对象却没有，我么可以这样造一个自定义迭代器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="built_in">Symbol</span>.iterator, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> ks = <span class="built_in">Object</span>.keys(self);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        value: self[ks[idx++]],</span><br><span class="line">        done: (idx &gt; ks.length )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>遍历数组下标使用的是数字顺序，但是遍历对象时其顺序是不确定的。因此在不同环境要想数据展现形式保持一致，那么一定不要相信任何观察到的顺序，因为它们是不可靠的。</p>
</blockquote>
<h4 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h4><h5 id="对象常量"><a href="#对象常量" class="headerlink" title="对象常量"></a>对象常量</h5><p>我们可以通过设置对象属性的 writable 来设置对象常量，这样能做到真正意义上的不可修改（类比 const 声明）</p>
<h5 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h5><p>对象默认是可扩展的，加入想要禁止一个对象的扩展性，即不能后期新增属性，那么可以使用 <code>Object.preventExtensions(&lt;obj&gt;)</code></p>
<h5 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h5><p><code>Object.seal(&lt;obj&gt;)</code> 会创建一个密封对象，其会在一个现有对象上调用 Object.preventExtensions() 并将所有的属性标记为 <code>configurable: false</code>。其不仅不能添加新属性，也不能重新配置或删除原有属性（可修改属性值）。</p>
<h5 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h5><p><code>Object.freeze(&lt;obj&gt;)</code> 会创建一个冻结对象，其会在对象上调用 Object.seal() 并将所有的属性标记为 <code>writable: false</code>，这样就无法修改其值。</p>
<blockquote>
<p>注意：对象中引用的对象无法被密封和冻结，只有非引用对象受影响最为全面，并且是浅操作。</p>
</blockquote>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li>《你所不知道的 JavaScript》</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 指令学习</title>
    <url>/2020/01/19/Mac-%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在研究可视化编辑器部分的内容，同时借此机会学习学习 node 相关的知识。然而在学习的过程中，发现好不容易申请下来的测试机却不会用，是时候该补充补充 linux 相关的知识了！</p>
<blockquote>
<p>该文档持续完善，争取每周一个指令</p>
</blockquote>
<a id="more"></a>
<h3 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a><code>grep</code> 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取对应文件内的内容</span></span><br><span class="line"><span class="comment">## -n 表示加上行号，file 支持 * 通配符</span></span><br><span class="line">grep -n &lt;content&gt; &lt;file&gt;</span><br></pre></td></tr></table></figure>
<h3 id="du-命令"><a href="#du-命令" class="headerlink" title="du 命令"></a><code>du</code> 命令</h3><p>du 命令用于显示目录或文件的大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看文件深度为 n 的所有文件大小</span></span><br><span class="line"><span class="comment"># n=0 时为该文件大小</span></span><br><span class="line">du -d &lt;depth &gt;= 0&gt; -h &lt;file-path&gt;</span><br></pre></td></tr></table></figure>
<h3 id="tar-命令"><a href="#tar-命令" class="headerlink" title="tar 命令"></a><code>tar</code> 命令</h3><p>tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。可以用来做文件压缩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># touch a.c</span></span><br><span class="line"><span class="comment"># 压缩 a.c文件为 test.tar.gz</span></span><br><span class="line">tar -czvf test.tar.gz a.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出压缩文件中的内容</span></span><br><span class="line">tar -tzvf test.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line">tar -xzvf test.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>-v：显示过程；</li>
<li>-c 建立新的备份文件；</li>
<li>-z：gzip 处理备份文件；</li>
<li>-x：从备份文件中还原文件；</li>
<li>-t：列出文件内容</li>
</ul>
</blockquote>
<h3 id="which-指令"><a href="#which-指令" class="headerlink" title="which 指令"></a>which 指令</h3><p>其主要用途是定位程序在系统的哪个位置，使用方法很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which &lt;target1&gt; &lt;target2&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Env</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 环境配置</title>
    <url>/2020/08/26/Mac-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近新换了一台 Mac（原来公司的 Mac 敲多了胳膊酸），因此又要重新配置 Mac 环境，想了想如果之后 Mac 又换了一台，那不又双叒叕得重新翻阅文档再配置一遍 Mac 吗。为了省去之后再次查资料的麻烦，这里写一篇记录文。</p>
<a id="more"></a>
<h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p><code>Homebrew</code> 可以说是每台 Mac 必备的包管理工具了。因为官方的源经常连接不上，因此可用镜像安装方式来安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 中科大的源</span></span><br><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)</span>"</span></span><br></pre></td></tr></table></figure>
<p>如果中间 <code>homebrew-core</code> 安装不上，则先终止安装，然后执行下述操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入安装目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>/Library/Taps/"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 homebrew 目录</span></span><br><span class="line">mkdir homebrew &amp;&amp; <span class="built_in">cd</span> homebrew</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆 homebrew-core 仓库</span></span><br><span class="line">git <span class="built_in">clone</span> git://mirrors.ustc.edu.cn/homebrew-core.git</span><br></pre></td></tr></table></figure>
<p>克隆完成后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果想换源可查看参考文档或自行查询相关文档。</p>
</blockquote>
<h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><p>git 在大多数情况下都会用到，因此优先安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 git</span></span><br><span class="line">git config --global user.name <span class="string">"你的名字"</span></span><br><span class="line">git config --global user.email <span class="string">"你的邮箱"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 ssh key（一直回车即可）</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"你的邮箱"</span></span><br></pre></td></tr></table></figure>
<h3 id="配置-vim"><a href="#配置-vim" class="headerlink" title="配置 vim"></a>配置 vim</h3><p>因为后续的配置需要用到 vim，因此我们先配置一下 vim，让编辑得更舒服。</p>
<p>创建一个 .vimrc 文件，在内部加上如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">syntax on                <span class="string">" 设置高亮</span></span><br><span class="line"><span class="string">set number               "</span> 默认显示行号</span><br><span class="line"><span class="built_in">set</span> ruler                <span class="string">" 显示标尺</span></span><br><span class="line"><span class="string">set expandtab            "</span> 空格代替 Tab</span><br><span class="line"><span class="built_in">set</span> tabstop=2            <span class="string">" Tab 键宽为 2</span></span><br><span class="line"><span class="string">set nobackup             "</span> 不生成临时文件</span><br><span class="line"><span class="built_in">set</span> noeb                 <span class="string">" 在处理未保存或只读文件的时候，弹出确认</span></span><br><span class="line"><span class="string">set scrolloff=3          "</span> 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line"><span class="built_in">set</span> mouse=a              <span class="string">" 内部滚动</span></span><br><span class="line"><span class="string">"</span> 语言设置</span><br><span class="line"><span class="built_in">set</span> langmenu=zh_CN.UTF-8</span><br><span class="line"><span class="built_in">set</span> helplang=cn</span><br><span class="line"><span class="string">" 主题设置</span></span><br><span class="line"><span class="string">set background=dark</span></span><br><span class="line"><span class="string">colorscheme solarized</span></span><br></pre></td></tr></table></figure>
<p>主题部分需要安装对应的包，操作如下（如果有则忽略）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建 .vim/colors 文件夹（有则跳过）</span></span><br><span class="line">mkdir -p ~/.vim/colors</span><br><span class="line"><span class="comment"># 进入文件夹</span></span><br><span class="line"><span class="built_in">cd</span> ~/.vim/colors</span><br><span class="line"><span class="comment"># 克隆主题并拷贝出来</span></span><br><span class="line">git <span class="built_in">clone</span> git://github.com/altercation/vim-colors-solarized.git</span><br><span class="line">cp vim-colors-solarized/colors/solarized.vim ~/.vim/colors/</span><br><span class="line"><span class="comment"># 删除仓库</span></span><br><span class="line">rm -rf vim-colors-solarized</span><br></pre></td></tr></table></figure>
<h3 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h3><p>同样 <code>oh-my-zsh</code> 官方版容易挂，这里仍然记录的是镜像版的安装方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换 shell 为 zsh（重新打开后生效）</span></span><br><span class="line">chsh -s /bin/zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 oh-my-zsh 镜像</span></span><br><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure>
<p>默认的 zsh 貌似仅有 git 插件，主题也不怎么好看，这里先改改 <code>~/.zshrc</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个 .bashrc 文件</span></span><br><span class="line">touch ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改 ~/.zshrc</span></span><br><span class="line"><span class="comment">## 主题部分设置</span></span><br><span class="line">ZSH_THEME=<span class="string">"pygmalion"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 插件部分的设置</span></span><br><span class="line">plugins=(git zsh-syntax-highlighting zsh-autosuggestions)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 最后一行添加上（附带启动执行的文件）</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>配置完了，然后是下载插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入自定义插件目录</span></span><br><span class="line"><span class="built_in">cd</span> ~/.oh-my-zsh/custom/plugins</span><br><span class="line"><span class="comment"># 拷贝插件</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br></pre></td></tr></table></figure>
<h3 id="配置-iterm"><a href="#配置-iterm" class="headerlink" title="配置 iterm"></a>配置 iterm</h3><p>下载 <code>solarized</code> 主题，<a href="http://ethanschoonover.com/solarized/files/solarized.zip" target="_blank" rel="noopener">下载链接</a>，这里我创建了一个 Custom 文件夹，解压缩在里边，然后进入 <code>oxs-terminal.app-colors-solarized</code> 文件夹，安装对应的俩 <code>.terminal</code> 主题（双击运行即可）。</p>
<p><img data-src="/images/iterm-theme.png" alt="item-theme"></p>
<blockquote>
<p>安装完后下载的主题可以删掉了</p>
</blockquote>
<p>打开 <code>iTerm2 -&gt; Preferences</code>，分别配置三处地方（Colors、Text、Window）</p>
<ul>
<li><code>Colors 部分</code>：配置主题色为 solarized dark</li>
<li><code>Text 部分</code>：设置字体 Font 大小</li>
<li><code>Window 部分</code>：设置 Transparent 背景透明度</li>
</ul>
<p><img data-src="/images/iterm-config.png" alt="item-config"></p>
<blockquote>
<p>一般设置前俩就够了，Window 主要配置 <code>transparence</code> 来控制背景透明度。</p>
</blockquote>
<h3 id="配置-nvm"><a href="#配置-nvm" class="headerlink" title="配置 nvm"></a>配置 nvm</h3><p>配置 node 环境这里选用 nvm 来控制，这样方便 node 版本快速切换，Mac 的安装方式很简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install nvm</span><br></pre></td></tr></table></figure>
<p>nvm 安装完后，通过 <code>nvm ls-remote v12</code> 来看云上 12 版本 node 有哪些，安装最新维护版本的 node 即可（其余版本同理）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装 node</span><br><span class="line">nvm install v12.18.3</span><br><span class="line"></span><br><span class="line"># 取个别名方便查找</span><br><span class="line">nvm alias node12 v12.18.3</span><br><span class="line"></span><br><span class="line"># 使用 node12</span><br><span class="line">nvm use node12</span><br></pre></td></tr></table></figure>
<p>此外，部分全局安装的包这里列举一下：</p>
<ul>
<li>yarn（通过 yarn 安装全局包就不用担心 node 切换后找不到包）</li>
<li>nrm（换 npm 源比较方便）</li>
<li>pm2（守护进程）</li>
</ul>
<h3 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h3><p>使用万能的 brew 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 nginx</span></span><br><span class="line">brew install nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">brew services start nginx</span><br></pre></td></tr></table></figure>
<p>附带一些 nginx 的默认配置地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># brew 安装 nginx 的路径</span></span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/nginx/1.6.2</span><br><span class="line"><span class="comment"># 配置文件路径</span></span><br><span class="line">/usr/<span class="built_in">local</span>/etc/nginx/nginx.conf</span><br><span class="line"><span class="comment"># 服务器默认路径</span></span><br><span class="line">/usr/<span class="built_in">local</span>/var/www</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为层级比较深，建议还是用 <code>ln -s</code> 软链出来，统一管理会更为方便</p>
</blockquote>
<h3 id="常用工具推荐"><a href="#常用工具推荐" class="headerlink" title="常用工具推荐"></a>常用工具推荐</h3><p>除了环境外我们还需要一些办公工具，这里列举一些：</p>
<ul>
<li>Vscode</li>
<li>Numi（自然语言计算器）</li>
<li>Chrome</li>
<li>Navicat</li>
<li>Agenda（我比较喜欢的 todoList 软件）</li>
<li>WPS</li>
<li>XMind</li>
<li>Transmit（连接服务器的文件传输工具）</li>
<li>Alfred4（高配聚焦）</li>
<li>Postman</li>
<li>Typora（markdown 写作工具）</li>
<li>Github Desctop</li>
<li>rdm（redis 连接工具）</li>
<li>StarUML（流程图）</li>
<li>Omniplan（排期工具）</li>
<li>OneNote 或 有道云笔记</li>
<li>V2Rayx（科学上网需要）</li>
<li>Scroll Reverser（外接鼠标滚轮方向配置）</li>
<li>Axure（看产品原型图必备）</li>
</ul>
<h3 id="配置-VSCode"><a href="#配置-VSCode" class="headerlink" title="配置 VSCode"></a>配置 VSCode</h3><p>通过 Sync 同步我个人的配置，这里记录 Sync 的配置，后续只需通过 gist 拉取即可</p>
<ol>
<li><code>Command/Ctrl + Shift + P</code> 调出控制台</li>
<li>输入 <code>Sync</code></li>
<li>选择 <code>Sync 高级选项</code></li>
<li>选择 <code>从公开 Gist 下载配置</code></li>
<li>点击 <code>Code -&gt; Preference -&gt; Settings</code> 进入配置页面</li>
<li>输入 <code>Sync</code> 并找到 <code>Gist</code>，然后输入 Gist ID 为 <code>0e7fde6e07ce3d8a9947880187fe5a3f</code></li>
<li>取消勾选 <code>Remove Extensions</code>，但需要勾选上 <code>Sync Extensions</code>（否则原有插件消失概不负责）</li>
<li><code>Shift + Option + D</code> 下载插件即可</li>
</ol>
<blockquote>
<p>之后 <code>settings.json</code> 的配置文件可以根据具体情况来修改，建议配合项目的 <code>.vscode/settings.json</code> 来更好的配置项目。</p>
</blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://blog.csdn.net/TH_NUM/article/details/107371088" target="_blank" rel="noopener">Mac下镜像安装 Homebrew</a></li>
<li><a href="https://www.cnblogs.com/zourrou/archive/2011/04/16/2018493.html" target="_blank" rel="noopener">很好很强大的vimrc（带注释版）</a></li>
<li><a href="https://www.cnblogs.com/heqiuyu/articles/7519803.html" target="_blank" rel="noopener">给vim配置 solarized 主题颜色</a></li>
<li><a href="https://www.cnblogs.com/monsterdev/p/11166720.html" target="_blank" rel="noopener">Oh-My-Zsh 的配置与使用</a></li>
<li><a href="https://blog.csdn.net/thatway_wp/article/details/79442177" target="_blank" rel="noopener">mac下 iterm 配色、半透明与样式设置</a></li>
</ul>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Env</tag>
      </tags>
  </entry>
  <entry>
    <title>React 代码规范配置</title>
    <url>/2020/03/29/React-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近开始初步学习 React 的一些知识，毕竟宅家这么久，总得开始学习学习新的内容了。“工欲善其事，必先利其器”，因此今天主要是配置 VSCode 的 React 支持，折腾来折腾去，核心的配置大概就如文中所示了。</p>
<a id="more"></a>
<h3 id="插件依赖"><a href="#插件依赖" class="headerlink" title="插件依赖"></a>插件依赖</h3><ul>
<li>Prettier （格式化插件）</li>
<li>ESlint（格式化插件）</li>
<li>ES7 React/Redux/GraphQL/React-Native snippets (快捷指令)</li>
</ul>
<blockquote>
<p><strong>注：</strong> 此处为一些必须安装的插件，安装后配置才会生效</p>
</blockquote>
<h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>VSCode 有整体的 setting.json 配置和单项目配置，个人还是推荐单项目配置，毕竟自己的开发器可能开发不仅仅就一种语言的吧，因此还是建立如下文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--</span><br><span class="line">|- .vscode</span><br><span class="line">      |- settings.json</span><br></pre></td></tr></table></figure>
<p>然后 settings.json 内配置内容为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 编辑器部分</span></span><br><span class="line">  <span class="attr">"editor.tabSize"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"editor.wordWrap"</span>: <span class="string">"on"</span>,</span><br><span class="line">  <span class="attr">"editor.formatOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"editor.renderWhitespace"</span>: <span class="string">"none"</span>,</span><br><span class="line">  <span class="attr">"editor.multiCursorModifier"</span>: <span class="string">"ctrlCmd"</span>,</span><br><span class="line">  <span class="attr">"editor.defaultFormatter"</span>: <span class="string">"esbenp.prettier-vscode"</span>, <span class="comment">// 默认启用的代码格式化插件</span></span><br><span class="line">  <span class="attr">"files.insertFinalNewline"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 代码配置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// eslint 部分</span></span><br><span class="line">  <span class="attr">"eslint.run"</span>: <span class="string">"onSave"</span>,</span><br><span class="line">  <span class="attr">"eslint.format.enable"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"editor.codeActionsOnSave"</span>: &#123;</span><br><span class="line">    <span class="attr">"source.fixAll.eslint"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"eslint.validate"</span>: [</span><br><span class="line">    <span class="string">"typescriptreact"</span>,</span><br><span class="line">    <span class="string">"typescript"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="样式文件配置"><a href="#样式文件配置" class="headerlink" title="样式文件配置"></a>样式文件配置</h3><p>因为项目使用的是 prettier 格式化插件，因此我们需要在根目录创建一个 .prettierrc 的文件，然后粘贴一下内容（从 ant design 拷贝过来的，之后根据使用习惯再做修改）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"singleQuote"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"trailingComma"</span>: <span class="string">"all"</span>,</span><br><span class="line">  <span class="attr">"printWidth"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">"proseWrap"</span>: <span class="string">"never"</span>,</span><br><span class="line">  <span class="attr">"arrowParens"</span>: <span class="string">"avoid"</span>,</span><br><span class="line">  <span class="attr">"overrides"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"files"</span>: <span class="string">".prettierrc"</span>,</span><br><span class="line">      <span class="attr">"options"</span>: &#123;</span><br><span class="line">        <span class="attr">"parser"</span>: <span class="string">"json"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Env</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 的小技巧</title>
    <url>/2020/06/09/Mysql-%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近期开始学习 Node 和 MySQL 相关的知识了，项目也开始从纯前端转向了“全栈”（刚刚起步）。起初还是挺痛苦的，特别是数据库设计和查询，大学学习的东西基本都还回去了，不过在一次次问题中也渐渐总结了些经验，这里就记录一下“初学者”难免会遇到的一些问题。</p>
<a id="more"></a>
<h3 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h3><p>其实先处理模型，然后再根据模型建库和表，基本上没什么太大问题（毕竟都是可视化操作，不写 SQL 代码生成了）。不过，在可视化建表的过程中，有时候为了图快往往容易忽视一些配置，如：</p>
<ul>
<li>int 的默认值部分配置</li>
</ul>
<p><img data-src="/images/mysql-int-type.jpg" alt="int 类型"></p>
<ul>
<li>datetime 默认值部分配置</li>
</ul>
<p><img data-src="/images/mysql-datetime-type.jpg" alt="datetime 类型"></p>
<p>根据情况配置对应默认值可以减少代码内的部分重复操作，如：</p>
<ul>
<li>配置 <code>create_time</code> 默认值为 <code>CURRENT_TIMESTAMP</code>， 那么每次新增时就可以不用带上时间戳了。</li>
<li>配置 <code>modify_time</code> 默认值勾选上 “根据当前时间戳更新”，那么每次编辑时可以不用去配置修改时间，对于重复数据操作会比较方便。</li>
</ul>
<h3 id="日期更新"><a href="#日期更新" class="headerlink" title="日期更新"></a>日期更新</h3><p>当然，也有情况是需要在进行某些操作后，更新其它数据的一些信息，这之中比较麻烦的是“日期”相关的操作，在网上也没找到比较合适的博文来解决。这里在翻查了 Mysql 的一些函数，顺利解决了这么一个问题，修改数据时间的 <code>sql</code> 为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> xxx_table</span><br><span class="line"><span class="keyword">set</span> xxx_time = <span class="keyword">CURRENT_TIMESTAMP</span>()</span><br><span class="line"><span class="keyword">where</span> xxx_id = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>配合 <code>mysql</code> 的时间函数能比较方便的处理时间相关的操作。</p>
<h3 id="ALTER-和-UPDATE-区别"><a href="#ALTER-和-UPDATE-区别" class="headerlink" title="ALTER 和 UPDATE 区别"></a>ALTER 和 UPDATE 区别</h3><p>最开始写 <code>sql</code> 时，总是习惯性的使用 <code>ALTER</code>，毕竟是 <code>ALTER</code> 是修改的意思嘛。实际上这两个区别很大，<code>ALTER</code> 是修改表结构的，而 <code>UPDATE</code> 是更新表数据信息的。因此在平时对数据进行 CRUD 时，记住使用 <code>UPDATE</code> 即可。这里记录一下：</p>
<ul>
<li><code>ALTER</code>、<code>DROP</code> 是结构上的更新和删除</li>
<li><code>UPDATE</code>、<code>DELETE</code> 是数据上的更新和删除</li>
</ul>
<h3 id="group-concat-的长度限制"><a href="#group-concat-的长度限制" class="headerlink" title="group_concat 的长度限制"></a><code>group_concat</code> 的长度限制</h3><p>在做函数聚合处理时，会经常使用到 <code>group_concat</code> 函数对字段进行聚合，但是 mysql 默认对聚合的字串设有长度限制（没记错的话应该是 1024）,这会导致在取值的时候对于比较长的字段就直接被截取掉了，还比较难发现问题。</p>
<p>对于自己的数据库，我们可以使用如下命令查看默认长度：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'group_concat_max_len'</span>;</span><br></pre></td></tr></table></figure>
<p>如果要修改其长度限制的话，有两种方法：</p>
<p><strong>（1）更改 Mysql 配置文件</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在配置文件中加入如下内容：</span><br><span class="line">group_concat_max_len = 1024000</span><br></pre></td></tr></table></figure></p>
<p><strong>（2）在 Navicat 内运行如下命令</strong><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> group_concat_max_len = <span class="number">1024000</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> group_concat_max_len = <span class="number">1024000</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意： 该方法缺点是重启服务后设置失效</p>
</blockquote>
<h3 id="mysql-连接阻塞问题"><a href="#mysql-连接阻塞问题" class="headerlink" title="mysql 连接阻塞问题"></a>mysql 连接阻塞问题</h3><p>最近遇到搭建的测试环境报错，查看日志发现是 mysql 的 max_connect_errors 报错导致服务器 ip 被禁止连接 mysql。但是自己通过 navcat 能够连接上数据库，查了下原因，发现应该是中间有一版本的代码部署后，node 代码数据库连接部分配置失误，导致错误连接数过大，ip 被禁止连接 mysql 了，针对不同情况有不同的解决方法，这里都列举出来：</p>
<h4 id="max-connect-errors-值过小，容易出错"><a href="#max-connect-errors-值过小，容易出错" class="headerlink" title="max_connect_errors 值过小，容易出错"></a>max_connect_errors 值过小，容易出错</h4><p>通过 navicat 连接上 mysql，查询一下 mysql 的 <code>max_connect_errors</code> 属性是否值过小，较小时代码更新过程中容易产生 max_connect_errors 错误导致 mysql 连接不上，查询并更新方法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询连接数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%max_connect_errors%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置连接数</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> max_connect_errors = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<h4 id="累计连接错误数超出"><a href="#累计连接错误数超出" class="headerlink" title="累计连接错误数超出"></a>累计连接错误数超出</h4><p>如果查询到的 <code>max_connect_errors</code> 数值已经比较大了，但是仍然报 <code>max_connect_errors</code> 超出的错误，那么应该是 mysql 的错误连接累计数量超出了，此时需要清空一下 <code>max_connect_errors</code> 数，在 navicat 的查询中输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">hosts</span>;</span><br></pre></td></tr></table></figure>
<h4 id="mysql-的-max-connect-errors-重启后变小"><a href="#mysql-的-max-connect-errors-重启后变小" class="headerlink" title="mysql 的 max_connect_errors 重启后变小"></a>mysql 的 <code>max_connect_errors</code> 重启后变小</h4><p>因为 mysql 重启后会重新读取 mysql 的 conf 文件，如果不想每次重启 mysql 都需要重新更改 <code>max_connect_errors</code> 数值，那么需要修改一下 my.cnf 文件，将一下内容的值改改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max_connect_errors = 1000</span><br></pre></td></tr></table></figure>
<h3 id="insert-数据重复问题"><a href="#insert-数据重复问题" class="headerlink" title="insert 数据重复问题"></a>insert 数据重复问题</h3><p>在插入数据时，有时候会碰到插入的数据重复，因此可以使用 <code>insert ... update ...</code> 语句来进行插入/更新。</p>
<p>使用语法大致如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> target_table(unique_col1, col2, col3)</span><br><span class="line"><span class="keyword">values</span> (val1, valb, valc), (val1, val2, val3)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span></span><br><span class="line">  col2 = <span class="keyword">values</span>(col2),</span><br><span class="line">  col3 = <span class="keyword">values</span>(col3)</span><br></pre></td></tr></table></figure>
<p>意思可理解为这样：</p>
<ul>
<li>当插入的 unique_col1 值不存在时，进行新增操作，其值分别对应为：(val1、val2、val3)</li>
<li>当插入的 unique_col1 值存在时，进行更新操作，分别更新 col2 和 col3 的值为传入 values 组对应的 val2 和 val3</li>
</ul>
<blockquote>
<p>注意，唯一值重复时，后面的数据会覆盖前面的数据内容（即只取最新数据）</p>
</blockquote>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://www.runoob.com/mysql/mysql-functions.html" target="_blank" rel="noopener">MySQL 函数</a></li>
<li><a href="https://blog.csdn.net/weixin_39469127/article/details/93768427" target="_blank" rel="noopener">MySQL中 insert into … on duplicate key update … values() 的使用笔记</a></li>
</ul>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 代码规范配置</title>
    <url>/2019/08/23/Vue-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>工欲善其事，必先利其器。一个好的规范能使的团队开发的效率提升一倍，因此，一个好的规范对于一个团队来说是必不可少的。此处记录我为所在团队维护的一套前端规范相关的配置。</p>
<a id="more"></a>
<h3 id="VSCode-配置"><a href="#VSCode-配置" class="headerlink" title="VSCode 配置"></a>VSCode 配置</h3><p>在项目根目录下新建一个 .vscode 文件夹，然后在该文件内创建一个 settings.json 文件，粘贴以下内容即可：</p>
<blockquote>
<p>注意：该部分配置需要安装两个必须的 VSCode 插件： Vetur 和 ESLint。</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 编辑器部分</span></span><br><span class="line">  <span class="attr">"editor.tabSize"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"editor.fontSize"</span>: <span class="number">15</span>,</span><br><span class="line">  <span class="attr">"editor.wordWrap"</span>: <span class="string">"on"</span>,</span><br><span class="line">  <span class="attr">"editor.formatOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"editor.renderWhitespace"</span>: <span class="string">"none"</span>,</span><br><span class="line">  <span class="attr">"editor.multiCursorModifier"</span>: <span class="string">"ctrlCmd"</span>,</span><br><span class="line">  <span class="attr">"editor.defaultFormatter"</span>: <span class="string">"octref.vetur"</span>,</span><br><span class="line">  <span class="attr">"editor.codeActionsOnSave"</span>: &#123;</span><br><span class="line">    <span class="attr">"source.fixAll"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"files.insertFinalNewline"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 代码配置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// eslint 部分</span></span><br><span class="line">  <span class="attr">"eslint.run"</span>: <span class="string">"onSave"</span>,</span><br><span class="line">  <span class="attr">"eslint.validate"</span>: [</span><br><span class="line">    <span class="string">"typescriptreact"</span>,</span><br><span class="line">    <span class="string">"typescript"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// vetur 部分</span></span><br><span class="line">  <span class="attr">"vetur.format.defaultFormatter.css"</span>: <span class="string">"prettier"</span>,</span><br><span class="line">  <span class="attr">"vetur.format.defaultFormatter.less"</span>: <span class="string">"prettier"</span>,</span><br><span class="line">  <span class="attr">"vetur.format.defaultFormatter.js"</span>: <span class="string">"vscode-typescript"</span>,</span><br><span class="line">  <span class="attr">"vetur.format.defaultFormatter.ts"</span>: <span class="string">"vscode-typescript"</span>,</span><br><span class="line">  <span class="attr">"vetur.format.defaultFormatter.html"</span>: <span class="string">"prettyhtml"</span>,</span><br><span class="line">  <span class="attr">"vetur.format.defaultFormatterOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"prettyhtml"</span>: &#123;</span><br><span class="line">      <span class="attr">"printWidth"</span>: <span class="number">75</span>,</span><br><span class="line">      <span class="attr">"singleQuote"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ESlint-配置"><a href="#ESlint-配置" class="headerlink" title="ESlint 配置"></a>ESlint 配置</h3><p>此处配置的 ESlint 为 TS 环境下的 typescript-eslint 的配置。配置文件为：<code>.eslintrc.js</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  root: <span class="literal">true</span>,</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    commonjs: <span class="literal">true</span>,</span><br><span class="line">    es6: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    parser: <span class="string">'@typescript-eslint/parser'</span>,</span><br><span class="line">    sourceType: <span class="string">'module'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  extends: [</span><br><span class="line">    <span class="string">'plugin:vue/essential'</span>,</span><br><span class="line">    <span class="string">'@vue/standard'</span>,</span><br><span class="line">    <span class="string">'@vue/typescript'</span>,</span><br><span class="line">  ],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'no-var'</span>: <span class="string">'error'</span>,</span><br><span class="line">    <span class="string">'arrow-parens'</span>: <span class="string">'off'</span>,</span><br><span class="line">    <span class="string">"semi"</span>: <span class="string">"off"</span>,</span><br><span class="line">    <span class="string">"@typescript-eslint/semi"</span>: [<span class="string">"error"</span>],</span><br><span class="line">    <span class="string">'eol-last'</span>: <span class="string">'off'</span>,</span><br><span class="line">    <span class="string">'@typescript-eslint/no-unused-vars'</span>: [</span><br><span class="line">      <span class="string">'error'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        vars: <span class="string">'local'</span>,</span><br><span class="line">        args: <span class="string">'none'</span>,</span><br><span class="line">        ignoreRestSiblings: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'generator-star-spacing'</span>: <span class="string">'off'</span>,</span><br><span class="line">    <span class="string">'camelcase'</span>: [<span class="string">'error'</span>, &#123; <span class="attr">properties</span>: <span class="string">'never'</span> &#125;],</span><br><span class="line">    <span class="string">'space-before-function-paren'</span>: [<span class="string">'error'</span>, &#123; <span class="attr">anonymous</span>: <span class="string">'always'</span>, <span class="attr">named</span>: <span class="string">'never'</span> &#125;],</span><br><span class="line">    <span class="string">'no-console'</span>: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'error'</span> : <span class="string">'off'</span>,</span><br><span class="line">    <span class="string">'no-debugger'</span>: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'error'</span> : <span class="string">'off'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="tsconfig-json-配置"><a href="#tsconfig-json-配置" class="headerlink" title="tsconfig.json 配置"></a>tsconfig.json 配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"."</span>,</span><br><span class="line">    <span class="string">"checkJs"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"esModuleInterop"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"importHelpers"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"jsx"</span>: <span class="string">"preserve"</span>,</span><br><span class="line">    <span class="string">"jsxFactory"</span>: <span class="string">"h"</span>,</span><br><span class="line">    <span class="string">"lib"</span>: [</span><br><span class="line">      <span class="string">"esnext"</span>,</span><br><span class="line">      <span class="string">"dom"</span>,</span><br><span class="line">      <span class="string">"dom.iterable"</span>,</span><br><span class="line">      <span class="string">"scripthost"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"esnext"</span>,</span><br><span class="line">    <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">    <span class="string">"paths"</span>: &#123;</span><br><span class="line">      <span class="string">"@/*"</span>: [</span><br><span class="line">        <span class="string">"src/*"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"pretty"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"esnext"</span>,</span><br><span class="line">    <span class="string">"types"</span>: [</span><br><span class="line">      <span class="string">"webpack-env"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"include"</span>: [</span><br><span class="line">    <span class="string">"src/**/*.ts"</span>,</span><br><span class="line">    <span class="string">"src/**/*.tsx"</span>,</span><br><span class="line">    <span class="string">"src/**/*.vue"</span>,</span><br><span class="line">    <span class="string">"tests/**/*.ts"</span>,</span><br><span class="line">    <span class="string">"tests/**/*.tsx"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"exclude"</span>: [</span><br><span class="line">    <span class="string">"node_modules"</span>,</span><br><span class="line">    <span class="string">"public"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关依赖（项目由非 TS -&gt; TS）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"@babel/core"</span>: <span class="string">"^7.0.0-0"</span>,</span><br><span class="line">    <span class="attr">"@babel/plugin-syntax-jsx"</span>: <span class="string">"^7.2.0"</span>,</span><br><span class="line">    <span class="attr">"@vue/cli-plugin-babel"</span>: <span class="string">"^3.7.0"</span>,</span><br><span class="line">    <span class="attr">"@vue/cli-plugin-eslint"</span>: <span class="string">"^3.0.5"</span>,</span><br><span class="line">    <span class="attr">"@vue/cli-plugin-typescript"</span>: <span class="string">"^3.8.1"</span>,</span><br><span class="line">    <span class="attr">"@vue/cli-service"</span>: <span class="string">"^3.0.5"</span>,</span><br><span class="line">    <span class="attr">"@vue/eslint-config-standard"</span>: <span class="string">"^4.0.0"</span>,</span><br><span class="line">    <span class="attr">"@vue/eslint-config-typescript"</span>: <span class="string">"^4.0.0"</span>,</span><br><span class="line">    <span class="attr">"babel-eslint"</span>: <span class="string">"^10.0.1"</span>,</span><br><span class="line">    <span class="attr">"eslint"</span>: <span class="string">"^5.8.0"</span>,</span><br><span class="line">    <span class="attr">"eslint-plugin-vue"</span>: <span class="string">"^5.0.0-0"</span>,</span><br><span class="line">    <span class="attr">"typescript"</span>: <span class="string">"^3.4.3"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Stylelint-配置"><a href="#Stylelint-配置" class="headerlink" title="Stylelint 配置"></a>Stylelint 配置</h3><p>此部分规范 css 和 less 语法，配置文件为： <code>stylelint.config.js</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: <span class="string">'stylelint-config-standard'</span>,</span><br><span class="line">  ignoreFiles: [</span><br><span class="line">    <span class="string">'**/*.js'</span>,</span><br><span class="line">    <span class="string">'**/*.md'</span>,</span><br><span class="line">    <span class="string">'**/*.png'</span>,</span><br><span class="line">    <span class="string">'**/*.json'</span></span><br><span class="line">  ],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'indentation'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'color-hex-case'</span>: <span class="string">'lower'</span>,</span><br><span class="line">    <span class="string">'string-quotes'</span>: <span class="string">'single'</span>,</span><br><span class="line">    <span class="string">'color-hex-length'</span>: <span class="string">'long'</span>,</span><br><span class="line">    <span class="string">'number-leading-zero'</span>: <span class="string">'never'</span>,</span><br><span class="line">    <span class="string">'rule-empty-line-before'</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'no-descending-specificity'</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'no-missing-end-of-source-newline'</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">'selector-pseudo-element-colon-notation'</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'selector-list-comma-newline-after'</span>: <span class="string">'always-multi-line'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相关依赖：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"stylelint"</span>: <span class="string">"^10.1.0"</span>,</span><br><span class="line">    <span class="attr">"stylelint-config-standard"</span>: <span class="string">"^18.3.0"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="规范参考"><a href="#规范参考" class="headerlink" title="规范参考"></a>规范参考</h3><ul>
<li><a href="http://alloyteam.github.io/CodeGuide/" target="_blank" rel="noopener">Code Guide</a></li>
<li><a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">风格指南</a></li>
</ul>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Env</tag>
      </tags>
  </entry>
  <entry>
    <title>git 环境配置</title>
    <url>/2019/03/31/git-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>git 的环境安装已经有很多次了，虽然简单，但是文章的重点却并不在此，此篇是用来记录学习 git 的一些好的规范、方便的工具、常用的命令以及遇到的坑。</p>
<a id="more"></a>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="下载安装-git"><a href="#下载安装-git" class="headerlink" title="下载安装 git"></a>下载安装 git</h4><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git 下载地址</a></p>
<h4 id="git-环境配置"><a href="#git-环境配置" class="headerlink" title="git 环境配置"></a>git 环境配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置用户名</span></span><br><span class="line">git config --global user.name <span class="string">"yourname"</span></span><br><span class="line"><span class="comment"># 设置邮箱</span></span><br><span class="line">git config --global user.email <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></table></figure>
<h4 id="git-commit-规范"><a href="#git-commit-规范" class="headerlink" title="git commit 规范"></a>git commit 规范</h4><p>用于说明 commit 的类型只允许一下 7 种：</p>
<ul>
<li>feat：新功能（feature）</li>
<li>fix：修补bug</li>
<li>docs：文档（documentation）</li>
<li>style： 格式（不影响代码运行的变动）</li>
<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>
<li>test：增加测试</li>
<li>chore：构建过程或辅助工具的变动</li>
</ul>
<h4 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h4><p><img data-src="/images/git-command.jpg" alt="git命令"></p>
<h4 id="git-使用的一些问题总结"><a href="#git-使用的一些问题总结" class="headerlink" title="git 使用的一些问题总结"></a>git 使用的一些问题总结</h4><h5 id="如何取消文件跟踪"><a href="#如何取消文件跟踪" class="headerlink" title="如何取消文件跟踪"></a>如何取消文件跟踪</h5><p><code>.gitignore</code> 文件会忽略其中记录的文件，不对其进行状态跟踪，但是对于已经跟踪的文件（即先前未添加至该文件内，后期再加入的）即使之后将其加入此 <code>.gitignore</code> 文件也不生效。</p>
<p>原因： git 缓存使其继续追踪</p>
<p>解决方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 单文件</span><br><span class="line">git rm --cache &lt;fileName&gt;</span><br><span class="line"></span><br><span class="line">## 全部</span><br><span class="line">git rm --cache .</span><br></pre></td></tr></table></figure></p>
<h5 id="本地远程-tag-版本冲突问题"><a href="#本地远程-tag-版本冲突问题" class="headerlink" title="本地远程 tag 版本冲突问题"></a>本地远程 tag 版本冲突问题</h5><p>当自己打的 tag 标签与远程 tag 标签不同步时，无法正常使用 git pull –tags，此会报错提示 xxx 版本的 tag 本地与远程不统一，此 tag 拒绝被拉取覆盖（不影响其余的 tag），这回造成 VSCode 编辑器的 git 插件无法正常使用。</p>
<p>解决方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull --tags -p -f</span><br><span class="line">## 补充</span><br><span class="line">本次仅做了强制本地覆盖并合并 tags</span><br><span class="line">git fetch --tags -h 有对应的指令详细说明</span><br></pre></td></tr></table></figure></p>
<h3 id="git-学习推荐"><a href="#git-学习推荐" class="headerlink" title="git 学习推荐"></a>git 学习推荐</h3><ul>
<li><a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">可视化学习 git</a></li>
</ul>
<h3 id="相关引用"><a href="#相关引用" class="headerlink" title="相关引用"></a>相关引用</h3><blockquote>
<p>git 命令图片源自 <a href="https://github.com/DickyQie/Tool-use" target="_blank" rel="noopener">https://github.com/DickyQie/Tool-use</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables 端口转发配置</title>
    <url>/2020/07/14/iptables-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>先前转载了一篇 iptables 的使用和配置的文章，但是凡事都得自己动手学习一下才能深入了解，因此本篇用来记录动手操作了一番后的一些配置心得。当然建议大家了解的时候读一读参考文章，特别是 <code>iptables 入门指南</code> 和 <code>iptables 详解</code>，能让你对 iptables 有更深入的理解。</p>
<a id="more"></a>
<h3 id="查看本地规则"><a href="#查看本地规则" class="headerlink" title="查看本地规则"></a>查看本地规则</h3><p>root 用户下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -nL -t nat --line-number</span><br></pre></td></tr></table></figure>
<p>显示结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@/]<span class="comment"># iptables -nL -t nat</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">REDIRECT   tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 redir ports 8020</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">REDIRECT   tcp  --  0.0.0.0/0            127.0.0.1            tcp dpt:80 redir ports 8020</span><br><span class="line">REDIRECT   tcp  --  0.0.0.0/0            &lt;本机IP&gt;       tcp dpt:80 redir ports 8020</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br></pre></td></tr></table></figure>
<p>其中 <code>Chain PREROUTING (policy ACCEPT)</code> 指的是有外部访问本机的 80 端口时，其会转发到 8020 端口；<code>Chain OUTPUT (policy ACCEPT)</code> 指的是内部机器地址输出时，当监测到目标地址为 <code>127.0.0.1</code> / <code>&lt;本机IP&gt;</code> 时，其默认的 80 端口会转发到 8020 端口，从而实现 80 -&gt; 8020 端口的转发。</p>
<h3 id="添加转发规则"><a href="#添加转发规则" class="headerlink" title="添加转发规则"></a>添加转发规则</h3><h4 id="外部访问端口转发"><a href="#外部访问端口转发" class="headerlink" title="外部访问端口转发"></a>外部访问端口转发</h4><p>iptables 转发端口时，其使用的并非默认的 filter，因此需要 -t 制定为 nat，此外上面有说到，外部访问时会经由 <code>PREROUTING</code>，因此需要对此规则做配置，指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8020</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-t</code>： 指定表为 nat 表（默认为 filter 表）</li>
<li><code>-A</code>： 指定 nat 表中的三项规则中的哪一项，分别为： <code>OUTPUT</code>、<code>PREROUTING</code>、<code>POSTEROUTING</code></li>
<li><code>-p</code>： 指定使用的协议</li>
<li><code>--dport</code>: 指定目标端口</li>
<li><code>-j</code>： 指定<strong>针对本机</strong>做重定向操作（DROP、ACCEPT、REDIRECT 等）</li>
<li><code>--to-port</code>： 重定向的端口</li>
</ul>
<blockquote>
<p>补充，不同表的操作链</p>
</blockquote>
<table>
<thead>
<tr>
<th>表</th>
<th>INPUT</th>
<th>FORWARD</th>
<th>OUTPUT</th>
<th>PREROUTING</th>
<th>POSTEROUTING</th>
</tr>
</thead>
<tbody>
<tr>
<td>Filter</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>Nat</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>Mangle</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
</tbody>
</table>
<h4 id="内部访问端口转发"><a href="#内部访问端口转发" class="headerlink" title="内部访问端口转发"></a>内部访问端口转发</h4><p>仅外部转发其实是不够的，对于内部地址访问时仍需要进行一次转发才能满足内外一致的情况，与上指令类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A OUTPUT -p tcp -d 127.0.0.1 --dport 80 -j REDIRECT --to-port 8020</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-d</code>： 指定目的地址地址（与之相反的 <code>-s</code> 为指定源地址）</li>
</ul>
<h3 id="删除转发规则"><a href="#删除转发规则" class="headerlink" title="删除转发规则"></a>删除转发规则</h3><p>删除指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables - t nat -D OUTPUT &lt;number&gt;</span><br></pre></td></tr></table></figure>
<h3 id="验证规则生效"><a href="#验证规则生效" class="headerlink" title="验证规则生效"></a>验证规则生效</h3><p><code>telnet ip port</code>： 查看某一个机器上的某一个端口是否可以访问，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet 127.0.0.1 8020</span><br></pre></td></tr></table></figure>
<h3 id="配置开机启动"><a href="#配置开机启动" class="headerlink" title="配置开机启动"></a>配置开机启动</h3><p>结合 <code>iptables-save</code> 和 <code>iptables-reload</code> 使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; /root/iptables.bk</span><br></pre></td></tr></table></figure>
<p>配置启动脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置启动脚本</span></span><br><span class="line">vim /root/iptables-preload</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 将如下内容贴入其中并保存</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/sbin/iptables-restore &lt; /root/iptables.up.rules</span><br><span class="line"><span class="comment">####</span></span><br><span class="line"></span><br><span class="line">chmod +x /root/iptables-preload</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 编辑 /etc/rc.local，添加如下内容</span></span><br><span class="line">/root/iptables-preload</span><br></pre></td></tr></table></figure>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://www.jianshu.com/p/58148d2d8416" target="_blank" rel="noopener">iptables 工具命令</a></li>
<li><a href="http://www.zsythink.net/archives/1199" target="_blank" rel="noopener">iptables 详解</a></li>
<li><a href="https://blog.csdn.net/zong596568821xp/article/details/102765801" target="_blank" rel="noopener">Linux之iptables端口转发（外网访问内网）</a></li>
<li><a href="https://www.cnblogs.com/liang2580/articles/8400140.html" target="_blank" rel="noopener">iptables 入门指南</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown 语法</title>
    <url>/2019/05/30/markdown-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于写文章时经常会用到 Markdown 语法，但是除了基础的 Markdown 语法外，hexo 还支持一些语法扩展，因此为了方便查找扩展语法，写此篇以做记录。</p>
<a id="more"></a>
<h3 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h3><h4 id="段落与换行"><a href="#段落与换行" class="headerlink" title="段落与换行"></a>段落与换行</h4><p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行（此便是段落）。</p>
<p>Markdown 中多个空格表示换行，除此外 <code>&lt;br /&gt;</code> 标签也表示换行（回车会处理成空格）。</p>
<blockquote>
<p>推荐的换行方式：两次回车，这样结构更清晰一些</p>
</blockquote>
<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>标题使用 <code>#</code> 表示其层级（还有下等号或横线的形式，单不推荐）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于 一、二、三级标题都有下划线，个人偏向从三级标题开始，下划线过多看区块划分不是很舒服。</p>
</blockquote>
<h4 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h4><p>区块引用只需要在没行前添加 <code>&gt;</code> 符号即可，可嵌套 markdown 语法，例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; &gt; 嵌套引用</span></span><br><span class="line"><span class="quote">&gt; **嵌套加粗**</span></span><br></pre></td></tr></table></figure>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><p>无序列表一般通过 <code>-</code>、<code>*</code> 或者 <code>+</code> 作为其语法，例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>项目一</span><br><span class="line"><span class="bullet">- </span>项目二</span><br><span class="line"><span class="bullet">- </span>项目三</span><br></pre></td></tr></table></figure>
<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>有序列表用 <code>阿拉伯数字</code> 来表示，例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>项目 A</span><br><span class="line"><span class="bullet">2. </span>项目 B</span><br><span class="line"><span class="bullet">3. </span>项目 C</span><br></pre></td></tr></table></figure>
<h5 id="列表段落"><a href="#列表段落" class="headerlink" title="列表段落"></a>列表段落</h5><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*   </span>This is a list item with two paragraphs.</span><br><span class="line"><span class="code">    &gt; This is the second paragraph in the list item.</span></span><br><span class="line"><span class="bullet">*   </span>Another item in the same list.</span><br></pre></td></tr></table></figure>
<h4 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h4><p>代码区块只要简单地缩进 4 个空格或是 1 个制表符就可以，此处推荐使用 ``` 来包裹代码块，如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">`` html</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>这是 html 代码<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">``</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：为了能展示代码块的写法，此处省略了一个 `</p>
</blockquote>
<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------</span><br></pre></td></tr></table></figure>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>表格写法稍微复杂一点，第二行中的 <code>:</code> 表示对齐方式，默认左对齐</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br></pre></td></tr></table></figure>
<h3 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h3><h4 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h4><p>链接的语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[中文提示](&lt;address&gt;)</span><br></pre></td></tr></table></figure>
<p>图片语法为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![中文提示](&lt;address&gt;)</span><br></pre></td></tr></table></figure>
<h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><p>Markdown 使用双星号（*）或双底线（_）作为标记强调字词的符号，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**强调部分**</span><br></pre></td></tr></table></figure>
<h4 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h4><p>Markdown 使用单星号（*）或双底线（_）作为标记强调字词的符号，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体部分*</span><br></pre></td></tr></table></figure>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h4><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，如 <code>*</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\*literal asterisks\*</span><br></pre></td></tr></table></figure>
<h3 id="拓展语法"><a href="#拓展语法" class="headerlink" title="拓展语法"></a>拓展语法</h3><h4 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% quote David Levithan, Wide Awake %&#125;</span><br><span class="line">Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</span><br><span class="line">&#123;% endquote %&#125;</span><br></pre></td></tr></table></figure>
<blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p>
<footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote>
<h4 id="居中引用"><a href="#居中引用" class="headerlink" title="居中引用"></a>居中引用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% cq User Name%&#125;</span><br><span class="line">  This is a center quoet list</span><br><span class="line">&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>This is a center quoet list</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h4 id="笔记块"><a href="#笔记块" class="headerlink" title="笔记块"></a>笔记块</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">  Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>Any content (support inline tags too.io).</p>
          </div>
<blockquote>
<p>笔记块有 2 参数：<br>第一个为类型：[default | primary | success | info | warning | danger]<br>第二个表面是否显示图标（写了右侧内容就没 icon 了）: no-icon</p>
</blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown 教程</a></li>
<li><a href="https://hexo.io/zh-cn/docs/tag-plugins" target="_blank" rel="noopener">hexo 标签插件</a></li>
<li><a href="https://theme-next.org/docs/tag-plugins/" target="_blank" rel="noopener">next Tag Plugins</a></li>
</ul>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>npx 的用途</title>
    <url>/2020/03/04/npx-%E7%9A%84%E7%94%A8%E9%80%94/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在使用 <code>package.json</code> 的 script 运行指令时，发现通过 npm 包安装的部分指令无法使用（比如 docsify 指令），原因是因为 <code>docsify-cli</code> 当作 <code>devDependence</code> 依赖项安装至项目中了，这与在终端上直接运行 docsify 指令一样，因为全局环境并没有对应的指令，因此会提示找不到对应的指令，这时候就能用上 npx 了。</p>
<a id="more"></a>
<h3 id="简介-npx"><a href="#简介-npx" class="headerlink" title="简介 npx"></a>简介 npx</h3><p>npx 是自 npm5.2 之后发布的一个命令，用于执行 <code>node_modules/.bin</code> 内的可执行命令，其主要解决的就是前言中描述的问题：<strong>能够直接执行项目内安装的模块的命令</strong>。</p>
<p>npx 的执行流程如下：</p>
<ul>
<li>去 <code>node_modules/.bin</code> 路径检查 npx 后面的命令是否存在，找到之后执行；</li>
<li>找不到，就去环境变量 $PATH 里面，检查 npx 后面的命令是否存在，找到之后执行;</li>
<li>还是找不到，自动下载一个临时的依赖包最新版本在一个临时目录，然后再运行命令，运行完之后删除，不污染全局环境。</li>
</ul>
<blockquote>
<p>使用 npx 能够减少无用的全局模块的安装，比如 <code>npx http-server</code> 可以在当前目录启动一个 Web 服务，即使没有安装对应的包</p>
</blockquote>
<h3 id="npx-常用参数"><a href="#npx-常用参数" class="headerlink" title="npx 常用参数"></a>npx 常用参数</h3><h4 id="–no-install-参数"><a href="#–no-install-参数" class="headerlink" title="–no-install 参数"></a>–no-install 参数</h4><p>如果想让 npx 强制使用本地模块，不下载远程模块，可以使用 –no-install 参数。如果本地不存在该模块，就会报错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx --no-install http-server</span><br></pre></td></tr></table></figure>
<h4 id="–ignore-existing-参数"><a href="#–ignore-existing-参数" class="headerlink" title="–ignore-existing 参数"></a>–ignore-existing 参数</h4><p>与上面相反，此命令是强制忽略本地的同名模块，强制安装使用远程模块。比如，本地已经全局安装了create-react-app，但还是想使用远程模块，就用这个参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx --ignore-existing create-react-app my-react-app</span><br></pre></td></tr></table></figure>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://www.npmjs.com/package/npx" target="_blank" rel="noopener">npx</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2019/02/npx.html" target="_blank" rel="noopener">npx 使用教程</a></li>
<li><a href="https://www.jianshu.com/p/14c813bba544" target="_blank" rel="noopener">npx详细使用</a></li>
</ul>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Env</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli3 的快速插件开发</title>
    <url>/2019/05/09/vue-cli3-%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不久前组内有大佬发布了一个 vue-cli3 的 dll 包，作为一个在 vue 项目内摸爬滚打的萌新，是时候该学习点儿新的技术了，于是在闲暇之余，我拷贝了一份代码，同时研究该如何从“零”开始编写一个 dll 包（该部分以 webpack 的 dllPlugin 作为例子）。</p>
<a id="more"></a>
<h3 id="了解文档"><a href="#了解文档" class="headerlink" title="了解文档"></a>了解文档</h3><p>通篇读完官网的文档，因为知识点比较多，并且没有详细的例子（指“傻瓜式教学式”），因此开发这第三方包的学习成本还是有一些的，特别是 webpack-chain 和 node 的部分知识，这里记录总结了一些关键的点。</p>
<h4 id="插件命名"><a href="#插件命名" class="headerlink" title="插件命名"></a>插件命名</h4><p>最开始命名文件夹时我并没有使用 <code>vue-cli-plugin-</code> 作为文件名前缀，结果可想而知，vue invoke 一直提示找不到该包的信息。于是我去看了看源码…… 在 <code>@vue/cli/lib/invoke.js</code> 内，其有一个关键的获取包 Id 的方法 <code>resolvePluginId</code>，该方法在 <code>@vue/cli-shared-utils/lib/pluginResolution.js</code>，源码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.resolvePluginId = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// already full id</span></span><br><span class="line">  <span class="comment">// e.g. vue-cli-plugin-foo, @vue/cli-plugin-foo, @bar/vue-cli-plugin-foo</span></span><br><span class="line">  <span class="keyword">if</span> (pluginRE.test(id)) &#123;</span><br><span class="line">    <span class="keyword">return</span> id</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// scoped short</span></span><br><span class="line">  <span class="comment">// e.g. @vue/foo, @bar/foo</span></span><br><span class="line">  <span class="keyword">if</span> (id.charAt(<span class="number">0</span>) === <span class="string">'@'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> scopeMatch = id.match(scopeRE)</span><br><span class="line">    <span class="keyword">if</span> (scopeMatch) &#123;</span><br><span class="line">      <span class="keyword">const</span> scope = scopeMatch[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">const</span> shortId = id.replace(scopeRE, <span class="string">''</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;scope&#125;</span><span class="subst">$&#123;scope === <span class="string">'@vue/'</span> ? <span class="string">``</span> : <span class="string">`vue-`</span>&#125;</span>cli-plugin-<span class="subst">$&#123;shortId&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// default short</span></span><br><span class="line">  <span class="comment">// e.g. foo</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`vue-cli-plugin-<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，使用 vue invoke 时其只会寻找含有 <code>vue-cli-plugin-</code> 作为前缀的包，官网内在文档的最后部分有做对应的说明（这个是后来才看到的），原文如下：</p>
<blockquote>
<p> 为了让一个 CLI 插件能够被其它开发者使用，你必须遵循 <code>vue-cli-plugin-&lt;name&gt;</code> 的命名约定将其发布到 npm 上。</p>
</blockquote>
<p>因此 <code>package.json</code> 的 <code>name</code> 字段符合规则即可。</p>
<h4 id="creator-和-service"><a href="#creator-和-service" class="headerlink" title="creator 和 service"></a>creator 和 service</h4><p>官网开篇就介绍了两个主要的部分：<code>@vue/cli</code> 和 <code>@vue/cli-service</code>，首先是 <code>@vue/cli</code> 部分，这里介绍了插件的目录结构，因此我们可以根据此来搭一个插件框架：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue-cli-plugin-xxx</span><br><span class="line">  ├── README.md</span><br><span class="line">  ├── generator</span><br><span class="line">  |  └── index.js</span><br><span class="line">  ├── index.js</span><br><span class="line">  ├── package.json</span><br><span class="line">  ├── prompts</span><br><span class="line">  |  └── index.js</span><br><span class="line">  ├── service</span><br><span class="line">  |  ├── config-file.js</span><br><span class="line">  |  └── regist-command.js</span><br><span class="line">  └── yarn.lock</span><br></pre></td></tr></table></figure>
<p>接下来就详细分析一下各部分的作用。</p>
<h4 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h4><h5 id="文档分析"><a href="#文档分析" class="headerlink" title="文档分析"></a>文档分析</h5><p>文档中有提到，插件内的 generator 将会在两种场景下被调用：</p>
<ul>
<li>在一个项目的初始化创建过程中，如果 CLI 插件作为项目创建 preset 的一部分被安装</li>
<li>插件在项目创建好之后通过 <code>vue invoke</code> 独立调用时被安装</li>
</ul>
<p>由于开发的第三方插件使用场景多数在于更改已安装的项目配置，<code>preset</code> 使用场景不是很多（创建项目时一般还是手动配置，大多数情况不会选择去生成一个 ~/.vuerc），因此这边仅处理使用手动调用 generator 的情况。</p>
<p>触发 <code>generator</code> 的方法有两种：</p>
<ul>
<li><code>vue invoke</code></li>
<li><code>vue add</code></li>
</ul>
<p>下面就简单介绍一下这两个命令的区别。</p>
<h5 id="vue-invoke-指令"><a href="#vue-invoke-指令" class="headerlink" title="vue invoke 指令"></a>vue invoke 指令</h5><p>此指令的适用情况为已经通过 yarn 或者 npm 将包安装至项目内，此时仅需要调用 vue invoke <packagename> 即可。</packagename></p>
<blockquote>
<p>注意：这里的 packageName 为不包含 <code>vue-cli-plugin-</code> 部分的剩余包名，比如：发布的包名为 <code>vue-cli-plugin-xxx</code>，那么此时使用命令即 <code>vue invoke xxx</code></p>
</blockquote>
<h5 id="vue-add"><a href="#vue-add" class="headerlink" title="vue add"></a>vue add</h5><p>此指令的使用情况为项目内还没有安装对应的包，使用方式同 <code>vue invoke</code></p>
<blockquote>
<p>注：如果包的源不对的话，请自己在后面加上包所在的 npm 源地址（ –registry <npm origin path> ）</npm></p>
</blockquote>
<h5 id="内容编写"><a href="#内容编写" class="headerlink" title="内容编写"></a>内容编写</h5><p>分析了这么多，重点还是 generator 内我们应该写点什么，它影响的是什么。好了，让我们来继续看文档(● ˃̶͈̀ロ˂̶͈́)੭ꠥ⁾⁾</p>
<p>generator 有三个参数，这里就不细赘了，因为这里不关注 preset 的配置，所以对我们来说，有用的部分就只有第一个参数 api。首先我们需要改动的部分便是项目内的 package.json 了，使用方法 <code>extendPackage</code> 即可，例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 修改 `package.json` 里的字段</span><br><span class="line">// vue 部分的内容可以不要</span><br><span class="line">module.exports = (api, options, rootOptions) =&gt; &#123;</span><br><span class="line">  // 修改 `package.json` 里的字段</span><br><span class="line">  api.extendPackage(&#123;</span><br><span class="line">    scripts: &#123;</span><br><span class="line">      test: &apos;vue-cli-service test&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    vue: &#123;</span><br><span class="line">      pluginOptions: &#123;</span><br><span class="line">        test: &#123;</span><br><span class="line">          // 需要预打包的部分</span><br><span class="line">          vendors: [],</span><br><span class="line">          // 输出文件名</span><br><span class="line">          outputName: &apos;vendor.dll.js&apos;,</span><br><span class="line">          // 输出地址</span><br><span class="line">          outputPath: &apos;./public/vendor&apos;,</span><br><span class="line">          // 是否调用 cleanWebpackPlugin</span><br><span class="line">          cleanCache: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于此处添加的 <code>vue</code> 字段在 invoke 后会自动补充至 vue.config.js 或者 package.json 内。</p>
<p>如果你配置了 promots 并且需要该部分的内容，那么可以使用第二个 options 参数去获取配置的内容。（配置 .vuerc 的方法没有尝试，因为解构 + 默认值 + prompts 已经足够了）</p>
<blockquote>
<p>如果需要配置模板方面的参考<a href="https://github.com/vuejs/vue-cli/blob/dev/packages/%40vue/cli-service/generator/index.js" target="_blank" rel="noopener">官方源码</a>，感觉配合 prompts 写个模板插件也不错。</p>
</blockquote>
<blockquote>
<p>友情提示：render() 函数内为你的 template 模板基于当前文件夹所在的路径。</p>
</blockquote>
<h4 id="prompts"><a href="#prompts" class="headerlink" title="prompts"></a>prompts</h4><p>该部分其实在这个项目内并没有涉及，但还是要提一下。官方文档对于此部分在内建插件有详细的说明（官方插件），第三方插件提到过一点：</p>
<blockquote>
<p>这个文件应该导出一个用于 Inquirer.js 的<a href="https://github.com/SBoudrias/Inquirer.js#question" target="_blank" rel="noopener">问题</a>的数组。这些被解析的答案对象会作为选项被传递给插件的 generator。</p>
</blockquote>
<p>因此，如果需要的情况下，我们得通过数组的形式编写问答。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'entry'</span>,</span><br><span class="line">    message: <span class="string">"What's the output file's name?"</span>,</span><br><span class="line">    type: <span class="string">'input'</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">'vendor'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>此部分的配置结果会在 generator 部分的第二个参数捕捉到。</p>
<h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>这部分就是配置的重点了,还是根据官网来吧，官网有提到 3 个命令： <code>chainWebpack</code>、<code>configureWebpack</code>、<code>registerCommand</code>。直接更改原有项目的配置并不是很好（除非你很有信心），因此我们可以使用 <code>configureWebpack</code> 来合并变更。</p>
<p>这部分总的来说做三件事：</p>
<ol>
<li>更改用户的 webpack 配置文件（也就是 vue.config.js）</li>
<li>向 cli-service 内注册指令</li>
<li>为注册的指令指定模式</li>
</ol>
<p>这里从简单的部分开始一一说明吧～（顺序：3、1、2）</p>
<h5 id="指定模式"><a href="#指定模式" class="headerlink" title="指定模式"></a>指定模式</h5><p>嗯，这个最简单了，毕竟官网文档内有，理由也就不赘述了，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.defaultModes = &#123;</span><br><span class="line">  &lt;your direct&gt;: <span class="xml"><span class="tag">&lt;<span class="name">target</span> <span class="attr">mode</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>your direct</code> 部分即先前的 generator 部分注册的 script 脚本内，在 <code>vue-cli-service</code> 后面的那个指，比如，先前写的是 <code>test</code>，那么这里注册的指令也是 <code>direct</code>，mode 就根据实际情况处理即可，一般使用 <code>production</code> 生产模式就没啥问题。</p>
<h5 id="更改用户的配置文件"><a href="#更改用户的配置文件" class="headerlink" title="更改用户的配置文件"></a>更改用户的配置文件</h5><p>这里就需要有 webpack-chain 的知识了。先看看 pluginAPI 内有些啥（<a href="https://github.com/vuejs/vue-cli/blob/dev/packages/%40vue/cli-service/lib/PluginAPI.js" target="_blank" rel="noopener">传送门</a>）,可能会用到的一些方法包括：</p>
<ul>
<li>getCwd：获取当前的工作目录</li>
<li>resolve：相当于 path.resolve</li>
<li>registerCommand：注册指令（有三个参数！）</li>
<li>chainWebpack：链式调用 webpack</li>
<li>configureWebpack：用于合并 webpack</li>
<li>resolveChainableWebpackConfig：用于解析 webpack</li>
</ul>
<p>此处我们使用 <code>configureWebpack</code> 来更改配置，同时使用  <code>registerCommand</code> 来注册我们的命令。这里刚好对应的就是我们的两个文件 <code>config-file</code> 和 <code>regist-command.js</code> 了，对应开发即可。</p>
<h6 id="configureWebpack"><a href="#configureWebpack" class="headerlink" title="configureWebpack"></a>configureWebpack</h6><p>参考源码的写法，我们可以通过 options 参数获取 invoke 生成的 <code>vue.config.js</code> 里面的 <code>pluginOptions</code> 字段内的对应配置内容，配合 <code>api.configureWebpack</code> 来注入我们的 webpack 配置。粗略的写法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">api.configureWebpack(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 增一个 plugins</span></span><br><span class="line">  config.plugins.push(</span><br><span class="line">    <span class="comment">/* plugin 配置 */</span></span><br><span class="line">  )</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h6 id="registerCommand"><a href="#registerCommand" class="headerlink" title="registerCommand"></a>registerCommand</h6><p>查看源码的写法，发现参数有三个，分别是：</p>
<ul>
<li>api: pluginAPI 实例</li>
<li>options: 用来添加配置说明</li>
<li>fn: 回调函数，用于触发执行的内容（比如运行一个 webpack 配置）</li>
</ul>
<p>官方的写法如下，我们可以据此模仿<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">api.registerCommand(</span><br><span class="line">  <span class="string">"test"</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    description: <span class="string">"此为指令的说明"</span>, <span class="comment">// 指令意义</span></span><br><span class="line">    usage: <span class="string">"vue-cli-service test"</span>, <span class="comment">// 命令怎么用</span></span><br><span class="line">    options: &#123;</span><br><span class="line">      <span class="comment">/* 参数说明 */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> args =&gt; &#123;</span><br><span class="line">    <span class="comment">/* 可以写个 chain-webpack 然后调用，或者干点其它的 */</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="部分问题总结"><a href="#部分问题总结" class="headerlink" title="部分问题总结"></a>部分问题总结</h3><h4 id="1-demo-内的-dll-打包位置问题"><a href="#1-demo-内的-dll-打包位置问题" class="headerlink" title="1. demo 内的 dll 打包位置问题"></a>1. demo 内的 dll 打包位置问题</h4><p>使用默认的打包位置： <code>public/vendor</code> 会产生一个问题，就是 build 文件内会包含此 vendor 文件夹（public 文件夹内的内容默认会带至 dist 文件夹内），我们注入的一些配置不生效。</p>
<p>解决方法：将默认的 <code>public/vendor</code> 打包位置改改，只要不是生成在 public 文件夹内的都没问题，可看 vue-cli 官网的 public 部分的解释。</p>
<h4 id="2-webpack-函数"><a href="#2-webpack-函数" class="headerlink" title="2. webpack 函数"></a>2. webpack 函数</h4><p>目前第二个回调参数的使用场景不是很明确（其实不用回调也可以，外层关闭对应的 log 即可）</p>
<h4 id="3-configureWebpack-只能用-push"><a href="#3-configureWebpack-只能用-push" class="headerlink" title="3. configureWebpack 只能用 push?"></a>3. configureWebpack 只能用 push?</h4><p>我尝试过自己新创建一个 webpack-chain 然后返回（源码上好像会对返回值进行判断，如果有那么会调用 merge 方法），按理来说返回一个 config.toConfig() 应该 没问题，但是行不通，目前仍然用的是 push 方法</p>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p><a href="https://github.com/kazehaiya/vue-cli-plugin-demo" target="_blank" rel="noopener">传送门</a></p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://cli.vuejs.org/zh/dev-guide/plugin-dev.html#%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">插件开发指南</a></li>
<li><a href="https://www.jianshu.com/p/7f0563dbe792" target="_blank" rel="noopener">Vue CLI 3使用：插件和 Preset（二）</a></li>
<li><a href="https://blog.csdn.net/weixin_34268310/article/details/87119105" target="_blank" rel="noopener">使用 Webpack-chain 链式生成 webpack 配置</a></li>
<li><a href="https://segmentfault.com/a/1190000016389996" target="_blank" rel="noopener">如何使用 vue-cli 3 的 preset 打造基于 git repo 的前端项目模板</a></li>
<li><a href="https://github.com/vuetifyjs/vue-cli-plugin-vuetify" target="_blank" rel="noopener">vuetify</a></li>
<li><a href="https://segmentfault.com/q/1010000011753433" target="_blank" rel="noopener">webpack 函数参数</a></li>
<li><a href="https://segmentfault.com/a/1190000017547171#articleHeader5" target="_blank" rel="noopener">webpack chain 中文文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack library</title>
    <url>/2019/10/18/webpack-library/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>虽然先前有过使用 webpack 构建包的经验，但是最近同事问我 library 相关知识时，还是支支吾吾答不上来。想了想，知其然而不知其所以然，这和没学没有什么区别啊。所以，经过一番努力，总结了一点关于 library 的知识，这里就做个笔记，以做备忘吧。</p>
<a id="more"></a>
<h3 id="配置目的"><a href="#配置目的" class="headerlink" title="配置目的"></a>配置目的</h3><p>在开发 npm 库时，我们有时候需要考虑配置多场景的引入方式，比如： AMD、CommonJS、ES6 Moudule、NodeJs/Window 等等。那么为了能够支持这么些引入方式，library 便是 webpack 为我们提供的简化打包策略的方法，使用 library 的配置方式可以让我们专注于 ES6 的写法，而编译部分就不做过多考虑了。</p>
<blockquote>
<p>由于 ES 语法越来越普及，此处仅介绍 ES 模块语法配置需要注意的问题。</p>
</blockquote>
<h3 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h3><h4 id="单文件配置"><a href="#单文件配置" class="headerlink" title="单文件配置"></a>单文件配置</h4><p>单文件 library 的配置就非常简单了，官方就有很好的例子，这里就先贴一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">moudule.export = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'webpack-numbers.js'</span>,</span><br><span class="line">    library: <span class="string">'webpack-demo'</span>,</span><br><span class="line">    <span class="comment">// 支持 AMD 和 CommonJS</span></span><br><span class="line">    libraryTarget: <span class="string">"umd"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于如今的项目来说，如果不是对引入方式有特别要求，建议使用 umd 方式；如果有明确指定环境时，再换成对应配置即可。</p>
<h4 id="多文件配置"><a href="#多文件配置" class="headerlink" title="多文件配置"></a>多文件配置</h4><p>多文件配置唯一注意的是文件的引入，以及默认 library 名同样需要设置成动态的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 多入口文件 JSON 对象</span></span><br><span class="line"><span class="keyword">var</span> components = <span class="built_in">require</span>(<span class="string">'./components.json'</span>);</span><br><span class="line"></span><br><span class="line">moudule.export = &#123;</span><br><span class="line">  entry: components,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    <span class="comment">// 每个文件的导出对象名与文件名保持一致</span></span><br><span class="line">    library: <span class="string">'[name]'</span>,</span><br><span class="line">    <span class="comment">// 支持 AMD 和 CommonJS</span></span><br><span class="line">    libraryTarget: <span class="string">"umd"</span>,</span><br><span class="line">    <span class="comment">// ES6 编写的组件，如果导出为 export default</span></span><br><span class="line">    <span class="comment">// 如果文件引入测试有问题，可配置此属性</span></span><br><span class="line">    libraryExport: <span class="string">"default"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性详解"><a href="#属性详解" class="headerlink" title="属性详解"></a>属性详解</h3><p>其实配置什么的，随便在网上查查，再根据自身的理解尝试，都能有所成效。但是知其然我们也得知其所以然，这里我们就看看大家所关注的 library、libraryTarget、libraryExport 此三属性吧。</p>
<h4 id="library"><a href="#library" class="headerlink" title="library"></a>library</h4><p>library 可设置的类型有两种，分别是：<code>string</code> 和 <code>object</code>。</p>
<p>当我们需要对不同环境设置不太一样的导出名时，我们才可能用到 <code>object</code>，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅此三属性</span></span><br><span class="line"><span class="comment">// 无 root 配置则其采用 commonjs 名，反之 commonjs 采用 root，此两属性必须配置其</span></span><br><span class="line"><span class="comment">// 一，否则会有全局污染的危险</span></span><br><span class="line">library: &#123;</span><br><span class="line">  commonjs: <span class="string">'my-package-a'</span>,</span><br><span class="line">  amd: <span class="string">'my-package-b'</span>,</span><br><span class="line">  root: <span class="string">'my-package-c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自测 demo 结果展示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">t, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span>)</span><br><span class="line">    <span class="built_in">module</span>.exports = n();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd)</span><br><span class="line">    define([], n);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">"object"</span>)</span><br><span class="line">    exports[<span class="string">"my-package-a"</span>] = n();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    t[<span class="string">"my-package3-c"</span>] = n()</span><br><span class="line">&#125;</span><br><span class="line">)(<span class="comment">/*...*/</span>)</span><br></pre></td></tr></table></figure>
<p>否则直接使用 string 模式即可。</p>
<blockquote>
<p>注意，library 对象模式必须设置 libraryTarget 为 umd 模式；此外 library 名称最好使用<strong>驼峰式</strong>，毕竟生成的是变量。</p>
</blockquote>
<div class="note warning">
            <p>疑问： umd 模式无论如何配置 amd，打包出的内容 amd 部分基本都是 <code>define([], n);</code>，即使配置成驼峰式的值，此外官方的例子上也没有对应值，不清楚是什么问题；但 amd 模式单独打包则有对应的配置名称。</p><p>此 amd 的配置与 amd-require 的结果很相似。</p>
          </div>
<h4 id="libraryTarget"><a href="#libraryTarget" class="headerlink" title="libraryTarget"></a>libraryTarget</h4><p><code>libraryTarget</code> 属性主要配置如何暴露我们的 <code>library</code> 名。其支持的值如下：</p>
<p>变量类型：</p>
<ul>
<li>var（默认）</li>
<li>assign（产生隐含的全局变量，慎用）</li>
</ul>
<p>对象类型：</p>
<ul>
<li>this（绑定至 this 对象上）</li>
<li>window（浏览器环境的全局对象 ）</li>
<li>global（node 环境的全局对象）</li>
<li>commonjs（绑定至 export 对象）</li>
<li>self（绑定至 self 对象）</li>
</ul>
<p>模块类型：</p>
<ul>
<li>amd（amd 引入模式）</li>
<li>umd（多模式并存）</li>
<li>commonjs-module（module.exports）</li>
<li>commonjs2（commonjs-module 的模块导出 + commonjs 对象，会忽略 library 名）</li>
<li>amd-require（立即加载版的 amd，会忽略 library 名）</li>
<li>system（systemJs 引入）</li>
<li>umd2</li>
</ul>
<p>其他类型：</p>
<ul>
<li>jsonp（library 为名的 jsonp 容器）</li>
</ul>
<p>一般根据情况选取合适的 target 方式，通常来看 umd 已经能解决绝大多数通用的引入模式了。</p>
<blockquote>
<p>umd2 结果和 umd 貌似差不多，个人暂未找到相应的解释</p>
</blockquote>
<h4 id="libraryExport"><a href="#libraryExport" class="headerlink" title="libraryExport"></a>libraryExport</h4><p>该属性主要是用于配置经由 <code>libraryTarget</code> 公开那些模块，默认为 <code>undefined</code>。</p>
<p>默认情况下（假设 <code>libraryTarget</code> 为 <code>var</code>），变量导出的格式为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyDefaultModule = _entry_return_;</span><br></pre></td></tr></table></figure>
<p>如果需要显示表明导出哪些模块，我们可以这么配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定模块</span></span><br><span class="line"><span class="comment">// libraryExport: 'MyModule'</span></span><br><span class="line"><span class="keyword">var</span> MyModule = _entry_return_.MyModule;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定模块路径</span></span><br><span class="line"><span class="comment">// libraryExport: ['MyModule', 'MySubModule']</span></span><br><span class="line"><span class="keyword">var</span> MySubModule = _entry_return_.MyModule.MySubModule;</span><br></pre></td></tr></table></figure>
<p>一般并不需要配置此属性，有一种情况是：当我们使用 ES6 编写模块时，有时候打包生成的文件在引入时，其内容呈现为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">default</span>: &#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>毕竟 ES6 的 <code>export default</code> 其 <code>default</code> 严格上来说也是一个变量名，因此为了修复此问题，我们可以配置 <code>libraryExport: &#39;default&#39;</code>，将<strong>默认导出</strong>分配给库目标</p>
<h3 id="测试例子"><a href="#测试例子" class="headerlink" title="测试例子"></a>测试例子</h3><p>该部分内容还是自己动手，配合官方文档理解起来会更快，可以拷贝该 <a href="https://github.com/kazehaiya/vue-component" target="_blank" rel="noopener">测试 Demo</a> 进行尝试。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://webpack.docschina.org/configuration/output/#output-library" target="_blank" rel="noopener">output.library</a></li>
<li><a href="https://webpack.docschina.org/guides/author-libraries/#src/components/Sidebar/Sidebar.jsx" target="_blank" rel="noopener">创建 library</a></li>
<li><a href="https://github.com/webpack/webpack/tree/master/examples/multi-part-library" target="_blank" rel="noopener">muti-part-library</a></li>
<li><a href="https://webpack.docschina.org/configuration/" target="_blank" rel="noopener">webpack 全量配置</a></li>
<li><a href="https://github.com/webpack/webpack/issues/1114" target="_blank" rel="noopener">commonjs 与 commonjs2</a></li>
</ul>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 文件分离思想</title>
    <url>/2019/05/23/webpack-%E6%96%87%E4%BB%B6%E5%88%86%E7%A6%BB%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>先前做 vue 项目时，对于代码分割做了一个 DllPlugin 的 demo ，项目内的收益也挺不错（编译时间减少了 20s 左右），但是今天在看文档时，无意间又扫到了 SplitChunksPlugin。那么问题就来了，先前用的是 DllPlugin ，它和这个 SplitChunksPlugin 又有什么区别呢。这里简单记录下调研所获得的一些收获。</p>
<a id="more"></a>
<h3 id="SplitChunksPlugin"><a href="#SplitChunksPlugin" class="headerlink" title="SplitChunksPlugin"></a>SplitChunksPlugin</h3><p>自 webpack 4.0 上线之后，CommonsChunkPlugin 已被替换成 SplitChunksPlugin，旨在优化 chunk 的拆分。了解 SplitChunksPlugin 之前，我们需要知道为什么会弃用 CommonsChunkPlugin，CommonsChunkPlugin 的设计思路是什么，目前的 SplitChunksPlugin 在原来的思路上有什么改进。因此先看看 CommonsChunkPlugin 的设计思路</p>
<h4 id="CommonsChunkPlugin-的设计思路"><a href="#CommonsChunkPlugin-的设计思路" class="headerlink" title="CommonsChunkPlugin 的设计思路"></a>CommonsChunkPlugin 的设计思路</h4><p>原本的 CommonsChunkPlugin 的思路为：</p>
<blockquote>
<p>Create this chunk and move all modules matching minChunks into the new chunk</p>
</blockquote>
<p>即：</p>
<blockquote>
<p>满足 minChunks 的引用次数时，都会将对应的模块抽离如一个新的 chunk 文件中，这个文件为所有的业务文件的父级。</p>
</blockquote>
<p>而这种设计思路带来了会造成模块打包冗余。总的来说会造成这么几个问题：</p>
<ul>
<li>产出的 chunk 在引入时，会包含重复的代码；</li>
<li>无法优化异步 chunk；</li>
<li>高优的 chunk 产出需要的 minchunks 配置比较复杂。</li>
</ul>
<p>让我们具体来看下面两种情况。</p>
<h5 id="产生多余模块"><a href="#产生多余模块" class="headerlink" title="产生多余模块"></a>产生多余模块</h5><p>假如我们的文件是这么配置的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">minChunks: 2</span><br><span class="line"></span><br><span class="line">entryA: vuex vue Acomponent</span><br><span class="line">entryB: vue axios BComponent</span><br><span class="line">entryC: vue vuex axios CComponent</span><br></pre></td></tr></table></figure>
<p>那么产出的文件为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vendor-chunk: vuex vue axios</span><br><span class="line">chunkA~chunkC: only the Component</span><br></pre></td></tr></table></figure>
<p><strong>带来的问题</strong>：entryB 并没有使用 vuex，entryA 并没有使用 axios ，但是从产出的文件上来看，entryA 与 entryB 都引入了部分“脏”模块，这并不太好。</p>
<h5 id="异步支持差"><a href="#异步支持差" class="headerlink" title="异步支持差"></a>异步支持差</h5><p>除此之外，CommonsChunkPlugin 对于异步的模块不是很友好。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">minChunks: 2</span><br><span class="line"></span><br><span class="line">entryA: vuex vue Acomponent</span><br><span class="line">asyncB: vue axios BComponent</span><br><span class="line">entryC: vue vuex axios CComponent</span><br></pre></td></tr></table></figure>
<p>产出的 chunk 为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vendor-chunk：vue vuex</span><br><span class="line">chunkA: only the components</span><br><span class="line">asyncB: vue axios someComponents</span><br><span class="line">chunkC: axios someComponents</span><br></pre></td></tr></table></figure>
<p><strong>带来的问题</strong>：异步引入 asyncB 之后会引入过多的 module。</p>
<h4 id="SplitChunksPlugin-的设计思路"><a href="#SplitChunksPlugin-的设计思路" class="headerlink" title="SplitChunksPlugin 的设计思路"></a>SplitChunksPlugin 的设计思路</h4><p>SplitChunksPlugin 优化了 webpack 的打包策略，使用自动重复算法，会自动计算出各页面公共的包引用以及部分页面公共的包引用，当然，对于那些部分共有但是阈值过小的文件其不会创建单独的输出文件，因为其大小不值得去新开一个请求。（缓存策略配置在 cacheGroup 中）</p>
<blockquote>
<p>注：减少 <code>maxInitial/AsyncRequest</code> 会加大 module 的冗余，但是会进一步的减少请求。</p>
</blockquote>
<p>SplitChunksPlugin 默认的分包策略基于以下 4 个条件：</p>
<ol>
<li>新代码块可以被共享引用，或这些模块都是来自 node_modules;</li>
<li>新产出的 vendor-chunk 的大小得大于 30kb;</li>
<li>按需加载的代码块（vendor-chunk）并行请求的数量不多于 5 次；</li>
<li>初始加载的代码块，并行请求的数量不多于 3 次。</li>
</ol>
<blockquote>
<p>SplitChunksPlugin 配合使用 RuntimeChunk 对运行时的 hash 变动做优化（相当于 CommonsChunkPlugin 的两次使用）</p>
</blockquote>
<h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><p>DLLPlugin 这个插件是在一个额外独立的 webpack 设置中创建一个只有 dll 的 bundle，也就是说，除了 webpack.config.js，项目中还会新建一个 webpack.dll.config.js 文件来配置 dll 的打包。webpack.dll.config.js 作用是把所有的第三方库依赖打包到一个 bundle 的 dll 文件里面，还会生成一个名为 manifest.json 文件。</p>
<p>该 manifest.json 的作用是用来让 DllReferencePlugin 映射到相关的依赖上去的。（可类比 CommonsChunkPlugin 的两次打包或者 RuntimeChunk 的运行包配置）</p>
<h4 id="DllPlugin-的设计思路"><a href="#DllPlugin-的设计思路" class="headerlink" title="DllPlugin 的设计思路"></a>DllPlugin 的设计思路</h4><p>SplitChunksPlugin 虽然也是将公共模块抽离，但是其每次打包的时候还是会去处理一些第三方依赖库，只是它能把第三方库文件和我们的代码分开掉，生成一个独立的 js 文件。但是它还是<strong>不能提高打包的速度</strong>。</p>
<p>DLLPlugin 它则是提前将公共的包构建出来，使得在 build 时过滤掉这些构建过的包，使得在正是构建时的速度缩短。所以其相对来说<strong>打包速度会更快</strong>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，两种打包的方式各有优劣。</p>
<p>如果开发的项目是锁定版本的，同时想要提升构建速度，这时候可以考虑使用 DllPlugin 的分包策略，提前将不变的一些依赖构建好，每次构建时仅构建业务代码即可。</p>
<p>如果项目会升级，同时想要减少后期对于打包步骤的操作（构建时间不考虑），那么优先使用 SplitChunksPlugin 来配置分包策略，毕竟 DllPlugin 得走两步。</p>
<p>对于两者一起使用的情况，目前查阅过两者一起使用的例子（貌似会打包重复，有冲突）不过网上的结论比较陈旧，笔者暂未做测试，之后空闲下来再做补充。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://www.cnblogs.com/wmhuang/p/8967639.html" target="_blank" rel="noopener">webpack4：连奏中的进化</a></li>
<li><a href="https://github.com/webpack/webpack/blob/master/examples/many-pages/README.md" target="_blank" rel="noopener">webpack 的自动重复数据删除算法示例</a></li>
<li><a href="https://github.com/webpack/webpack/tree/master/examples/side-effects" target="_blank" rel="noopener">webpack4 tree-shaking 与 side-effect</a></li>
<li><a href="https://www.jianshu.com/p/95752b101582" target="_blank" rel="noopener">webpack 、manifest 、runtime 、缓存与 CommonsChunkPlugin</a></li>
<li><a href="https://www.jianshu.com/p/4dcccf390cb3" target="_blank" rel="noopener">vue-cli 中的 CommonsChunkPlugin 都做了些啥</a></li>
<li><a href="https://blog.csdn.net/napoleonxxx/article/details/81975186" target="_blank" rel="noopener">Webpack4 之 SplitChunksPlugin 规则</a></li>
<li><a href="https://www.cnblogs.com/tugenhua0707/p/9520780.html#_labe1_0" target="_blank" rel="noopener">深入浅出的webpack构建工具—DllPlugin DllReferencePlugin提高构建速度(七)</a></li>
<li><a href="https://www.zhihu.com/question/275961568" target="_blank" rel="noopener">webpack4中， splitchunks 和 dllplugin 可以并存吗？</a></li>
</ul>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>node 环境配置（windows）</title>
    <url>/2019/04/06/windows-node-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>window 上安装 node，其默认的包安装地址在 C 盘，然而从长期来看这并不是很好（如果你 C 盘特别大就当我没说），因此写此篇用于记录 windows 上 node 部分的安装配置，以便今后的查阅。</p>
<a id="more"></a>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="下载安装-node"><a href="#下载安装-node" class="headerlink" title="下载安装 node"></a>下载安装 node</h4><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node 下载地址</a></p>
<blockquote>
<p>注： 除配置目录外，其余一直点击 next 即可</p>
</blockquote>
<h4 id="设置-cache-和-global-安装位置"><a href="#设置-cache-和-global-安装位置" class="headerlink" title="设置 cache 和 global 安装位置"></a>设置 cache 和 global 安装位置</h4><p>在安装 node 的文件夹内添加 node_cache 和 node_modules 两个空文件夹，分别表示 cache 的存储和全局 npm 包的存储地址，然后在 cmd 中输入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &lt;your file path&gt; 替换成 node 安装的地址</span></span><br><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">"&lt;your file path&gt;"</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">"&lt;your file path&gt;\node_cache"</span></span><br></pre></td></tr></table></figure>
<p>之后所有的安装包都会在安装 Node 的文件夹下的 node_modules 文件内了。</p>
<p><img data-src="/images/node-env.png" alt="新建文件夹"></p>
<h4 id="设置系统环境变量"><a href="#设置系统环境变量" class="headerlink" title="设置系统环境变量"></a>设置系统环境变量</h4><p>（右击）我的电脑 -&gt; 属性 -&gt; 高级系统环境 -&gt; 环境变量 -&gt; 选择系统环境的 Path -&gt; 配置 Node 的安装地址</p>
<p><img data-src="/images/node-path-setting.png" alt="设置 node 环境"></p>
<blockquote>
<p>附：在命令行中输入 <code>npm list -g --depth=0</code> 会提示当前的 npm 包的安装地址</p>
</blockquote>
<h4 id="安装-npm-包"><a href="#安装-npm-包" class="headerlink" title="安装 npm 包"></a>安装 npm 包</h4><h5 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h5><p>nrm 是更换源的包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g nrm</span><br><span class="line"><span class="comment"># 使用 taobao 源</span></span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure>
<h5 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h5><p>nvm 是更换 node 版本的包，可自行更改当前 node 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g nvm</span><br></pre></td></tr></table></figure>
<h5 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h5><p>包管理工具，在项目中使用比 npm 更为方便且更快</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g yarn</span><br></pre></td></tr></table></figure>
<h4 id="系统变量和用户变量"><a href="#系统变量和用户变量" class="headerlink" title="系统变量和用户变量"></a>系统变量和用户变量</h4><p>网上有很多都是在系统环境中先声明一个 NODE_ENV 的变量，然后在用户环境中在配置 npm 包的位置，其区别是：</p>
<ul>
<li>系统环境：对全部用户起作用</li>
<li>用户环境：仅对当前用户起作用</li>
</ul>
<p>如果 windows 需要配置多用户的话可以根据情况适当配置，但是如果仅仅个人使用的话配一个全局的环境变量即可，无需根据当前用户做适当配置。</p>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 git submodule 来管理子模块</title>
    <url>/2019/10/17/%E4%BD%BF%E7%94%A8-git-submodule-%E6%9D%A5%E7%AE%A1%E7%90%86%E5%AD%90%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近期在考虑项目拆分的过程中，对于公共组件的维护总共找到了两种方式，分别是：发布 npm 包与 <code>git submodule</code> 子模块管理。对于 npm 发包的方法这里我就不做赘述了（先前有写到过），而另一种 <code>git submodule</code> 的方法这里就详细介绍一下，对于不想使用发包的方式（比较繁琐）来维护子项目的 coder 来说，这种方式可以算是最为方便的了。</p>
<a id="more"></a>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。也许是第三方库，或者你独立开发的，用于多个父项目的库。现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。</p>
<p>我们举一个例子。假设你正在开发一个网站然后创建了 Atom 订阅。你决定使用一个库，而不是写自己的 Atom 生成代码。你可能不得不通过 CPAN 安装或 Ruby gem 来包含共享库中的代码，或者将源代码直接拷贝到自己的项目中。如果将这个库包含进来，那么无论用何种方式都很难定制它，部署则更加困难，因为你必须确保每一个客户端都包含该库。如果将代码复制到自己的项目中，那么你做的任何自定义修改都会使合并上游的改动变得困难。</p>
<p>Git 通过子模块来解决这个问题。子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p>
<blockquote>
<p>该部分直接引用官方的例子，就不造轮子了。</p>
</blockquote>
<h3 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h3><p>使用 <code>git submodule</code> 时，需要的一些命令有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前项目文件名如不指定，则默认为仓库名</span></span><br><span class="line"><span class="comment"># 目标仓库路径可为远程仓库地址，也可为当前相对路径</span></span><br><span class="line">git submodule add &lt;目标仓库路径&gt; &lt;当前项目文件名&gt;</span><br><span class="line"><span class="comment"># 查看子模块状态</span></span><br><span class="line">git submodule (status)</span><br><span class="line"><span class="comment"># 将子模块与远程保持同步（会切换至一个临时分支）</span></span><br><span class="line">git submodule update --remote</span><br><span class="line"><span class="comment"># 将所有子模块都切换至 master 分支</span></span><br><span class="line">git submodule foreach <span class="string">'git checkout master'</span></span><br><span class="line"><span class="comment"># 将所有子模块同步远程更新</span></span><br><span class="line">git submodule foreach <span class="string">'git pull'</span></span><br><span class="line"><span class="comment"># 查看子模块追踪的内容信息</span></span><br><span class="line">git diff --cached --submodule</span><br></pre></td></tr></table></figure>
<h3 id="初次添加仓库操作"><a href="#初次添加仓库操作" class="headerlink" title="初次添加仓库操作"></a>初次添加仓库操作</h3><p>作为添加者来说，子模块的添加是很简单的一件事，主要步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加仓库</span></span><br><span class="line">git submodule add &lt;子模块仓库路径&gt; &lt;当前项目文件名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时打印 git status 会显示 submodule 的一些信息</span></span><br><span class="line"><span class="comment"># .submodule 文件内存储的就是我们需要的映射信息了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交更新并推送至远程</span></span><br><span class="line"><span class="comment"># 当仓库提交至远程时，子模块的内容并不会被带过去</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"init submodule"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<h3 id="拷贝远程仓库"><a href="#拷贝远程仓库" class="headerlink" title="拷贝远程仓库"></a>拷贝远程仓库</h3><p>拷贝远程带有子模块的项目需要稍微注意一点，那就是子模块需要额外的步骤才能将内容拷贝下来，具体步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆仓库</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;远程仓库地址&gt;</span><br><span class="line"><span class="comment"># 此时子模块是没有内容的，所以</span></span><br><span class="line"><span class="comment"># 初始化本地配置文件</span></span><br><span class="line">git submodule init</span><br><span class="line"><span class="comment"># 配置文件有记录对应的 commit id，此将子模块文件同步至配置文件内记录的 id 处</span></span><br><span class="line"><span class="comment"># 注意： `git submodule update` 拿到的文件内容并不一定与子模块仓库的最新状态保持一致</span></span><br><span class="line"><span class="comment"># 因为它记录的为先前初始化时的版本，需要额外更新</span></span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三步简化成一步的操作为： git clone &lt;远程仓库地址&gt; –recursive</p>
</blockquote>
<h3 id="更新子模块"><a href="#更新子模块" class="headerlink" title="更新子模块"></a>更新子模块</h3><p>更新的方法也有多种，最为基础的处理方式是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入项目中的子模块内</span></span><br><span class="line"><span class="built_in">cd</span> &lt;child-module&gt;</span><br><span class="line"><span class="comment"># 拉取新内容</span></span><br><span class="line">git fetch</span><br><span class="line"><span class="comment"># 合并新内容</span></span><br><span class="line">git merge</span><br><span class="line"><span class="comment"># fetch 和 merge 可以简化为一步： git pull</span></span><br></pre></td></tr></table></figure>
<p>当然，此做法比较繁杂，较为简便的处理方法是（无需进入子模块）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 remote 会更新至远程项目的最新版本，否则是本地最新版本</span></span><br><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure>
<p>Git 会自动进入子模块并更新它。但是该命令会默认假定你想要更新并检出子模块的 master 分支。简单的说，此时子模块会自动生成一个新临时分支，与远程的源保持一致，如果子模块内部有改动，想要迁回，那么将子模块的 branch 切回原来的分支即可。</p>
<p>例如：子模块本来是 master 分支，后来远程子模块的源更新了，此时 <code>git submodule update --remote</code> 会将子模块分支切换成一个 hash id 分支。此时进入子模块目录，<code>git checkout master</code> 切回 master 分支，你会发现该 master 分支内容与执行 <code>update</code> 指令之前的是一致的，没有变动，但会提醒你远程的源已经更新了，需要手动 pull 一下。</p>
<div class="note info">
            <p>这样看来，这两种写法都没差啦～反正最后都得自己手动处理一下。</p>
          </div>
<p>对于包含多个子模块的项目来说，进入子模块一个个更新着实是很麻烦，批量更新可以使用 foreach，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同步最新的 head 指针，否则</span></span><br><span class="line">git submodule update --remote</span><br><span class="line"><span class="comment"># 将默认迁出的分支迁回 master，然后拉取更新</span></span><br><span class="line">git submodule foreach git checkout master</span><br><span class="line">git submodule foreach git pull</span><br></pre></td></tr></table></figure>
<p>或者，如果知道更新了，可以省略掉前两步骤（前面步骤主要是为了 <code>git status</code> | <code>git submodules</code> 看有没有子模块变动），直接拉取就行，这样也不用再去切分支了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule foreach git pull</span><br></pre></td></tr></table></figure>
<h3 id="更改子模块"><a href="#更改子模块" class="headerlink" title="更改子模块"></a>更改子模块</h3><p>前面对子模块的处理仅仅只是同步更新而已，这和使用 npm 包没啥区别，但毕竟是将子模块给弄进项目了，当个包放在那里用，那也太委屈了。其实在主项目内，我们还可以对子模块进行更新，还可以并发布其改动，这样就能节省很多时间和劳力了（前提是别改造得别人无法使用，变成私有代码库了）。</p>
<p>这里仅介绍比较省时的操作，直接启动 merge ，我们可以用下面这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule update --remote --merge</span><br></pre></td></tr></table></figure>
<p>进入子模块后，我们就能和平常一样的合并冲突了。</p>
<p>在主分支进行推送时，我们得保证当前分支的所有子模块都已经与远程一致（或者都落后，但不可 diverged），防止别的伙伴接受不到新的变动，因此推送的命令改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这样 git 会进入到子模块中然后在推送主项目前推送了它。如果那个子模块因为某些原因推送失败，主项目也会推送失败</span></span><br><span class="line"><span class="comment"># 该方法暂未尝试，一直用的 foreach push，比较方便</span></span><br><span class="line">git push --recurse-submodules=on-demand</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>如果出现了无法推送的情况，特别是远程分支为本地项目的情况，此时我们需要进入该远程分支，然后设置 ‘.git/config’ 文件，加上内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[receive]</span><br><span class="line">        denyCurrentBranch = false</span><br></pre></td></tr></table></figure>
<p>这样就能 push 了。</p>
<h3 id="删除子模块"><a href="#删除子模块" class="headerlink" title="删除子模块"></a>删除子模块</h3><p>删除子模块需要进行 2 步操作，首先得删除对应的 cache 缓存追踪，然后再删除对应的模块文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;fileName&gt;</span><br><span class="line">rm --rf &lt;fileName&gt;</span><br></pre></td></tr></table></figure>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">Git 子模块</a></li>
<li><a href="https://www.jianshu.com/p/9000cd49822c" target="_blank" rel="noopener">Git 子模块的管理和使用</a></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 vue-cli 发布一个完善的包</title>
    <url>/2019/07/11/%E4%BD%BF%E7%94%A8-vue-cli-%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E5%8C%85/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>其实先前有写过一篇《发布一个 vue 包》，不过对于“极简主义者”来说，该文章还是显得有些复杂，毕竟需要配置“复杂”的 webpack。那么有没有一种简单上手、开箱即用的方法呢？答案是有的，vue-cli 已经完美的考虑到了这些问题，此处就介绍如何使用 vue-cli 来搭建一个完整的发包环境。</p>
<blockquote>
<p>注：此处的 vue-cli 指的是 @vue/cli ，为 3.x 版本。</p>
</blockquote>
<a id="more"></a>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>我们的最终目标是发布的包、测试环境和包的使用文档，此可概括为：项目构建环境和项目使用文档。由于 vue-cli 可以手动配置项目需要的环境，因此在项目构建环境部分此处仅记录 vue-cli 的部分配置选项和相关解释，整体的项目结构和先前的基本一致。</p>
<p>然而文档方面因为 vue-cli 没有做相应的支持，因此我们需要找一个能识别 vue 组件的文档库，个人建议首选 vuepress，其次可以尝试 docsify 或者其余能够支持 vue 的文档网站生成工具（当然自己造对应轮子也是可以的）。</p>
<h3 id="项目环境构建"><a href="#项目环境构建" class="headerlink" title="项目环境构建"></a>项目环境构建</h3><p>使用 vue-cli 创建一个项目，此处就以 vue-cli-plugin-demo 做为例子。直接使用 vue create 创建项目，然后选择 Manully select features，之后选择的内容如下图：</p>
<p><img data-src="/images/vue-cli-init-config.png" alt="vue-cli 配置"></p>
<p>这里解释一下其中部分选项的选择的原因：</p>
<h4 id="TS-的-Class-风格支持"><a href="#TS-的-Class-风格支持" class="headerlink" title="TS 的 Class 风格支持"></a>TS 的 Class 风格支持</h4><p>因为 vue3 相对于 vue2 版本有比较大的变动，至于 vue2 所支持的 class 风格的 TS 写法在 vue3 中可能不怎么支持，因此现有项目是否使用 Class 风格可能会有些争议（主要是担心写习惯后到时候不太好切换写法）。</p>
<p>个人建议使用，毕竟单纯的 TS 写法在 vue2 中的会稍显难受，装饰器的写法要稍微舒服一些。此外，多学习一些新知识总归是对自己有好处。</p>
<h4 id="TS-使用-eslint-standard"><a href="#TS-使用-eslint-standard" class="headerlink" title="TS 使用 eslint-standard"></a>TS 使用 eslint-standard</h4><p>有人会问为什么创建项目时不直接选 TSlint 作为校验规则呢？这其实也是有原因的。可以上网对比一下 ESlint 和 TSlint ，你会发现 ESlint 的校验规则相对来说更细致，且更完全。此外，TypeScript 官方都决定迁移 TSlint 至 typescript-eslint，那我们还有什么理由坚持 TSlint 了呢？嘿嘿～</p>
<div class="note info">
            <p>The TypeScript Team themselves also announced their plans to move the TypeScript codebase from TSLint to typescript-eslint, and they have been big supporters of this project. More details at <a href="https://github.com/microsoft/TypeScript/issues/30553" target="_blank" rel="noopener">https://github.com/microsoft/TypeScript/issues/30553</a></p>
          </div>
<h4 id="其余部分"><a href="#其余部分" class="headerlink" title="其余部分"></a>其余部分</h4><p>单元测试部分因为我仅仅了解 Mocha 的部分内容，因此选择的是 Mocha，熟悉 Jest 的可以选 Jest；至于勾选 vue-router 和 vuex，这个是对于运行 devServer 做的一些配置；然后是 vue-router 不选择 history 模式，这个仁者见仁，智者见智吧，毕竟 lib 发包不走这个。</p>
<h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><h4 id="结构配置"><a href="#结构配置" class="headerlink" title="结构配置"></a>结构配置</h4><p>过滤掉默认生成的并且不做修改的部分，最终项目的结构大致为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue-cli-plugin-demo</span><br><span class="line">├── components.json</span><br><span class="line">├── docs</span><br><span class="line">├── packages</span><br><span class="line">├── src</span><br><span class="line">|  ├── App.vue</span><br><span class="line">|  ├── components</span><br><span class="line">|  ├── entry.js</span><br><span class="line">|  ├── main.js</span><br><span class="line">|  ├── mixins</span><br><span class="line">|  ├── router.js</span><br><span class="line">|  ├── store.js</span><br><span class="line">|  ├── views</span><br><span class="line">|  └── types</span><br><span class="line">├── types</span><br><span class="line">|  └── index.d.ts</span><br><span class="line">├── vue.config.js</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── webpack.component.js</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure>
<p>其中 docs 为文档的文件夹，然后 components.json 、webpack.component.js 和 src/entry.js 主要为了按需引入而做的单独打包处理，其次在根目录和 src 文件夹内都添加了一个 types 文件，最后在根目录下建立了一个 packages 文件夹作为发包组件的结构。接下来我们一步步来搭建我们自己的 vue 包。</p>
<blockquote>
<p>整体结构参考 element-ui 的项目结构</p>
</blockquote>
<h4 id="配置-tsconfig-json-和-vue-config-js"><a href="#配置-tsconfig-json-和-vue-config-js" class="headerlink" title="配置 tsconfig.json 和 vue.config.js"></a>配置 tsconfig.json 和 vue.config.js</h4><p>tsconfig.json 内的配置内容不是很多，仅配置以下信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"jsxFactory": "h", // 简写 jsx 的 render 函数</span><br><span class="line">"paths": [         // 配置 import 引入的路径索引，视情况扩展</span><br><span class="line">  <span class="comment">// ...,</span></span><br><span class="line">  "@views/*": [</span><br><span class="line">    <span class="string">"src/views/*"</span></span><br><span class="line">  ]</span><br><span class="line">],</span><br><span class="line">"pretty": true,    // 为错误消息设置样式</span><br><span class="line">"includes": [      // 添加需要 ts 校验的文件</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  "packages/**/*.ts",</span><br><span class="line">  "packages/**/*.tsx",</span><br><span class="line">  <span class="string">"packages/**/*.vue"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>vue.config.js 内的配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置公共请求路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  lintOnSave: <span class="literal">true</span>,</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置 output 的默认 export 值</span></span><br><span class="line">    config.output.libraryExport(<span class="string">'default'</span>)</span><br><span class="line">    <span class="comment">// 新增部分别名，视情况扩展</span></span><br><span class="line">    config.resolve.alias</span><br><span class="line">      .set(<span class="string">'@'</span>, resolve(<span class="string">'src'</span>))</span><br><span class="line">      .set(<span class="string">'@views'</span>, resolve(<span class="string">'src/views'</span>))</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 新增 js 的 exclude 内容</span></span><br><span class="line">    config.module.rule(<span class="string">'js'</span>).exclude.add([resolve(<span class="string">'lib'</span>), resolve(<span class="string">'dist'</span>)])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注：</strong> 两文件内的别名扩展需要保持一致。除了配置别名外，另一个<strong>需要关注的部分</strong>是修改 rule(‘js’) 部分的配置，否则后面测试自己打包好的 lib 文件会报错。</p>
</blockquote>
<h4 id="packages-包写法"><a href="#packages-包写法" class="headerlink" title="packages 包写法"></a>packages 包写法</h4><p>packages 包用于存放我们编写的包组件，我们统一其每一项的结构为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*...*/vue-cli-project-demo/packages</span><br><span class="line">└── button</span><br><span class="line">   ├── index.ts</span><br><span class="line">   └── src</span><br><span class="line">      └── main.vue</span><br></pre></td></tr></table></figure>
<p>这么写的原因在于方便按需打包，使用统一的格式利于我们抽象对应的函数方法，同时也利于项目的维护。其中 index.ts 用于暴露 src 中的 vue 文件和其对应的 install 扩展方法。</p>
<blockquote>
<p>index.ts 内没有必要对单文件进行 install 扩展，除非需要规范化对应 component 的标签值，比如：element-ui 单文件引入的是 Button，没有 el 前缀，用 Vue.use 就是为了补充上前缀，内部走 Vue.component 方法。</p>
</blockquote>
<blockquote>
<p>个人建议：保证导出的组件的 name 值符合总体规范即可，并不需要一定走此配置的格式。</p>
</blockquote>
<h4 id="打包配置"><a href="#打包配置" class="headerlink" title="打包配置"></a>打包配置</h4><p>这里使用的是 vue-cli 提供的 lib 打包方式，基本不用额外的 webpack 配置，命令为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vue-cli-service build --target lib --name myLib [entry]</span><br></pre></td></tr></table></figure>
<p>因此我们可以改造 package.json 如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "dev": "vue-cli-service serve --open",</span><br><span class="line">  "build": "vue-cli-service build --target lib --dest lib ./src/entry.ts &amp;&amp; yarn removeHtml",</span><br><span class="line">  "removeHtml": "rm ./lib/*.html",</span><br><span class="line">  "lint:js": "vue-cli-service lint",</span><br><span class="line">  "lint:css": "npx stylelint src packages --fix",</span><br><span class="line">  "test:unit": "vue-cli-service test:unit"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为构建 lib 包会默认生成一个 html 文件，在此我做了删除。此外添加了 stylelint 的一些配置。demo 内还规范了发包上传的内容以及 commit 时的校验配置，可视情况添加。</p>
<p>此外如果更规范一点，我们可以写上作者，写作者等配置（可参考 demo）。</p>
<h4 id="dev-环境配置"><a href="#dev-环境配置" class="headerlink" title="dev 环境配置"></a>dev 环境配置</h4><p>开发环境需要配置的东西基本没有，这里仅仅介绍一下如何引用打包文件。此处有两种情况：</p>
<p>在开发包的阶段，我们直接引用 entry.ts 文件即可，当测试生成的包时，我们引用 lib 内的生成的文件。如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开发时测试用</span></span><br><span class="line"><span class="keyword">import</span> MyComponents <span class="keyword">from</span> <span class="string">'./entry'</span>;</span><br><span class="line"><span class="comment">// 构建完测试用</span></span><br><span class="line"><span class="keyword">import</span> MyComponents <span class="keyword">from</span> <span class="string">'@lib/vue-cli-project-demo.umd'</span>;</span><br></pre></td></tr></table></figure>
<p>此时我们需要配置对应 js 文件的 module 扩展，如 demo 内的 global.d.ts 的声明：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "@lib/*" &#123;</span><br><span class="line">  <span class="keyword">import</span> Vue, &#123; PluginFunction &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">  <span class="keyword">const</span> _default: PluginFunction&lt;Vue&gt;;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> _default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>项目开发相关的 ts 问题可查阅先前的一篇 ts 问题总结篇，配置开发包的 ts 问题看本文的问题汇总。</p>
</blockquote>
<h4 id="Test-测试配置"><a href="#Test-测试配置" class="headerlink" title="Test 测试配置"></a>Test 测试配置</h4><p>demo 内使用的是 Mocha + chai，同时对 slot 部分做了一下测试，这个对着文档就能做出一些测试函数，其余的配置 vue-cli 都封装好了。测试的语法并非本文的重点，有机会可以补上一篇。</p>
<h4 id="单文件打包配置"><a href="#单文件打包配置" class="headerlink" title="单文件打包配置"></a>单文件打包配置</h4><p>要实现按需引入的话，我们还需配置多入口打包。先前规范的 package 文件夹的结构刚好就支持我们遍历需要打包的文件。</p>
<p>由于想稍微偷点懒，这里我就直接用 json 记录各需要的入口文件，同时配置 webpack.components.js 仅用于单独打包。webpack 的详细配置其实可以参考 vue-cli 的内部配置（vue inspect），在此我就不一一列举了，其它需要注意的部分就是如果 package 包内的组件如果用 TS 写的，那么尽量不要压缩代码，可能会出现 name 被压缩的问题了。</p>
<h3 id="文档配置"><a href="#文档配置" class="headerlink" title="文档配置"></a>文档配置</h3><p>对于整个项目来说，文档的配置可以算是一个点缀项，能让整体更加完善。vuepress 文档已经十分详细了，这里仅仅记录一些比较困难的配置点。docs 文件的结构大致为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue-cli-project-demo/docs</span><br><span class="line">├── .vuepress</span><br><span class="line">|  ├── config.js</span><br><span class="line">|  ├── enhanceApp.js</span><br><span class="line">|  ├── public</span><br><span class="line">|  |  ├── favicon.ico</span><br><span class="line">|  |  └── logo.jpg</span><br><span class="line">|  ├── router-config.js</span><br><span class="line">|  ├── static-theme-config.js</span><br><span class="line">|  └── utils</span><br><span class="line">|    └── index.js</span><br><span class="line">├── components</span><br><span class="line">|  ├── button.md</span><br><span class="line">|  └── index.md</span><br><span class="line">└── index.md</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： docs 才是文档页面的根路径。</p>
</blockquote>
<h4 id="图片配置"><a href="#图片配置" class="headerlink" title="图片配置"></a>图片配置</h4><p>Vuepress 内分为文档图片资源和静态图片资源。公共图片资源就不用介绍了，一般相对路径的 markdown 写法能完全满足要求。但是对于页面的 favicon 和首页模板部分的 logo ，这个需要在 .vuepress 下的 public 文件内做存储。</p>
<h4 id="项目包引入"><a href="#项目包引入" class="headerlink" title="项目包引入"></a>项目包引入</h4><p>对于我们生成的 lib 包的引入，此需要在 .vuepress 文件夹下创建一个 enhanceApp.js 文件，在该文件内做额外包的引入。写法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装发布的包</span></span><br><span class="line"><span class="keyword">import</span> MyComponents <span class="keyword">from</span> <span class="string">'../../lib/vue-cli-project-demo.umd'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123;</span><br><span class="line">  Vue, <span class="comment">// VuePress 正在使用的 Vue 构造函数</span></span><br><span class="line">  options, <span class="comment">// 附加到根实例的一些选项</span></span><br><span class="line">  router, <span class="comment">// 当前应用的路由实例</span></span><br><span class="line">  siteData <span class="comment">// 站点元数据</span></span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  Vue.use(MyComponents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="整体页面配置"><a href="#整体页面配置" class="headerlink" title="整体页面配置"></a>整体页面配置</h4><p>与 .vuepress 同级别的其余文件/文件夹为对应的页面模板，例如：默认进入显示的首页为 index.md 文件，对于各文件的路径配置需要在 .vuepress/config.js 文件内对应编写。</p>
<p>这里可能会遇到的问题是，将 config.js 文件拆分成多个文件时，页面会无法监听到其余 js 配置文件的修改。我们此时需要配置 <code>extraWatchFiles</code> 字段来额外监听需要监听的文件。</p>
<p>另外需要注意的是 <code>base</code> 属性，如果部署在服务器上的路径非根路径，那么此还需要对应设置一下。剩余的配置都为比较基础的配置了，demo 内都有较为详细的说明，在此就不一一列举了。</p>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>因为我的 github.io 上已经有我的博客了，此部分具体有什么坑我也没有踩过，仅能给大家抛个<a href="https://v1.vuepress.vuejs.org/zh/guide/deploy.html#github-pages" target="_blank" rel="noopener">链接</a>了。</p>
<h3 id="Demo-地址"><a href="#Demo-地址" class="headerlink" title="Demo 地址"></a>Demo 地址</h3><p><a href="https://github.com/kazehaiya/vue-cli-project-demo" target="_blank" rel="noopener">传送门</a></p>
<h3 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h3><h4 id="引入打包的-lib-文件报错"><a href="#引入打包的-lib-文件报错" class="headerlink" title="引入打包的 lib 文件报错"></a>引入打包的 lib 文件报错</h4><p>在测试生成的包时，通过 import 引入报错，其原因是 webpack 对于 import 的文件会进行此处的 js 解析，然而对于已经打包好的文件我们预想的是直接引入就行了，因此需要将其从规则中去除掉，否则通过规则去解析就会报错。</p>
<h4 id="两个-types-文件的目的"><a href="#两个-types-文件的目的" class="headerlink" title="两个 types 文件的目的"></a>两个 types 文件的目的</h4><p>项目内的 types 文件其实可以合并成一个，但是个人倾向分成两部分。与 src 同层的 types 文件仅用来声明 lib 默认导出的文件，而 src/types 文件则是项目开发时需要的文件声明。如果最终发布至 npm 上的包仅包含 lib 文件，那么建议使用 demo 的这种写法，层次会更清楚一点。</p>
<h4 id="使用-lib-中的-umd-min-js-文件报错"><a href="#使用-lib-中的-umd-min-js-文件报错" class="headerlink" title="使用 lib 中的 umd.min.js 文件报错"></a>使用 lib 中的 umd.min.js 文件报错</h4><p>由于 lib 打包生成的 min 文件将组件的 Class 名压缩了，因此对应的 name 值就不是我们设置的值，即使将 name 显示至于 Component 内也不行，对此我发了一条 <a href="https://github.com/vuejs/vue-cli/issues/4338" target="_blank" rel="noopener">issue</a></p>
<p>补充： 最终的解决方案有两个，这里列举一下解决思路：</p>
<p>方法 1:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对应包组件</span></span><br><span class="line">@Component(&#123;</span><br><span class="line">  name: <span class="string">'MyButton'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// install 方法内的 component 注册部分</span></span><br><span class="line">Vue.component(MyButton.options.name, MyButton);</span><br></pre></td></tr></table></figure>
<p>方法 2:</p>
<p>配置 terser 的代码压缩部分，令其不压缩 className，该部分在 vue.config.js 内配置如下内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    config.optimization.minimizer[<span class="number">0</span>].options.terserOptions.keep_fnames = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> vue-cli 使用的是 terser 而不是 uglify，此外虽然 vue 内有对应 terser 的命名，但是没法获取得到，使用 config.optimization.minimizer(‘terser’) 函数会使得 minimizer 部分的内容丢失，暂未找到比较好的解决方法。个人还是希望官方补充一下解决该问题的思路。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码中的 production 环境的部分配置</span></span><br><span class="line"><span class="keyword">if</span> (process.env.VUE_CLI_TEST) &#123;</span><br><span class="line">  webpackConfig.optimization.minimize(<span class="literal">false</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>)</span><br><span class="line">  <span class="keyword">const</span> terserOptions = <span class="built_in">require</span>(<span class="string">'./terserOptions'</span>)</span><br><span class="line">  webpackConfig.optimization</span><br><span class="line">    .minimizer(<span class="string">'terser'</span>)</span><br><span class="line">      .use(TerserPlugin, [terserOptions(options)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>源码请见 <a href="https://github.com/vuejs/vue-cli/blob/dev/packages/%40vue/cli-service/lib/config/prod.js" target="_blank" rel="noopener">prod.js</a><br>官方 <a href="https://github.com/vuejs/vue-cli/blob/dev/packages/%40vue/cli-service/lib/config/terserOptions.js" target="_blank" rel="noopener">terserOptions</a> 配置</p>
</blockquote>
<h4 id="install-方法报错"><a href="#install-方法报错" class="headerlink" title="install 方法报错"></a>install 方法报错</h4><p>在对应包的 index.ts 内为导出的包设置 install 方法时报错，install 方法在 Vue 中是作为 Plugins 的一个内置函数而设置的，而我们导出的实例类型为 VueConstructor ，在 VueConstructor 上并没有 install 函数，因此按照 plugins 那种写法扩展声明一个即可。</p>
<h4 id="引入包的项目构建页面不呈现"><a href="#引入包的项目构建页面不呈现" class="headerlink" title="引入包的项目构建页面不呈现"></a>引入包的项目构建页面不呈现</h4><p>使用 <code>Components</code> 语法编写的组件库可能会遇到这么一个问题，项目将组件通过 <code>Vue.use</code> 方法全量注册到项目中了，开发环节并没有遇到任何问题，可随处使用，但是一旦 <code>build</code> 构建后，页面却无法呈现出组件。</p>
<p><strong>原因：</strong> <code>Class</code> 语法编写的组件编译时会经有 <code>vue-cli</code> 的 webpack 处理，默认的 <code>terser</code> 压缩配置中同样会将 <code>ClassName</code> 给压缩掉，这就导致引入的组件在生产环境找不到了。</p>
<blockquote>
<p>解决方法：参考 <strong>使用 lib 中的 umd.min.js 文件报错</strong> 的 <strong>方法 2</strong></p>
</blockquote>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="/2019/04/14/发布一个-vue-包/" title="发布一个 vue 包">发布一个 vue 包</a></li>
<li><a href="/2019/07/14/项目-ts-迁移的踩坑记录/" title="项目 ts 迁移的踩坑记录">项目 ts 迁移的踩坑记录</a></li>
<li><a href="https://github.com/typescript-eslint/typescript-eslint#readme" target="_blank" rel="noopener">typescript-eslint/typescript-eslint</a></li>
<li><a href="https://cli.vuejs.org/zh/guide/" target="_blank" rel="noopener">vue-cli 文档</a></li>
<li><a href="https://v1.vuepress.vuejs.org/zh/guide/" target="_blank" rel="noopener">vuepress 文档</a></li>
<li><a href="https://www.cnblogs.com/zaihuilou/p/9556373.html" target="_blank" rel="noopener">TS 编译选项查询表</a></li>
<li><a href="https://www.chaijs.com/" target="_blank" rel="noopener">Chai.js 文档</a></li>
<li><a href="https://medium.com/haiiro-io/element-component-name-with-vue-class-component-f3b435656561" target="_blank" rel="noopener">Element/Component name with vue-class-component</a></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 JS 中“继承”的写法</title>
    <url>/2019/06/28/%E5%85%B3%E4%BA%8E-JS-%E4%B8%AD%E2%80%9C%E7%BB%A7%E6%89%BF%E2%80%9D%E7%9A%84%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在巩固继承这部分知识时，突然想到早期分享时同事提出的一些疑问，即实现 JS 继承具体有那些方法。在经过一番调研后，此篇便是我所总结出的比较全面的方法。当然，文中记录的仅是一些基础的继承方法以及它们之间的的区别，以供参考。</p>
<a id="more"></a>
<h3 id="（原型）继承"><a href="#（原型）继承" class="headerlink" title="（原型）继承"></a>（原型）继承</h3><p>JavaScript 中有许多模拟类行为的方法，其中“继承”（更贴切的说法是委托）便是其中的一项，没有“继承”机制，JavaScript 中的类就是一个空架子。</p>
<p>假如我们以此例作为继承的模板，归结下来总共有 5 种继承的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age, size</span>) </span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>, age);</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 继承的实现，看下例 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">28</span>, <span class="string">'small'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="隐式链接法"><a href="#隐式链接法" class="headerlink" title="隐式链接法"></a>隐式链接法</h4><p>ES6 之前比较非常规的写法是手动更改 <code>__proto__</code> 属性来最简化链式继承。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Child.prototype.__proto__ = Father.prototype</span><br></pre></td></tr></table></figure>
<p>优点：操作很简便直接</p>
<p>缺点：该方法并非标准，并且无法兼容所有浏览器，慎用。</p>
<h4 id="直接引用法"><a href="#直接引用法" class="headerlink" title="直接引用法"></a>直接引用法</h4><p>直接将子类的 prototype 对象指向父类的 prototype 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Child.prototype = Father.prototype;</span><br></pre></td></tr></table></figure>
<p>优点：操作简单</p>
<p>缺点： Child 的 prototype 属性修改会直接影响到父类，此写法其实相当于直接在父类进行修改，新创建一个子类有些多此一举。</p>
<h4 id="实例化方法"><a href="#实例化方法" class="headerlink" title="实例化方法"></a>实例化方法</h4><p>子类的 prototype 属性为父类的实例对象，借由对象的 prototype 链来传递。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// Child.prototype.constructor = Chlid;</span></span><br></pre></td></tr></table></figure>
<p>优点：能基本满足“继承”的需求</p>
<p>缺点：</p>
<ol>
<li>需要创建一个新对象，然后将旧对象（原本存在的 prototype 对象，带有 constructor）抛弃掉，不能直接修改默认的 prototype 对象。</li>
<li>会产生副作用，比如：原型（prototype）上会有“脏”属性，本例的 prototype 上会有多余的 age 属性。</li>
<li>必要时还得自己重写一下 Child 的 constructor 指向，如“寄生组合式继承”。</li>
</ol>
<blockquote>
<p>“寄生组合式继承” 在 ES5 中为最佳写法，如果不考虑其稍微的复杂性。</p>
</blockquote>
<h4 id="对象构造法"><a href="#对象构造法" class="headerlink" title="对象构造法"></a>对象构造法</h4><p>通过 <code>Object.create</code> 方法来构造一个合适的关联对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Father.prototype)</span><br><span class="line"><span class="comment">// Child.prototype.constructor = Chlid;</span></span><br></pre></td></tr></table></figure>
<p>优点：在 ES6 之前的最佳之选，优于实例化方法。</p>
<p>缺点：与实例化方法基本相同，但没有副作用。此外，其隐式 <code>__proto__</code> 链比实例化方法要多一层，链式查找方法相对会耗时长一点点，基本可忽略。</p>
<h4 id="设置原型法"><a href="#设置原型法" class="headerlink" title="设置原型法"></a>设置原型法</h4><p>使用 ES6 的原型设置方法，此法在 ES6 环境为最佳之选，没有之一。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Child.prototype, Father.prototype)</span><br></pre></td></tr></table></figure>
<p>优点：能覆盖所有需求，清晰易懂，可读性强。</p>
<p>缺点：性能比 <code>Object.create</code> 稍微差点，如果考虑性能的话可优先使用 <code>Object.create</code> 方法</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener">MDN</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>分析 Vue 的观察者模式（上）</title>
    <url>/2019/10/10/%E5%88%86%E6%9E%90-Vue-%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近又鼓起勇气鼓捣 vue 源码，然后不经意间瞅了瞅最早开始学习 vue 源码时跟着撸的一个 vue-observer 的实例，发现自己对于观察者模式还是有些不太明白。因此，在学习了《JavaScript 设计模式》的“观察者模式”一篇后，总算有了一点灵感。目前趁灵感还在，在此便记录下我的理解。</p>
<a id="more"></a>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>什么是观察者模式呢？首先引用一下比较正规的说法：</p>
<div class="note info">
            <p>观察者模式：又被称作发布-订阅者模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。</p>
          </div>
<p>简单来说，观察者模式主要实现的是一种对于未来可能发生的事情做的一种消息订阅处理。DOM2 级事件中的 addEventListener 方法以及生活中的订报纸都基本上就是这种原理。</p>
<p>首先我们得有发布者和订阅者，他们之间如何联系起来那就需要一个观察者平台。订阅者在观察者平台上向发布者添加订阅，待发布者在发布信息后，观察者平台获取到更新的信息后，给各个订阅者发提醒表示“你关注的发布者更新了文档哦～”，这样订阅者就能得到更新后的消息内容了。</p>
<p>其实发布者和订阅者都很简单，关键点还是观察者这个中间平台的实现。我们最终想要的结果其实可简化为如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察者（平台）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params"></span>) </span>&#123; <span class="comment">/***/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者（平台作者）</span></span><br><span class="line"><span class="keyword">const</span> publisher = &#123; <span class="attr">bookName</span>: <span class="string">'Hello World!'</span>, <span class="attr">content</span>: <span class="string">'This is a book'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者（在平台上订阅某作者）</span></span><br><span class="line"><span class="keyword">const</span> subscriber = observer(publisher);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后 publisher 改变什么东西，observer 触发订阅的消息即可。</span></span><br></pre></td></tr></table></figure>
<h3 id="简单的观察者"><a href="#简单的观察者" class="headerlink" title="简单的观察者"></a>简单的观察者</h3><p>前面分析到，观察者其实就是对于发布者和订阅者的一个中间平台，因此观察者所需要的能力包括：添加订阅者、消息推送和删除订阅者。先不考虑最终自动化处理发布订阅的流程以及删除操作，手动处理的大致流程为：</p>
<ol>
<li>平台上新增了一个订阅者，并订阅了一个发布者；</li>
<li>发布者更改了自身的某些属性；</li>
<li>平台通知订阅者，“你订阅的发布者更新了新内容”。</li>
</ol>
<p>因此我们可以简化一个观察者模型为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscriberList = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加订阅方法</span></span><br><span class="line">  addSubscriber(subscribFunc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (subscribFunc &amp;&amp; !<span class="keyword">this</span>.subscriberList.includes(subscribFunc)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subscriberList.push(subscribFunc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布者更新消息，触发所有的订阅方法</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscriberList.forEach(<span class="function"><span class="params">subscribFunc</span> =&gt;</span> subscribFunc());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> Observer();</span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="keyword">const</span> publisher = &#123; <span class="attr">bookName</span>: <span class="string">'Hello'</span> &#125;</span><br><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="keyword">const</span> subscriber = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`The publisher your followed update the book <span class="subst">$&#123;publisher.bookName&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者订阅事件需要平台完成</span></span><br><span class="line">observer.addSubscriber(subscriber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者更新消息</span></span><br><span class="line">publisher.bookName = <span class="string">'Hello World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台根据订阅者设置的事件通知订阅者，你有新订阅信息</span></span><br><span class="line">observer.notify();</span><br></pre></td></tr></table></figure>
<h3 id="稍复杂的观察者"><a href="#稍复杂的观察者" class="headerlink" title="稍复杂的观察者"></a>稍复杂的观察者</h3><p>前面基本上勾勒出了基本的观察者模型大致逻辑，虽然是纯“手动”操作，但是顺着这个机制走下去就没有太大问题。现在我们需要的是慢慢将“手动”转变为“自动”，而要实现这种转变则需要一些中间的封装，也就是中间的依赖类，此时我们的思路是这样的：</p>
<ol>
<li>为每个发布者生成一个对应的依赖收集对象（类比 Vue 中 data 返回的对象）</li>
<li>为负责依赖收集的对象添加订阅者事件（类比 Vue 中的 methods 和 computed 内容）</li>
<li>发布者更新内容，订阅者事件触发</li>
</ol>
<p>因为待依赖收集的对象总是动态变动的，因此我们还得维护一个全局的 target 对象来动态绑定当前变动的发布者，此时的代码可以抽象为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscriberList = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加订阅方法</span></span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &amp;&amp; !<span class="keyword">this</span>.subscriberList.includes(target)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subscriberList.push(target);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布者更新消息，触发所有的订阅方法</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscriberList.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间依赖的平台</span></span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"><span class="comment">// 发布者（data 对象中的属性，为了方便处理，直接扩出来了，写成对象也行）</span></span><br><span class="line"><span class="keyword">let</span> bookName = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">let</span> bookContent = <span class="string">"This is a book"</span>;</span><br><span class="line"><span class="keyword">let</span> publishInfo = <span class="string">''</span>; <span class="comment">// 消息提示</span></span><br><span class="line"><span class="comment">// 绑定当前的订阅者（method 方法）</span></span><br><span class="line"><span class="keyword">const</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  publishInfo = <span class="string">`The book <span class="subst">$&#123;bookName&#125;</span>‘s content is <span class="subst">$&#123;bookContent&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者还未订阅信息</span></span><br><span class="line"><span class="built_in">console</span>.log(publishInfo); <span class="comment">// ‘’</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者在平台上添加订阅事件，并推送用户目前的最新信息</span></span><br><span class="line">dep.depend();</span><br><span class="line">target();</span><br><span class="line"><span class="built_in">console</span>.log(publishInfo) <span class="comment">// The book Hello World‘s content is This is a book</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// publisher 更新消息</span></span><br><span class="line">bookContent = <span class="string">'The content is "Hello World"'</span>;</span><br><span class="line"><span class="comment">// 平台还未处理前，原信息没有改变</span></span><br><span class="line"><span class="built_in">console</span>.log(publishInfo) <span class="comment">// The book Hello World‘s content is This is a book</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台观察到 publisher 更新内容了，更新了用户的通知信息</span></span><br><span class="line">dep.notify();</span><br><span class="line"><span class="comment">// 呈现更新后的信息</span></span><br><span class="line"><span class="built_in">console</span>.log(publishInfo) <span class="comment">// The book Hello World‘s content is The content is "Hello World"</span></span><br></pre></td></tr></table></figure>
<p>与前面的相比，目前这一版的优点在于：</p>
<ol>
<li>每个发布者都有属于自己的小管家，而不是与各订阅者一一绑定（原绑定方式：发布者 -&gt; 平台 -&gt; 订阅者），方便消息推送管理；</li>
<li>平台能动态绑定发布者（原来是通过订阅者显示绑定发布者）；</li>
</ol>
<p>但是目前还有一些缺陷，那就是：<strong>还没有实现动态的观察变化</strong></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/Wm5-3hsqre7ft_f0YBnoeg" target="_blank" rel="noopener">以 Vue 为例，解释 JavaScript 的反应性</a></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>分析 Vue 的观察者模式（中）</title>
    <url>/2019/10/11/%E5%88%86%E6%9E%90-Vue-%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上篇<a href="/2019/10/10/分析-Vue-的观察者模式（上）/" title="分析 Vue 的观察者模式（上）">分析 Vue 的观察者模式（上）</a>中，简单实现了“手动”版观察者模式，而在本篇中我们继续沿着该思路往下探索，看如何实现“自动”版的观察者。</p>
<a id="more"></a>
<h3 id="完善的观察者"><a href="#完善的观察者" class="headerlink" title="完善的观察者"></a>完善的观察者</h3><p>紧接着上文的思路，因为我们只是实现了 Dep 依赖（管家），却还没有对平台的观察处理方式优化，因此我们需要将此步骤给完善起来。</p>
<p>首先，要实现发布者更新内容后自动触发订阅事件，那么我们需要的是对发布者内容改变的监听，ES5 中恰好有这么一种方法能满足我们的需求，那就是 <code>Object.defineProperty(...)</code>。其语法很简单，我们此处仅仅需要拦截 get 和 set 方法，大致写法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  name: <span class="string">'test'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, name, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> data.name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">    <span class="comment">// 调用 setter 方法，不可直接赋值，否则会死循环</span></span><br><span class="line">    <span class="comment">// 错误写法 obj[key] = newVal</span></span><br><span class="line">    <span class="comment">// 可查看 Vue 中的 setter 获取</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>既然有了能够观测发布者的方法，那么对于对象变更后的监听就能自动化处理了，那么先前手动触发 <code>dep.depend()</code> 和 <code>dep.notify()</code> 函数的操作就能整合入 <code>Object.defineProperty</code> 内了。</p>
<p>延续先前的逻辑，<code>dep.notify()</code> 方法执行都得在对象值变动之后，因此我们可以将此方法放入 set 函数内；而 <code>dep.depend()</code> 方法主要是将订阅者事件存储入自身的事件列表中，因此该方法执行一次就行，之后每次更新都触发 <code>notify</code> 来依次执行注册的函数即可。因此，在考虑只是传入简单对象的情况时，这阶段的代码思路大致是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （私人管家）依赖收集</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscriberList = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加订阅方法</span></span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="comment">// 此处添加对应订阅方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布者更新消息</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscriberList.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 依次处理订阅的方法</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （发布者和管家的联系方式）监听器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">data = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> val = data[key];</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">// get 时添加依赖，当有目标的时候才添加</span></span><br><span class="line">        <span class="keyword">if</span> (target) &#123;</span><br><span class="line">          dep.depend();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set 时触发更新</span></span><br><span class="line">        <span class="comment">// 此处用 setter 做变动，此处偷懒一下，不要直接赋值，会反复触发 set</span></span><br><span class="line">        val = newVal;</span><br><span class="line">        dep.notify();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么现在问题又有了。目前代码实现至此我们仅仅只是将发布者与其 Dep 依赖进行了关联，那么观察者又该如何将其获订阅者的事件与 Dep 存储的事件列表进行关联呢？从订阅者角度分析一下：</p>
<ol>
<li>订阅者决定好要订阅的内容（订阅者的函数）；</li>
<li>订阅者在对应的观察者平台上注册事件，绑定发布者信息；</li>
<li>观察者先联系到 Dep 管家，将订阅事件存放至管家处；</li>
<li>待管家拿到了发布者新情报，则响应所有存储好的订阅者的订阅事件了。</li>
</ol>
<p>思路逐渐清晰，那么这么个流程我们可以简化为如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">target = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.sub = [];</span><br><span class="line">  &#125;</span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &amp;&amp; !<span class="keyword">this</span>.sub.includes(target)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.sub.push(target);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.sub.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watcher</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  target = callback;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处触发一下监听对象的 get 方法，将 callback 方法加入 Dep 依赖的订阅队列中</span></span><br><span class="line">  <span class="comment">// 然后清除掉 target，防止重复注册</span></span><br><span class="line"></span><br><span class="line">  target = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watcher(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 此处是订阅事件</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样我们就讲观察者的订阅方法和 Dep 依赖给绑定上了。考虑到 watcher 的通用性，这里写了一个加强版的 demo，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （私人管家）依赖收集</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscriberList = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前的 watcher 加入 dep 中</span></span><br><span class="line">  addSub(watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscriberList.push(watcher)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加订阅方法</span></span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">      target.addDep(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布者更新消息，触发所有的订阅方法</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscriberList.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （平台）观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(data = &#123;&#125;, key = <span class="string">''</span>, cb = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    <span class="keyword">this</span>._data = data;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line"></span><br><span class="line">    target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 触发 getter，存储本 watcher</span></span><br><span class="line">    <span class="keyword">this</span>.value = data[key];</span><br><span class="line">    <span class="comment">// 防止反复触发</span></span><br><span class="line">    target = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addDep(dep) &#123;</span><br><span class="line">    dep.addSub(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">const</span> newVal = <span class="keyword">this</span>._data[<span class="keyword">this</span>.key];</span><br><span class="line">    <span class="keyword">this</span>.value = newVal;</span><br><span class="line">    <span class="keyword">this</span>.cb(newVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （发布者和管家的联系方式）监听器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">data = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> val = data[key];</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (target) &#123;</span><br><span class="line">          <span class="comment">// get 时添加依赖</span></span><br><span class="line">          dep.depend();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set 时触发更新</span></span><br><span class="line">        val = newVal;</span><br><span class="line">        dep.notify();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="keyword">const</span> publisher = &#123;</span><br><span class="line">  bookName: <span class="string">'book'</span>,</span><br><span class="line">  bookContent: <span class="string">'hello world'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管家开始观测发布者</span></span><br><span class="line">observer(publisher);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者在平台上订阅发布者的部分信息</span></span><br><span class="line"><span class="keyword">new</span> Watcher(publisher, <span class="string">'bookName'</span>, name =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`new book name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> Watcher(publisher, <span class="string">'bookContent'</span>, content =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`new book content is <span class="subst">$&#123;content&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者发布信息</span></span><br><span class="line">publisher.bookName = <span class="string">'new book'</span>;</span><br><span class="line">publisher.bookContent = <span class="string">'new content'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Vue-观察者的实现"><a href="#Vue-观察者的实现" class="headerlink" title="Vue 观察者的实现"></a>Vue 观察者的实现</h3><p>在看源码之前，首先让我们看看 Vue 的实现原理图：</p>
<p><img data-src="/images/vue-observer.jpeg" alt="Reactive"></p>
<p>先仅考虑 data 部分的观察者模式，我们可以看到大致步骤为：</p>
<ol>
<li>为发布者 data 做数据监听处理；</li>
<li>为劫持方法添加 Dep 依赖收集，<code>get</code> 存储 target 目标，set 设置 target 目标；</li>
<li>依赖收集触发后，触发 Watch 观察者，通知订阅者改变。</li>
</ol>
<p>因为流程图中只是详细展示了响应式部分的变动，为了便于大家更清楚的理解这部分的流程，所以这里先解释一下 Vue 中完整的流程：</p>
<ol>
<li>页面开始渲染，对 data 进行依赖收集；</li>
<li>依赖收集完毕，开始监测订阅者的方法，并存储原值方便变更时的对比；</li>
<li>因为依赖收集完毕，要存储原值则触发了 get 事件，此时添加 dep 依赖，将对应生成的 watcher 存储入依赖列表内</li>
<li>页面渲染完成，用户触发页面某些点击事件（比如按钮）；</li>
<li>点击事件绑定了某个 methods 方法，该 methods 方法使得 data 部分内容更新了；</li>
<li>因为已经对 data 进行了依赖收集，触发了对应的 set 方法；</li>
<li>set 方法对比新旧值发现值更新了，此时重新收集依赖新的值（特别是对象的情况），然后通知它的私有管家 Dep 进行更新；</li>
<li>Dep 依赖开始遍历其所存储的数组，为该发布者的订阅者们发送消息，触发订阅事件。</li>
<li>各订阅者事件触发 update 更新，此时便流转到 render 渲染，之后页面就更新啦！</li>
</ol>
<p>为了方便大家理解源码，这里手动实现了一个简单的 observer 模式，基本是按着源码的思路一点点撸出来的，注释很全，方便大家理解！</p>
<ul>
<li><a href="https://github.com/kazehaiya/vue-observe" target="_blank" rel="noopener">个人版 vue-observer 源码</a></li>
</ul>
<h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p>所有的 demo 都写入仓库了，仓库地址为：<a href="https://github.com/kazehaiya/vue-observe" target="_blank" rel="noopener">传送门</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端缓存查询状态</title>
    <url>/2019/08/15/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>为了提升用户的使用体验，多数场合我们都会对表单场景做一些缓存。当然最简单的情况是弹框处理下钻页面，这样基本上不用考虑换页返回时的状态缓存问题了，然而并不是所有的需求都满足这种场景，此处我就记录一下这次做缓存时的一些策略选择和遇到的问题。</p>
<a id="more"></a>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在做项目迭代时，第一期因为时间的原因，在保证原有功能的情况下，并没有做缓存处理。在这一期的项目迭代时，应用户和产品的需求，在原有的逻辑基础上添加了缓存处理。要求仅从下钻页面返回时保留离开的状态，否则呈现默认的状态。</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>项目总体有三层：</p>
<ul>
<li>登陆与权限判断层</li>
<li>公共路由层</li>
<li>业务页面层</li>
</ul>
<p>登陆与权限判断层主要处理用户的登陆信息和对应页面的权限拦截，对于无页面权限的跳转和未登录状态做重定向处理，此外全局 vuex 存储获得的页面信息。</p>
<p>公共路由层主要处理获取的页面路由结构，同时与权限路由的菜单配置绑定，为各页面具体的权限约束提供对应的配置方法，方便产品将其与用户角色做相关绑定。</p>
<p>业务页面层仅关注对应业务逻辑的开发以及相关权限控制，统一接口和方法处理权限。</p>
<h3 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h3><p>实现缓存的方法有多个，当前考虑的可行的方案有三种，分别是：</p>
<ul>
<li>vuex 做查询缓存</li>
<li>keep-alive 做页面缓存</li>
<li>webStorage 做条件缓存</li>
</ul>
<p>首先说一下最后选择的方案是：sessionStorage 做条件缓存。这里分别来分析一下各方案的优缺点。</p>
<h4 id="vuex-方案"><a href="#vuex-方案" class="headerlink" title="vuex 方案"></a>vuex 方案</h4><p>vuex 方案是最容易想到的一个方案，毕竟对于跨页面的单页应用来说，在数据的传递上可谓是非常便捷的，对于查询缓存来说，其优点如下：</p>
<ul>
<li>获取数据和传递数据容易</li>
<li>存储数据的操作简单，代码量不大</li>
</ul>
<p>但是其缺点也很明显：</p>
<ul>
<li>子页面刷新再返回会导致缓存的数据清空</li>
<li>无论是从子页面还是从别的页面切换回来，此都会缓存查询条件</li>
</ul>
<p><strong>缺点的解决思路：</strong></p>
<p>对于数据会清空的问题，vuex 需要配合 webStorage 对刷新情况做处理；</p>
<p>对于任意页面都会缓存查询条件问题，又需要配合路由来做处理。</p>
<h4 id="keep-alive-方案"><a href="#keep-alive-方案" class="headerlink" title="keep-alive 方案"></a>keep-alive 方案</h4><p>keep-alive 方案与 vuex 方案基本差别不带，其缓存整个组件的状态，来保证跳转至其它组件后，当前组件的状态不改变。与 vuex 写法相比，其优点还包括：</p>
<ul>
<li>整体的状态能得以保存，无需过多的数据缓存处理</li>
</ul>
<p>但是其缺点相对 vuex 来说，也有一些：</p>
<ul>
<li>页面参数共享不是很方便</li>
<li>每新增一个缓存页面都需要更新一下 include 数组</li>
</ul>
<p><strong>缺点的解决思路：</strong><br>与 vuex 的解决思路基本一致，但是此还有另外一种操作方法</p>
<p>keep-alive 还有一种配合路由 meta 的操作写法。但是由于项目路由基本上是动态的，有后台提供相应的路由结构，配置相应的字段还需要与后台沟通，如果考虑不是很充足对于之后的开发也不是很友好；此外，该方法对于页面回退情况有相应问题（刷新同样无法处理）。因此此方案 pass 了。</p>
<h4 id="webStorage-方案"><a href="#webStorage-方案" class="headerlink" title="webStorage 方案"></a>webStorage 方案</h4><p>鉴于之前的两种方案都包含路由的处理以及 webStorage 的使用，从代码复杂度来衡量，最终还是选用了此方法。具体的思路为：</p>
<ol>
<li>路由层添加 <code>$route</code> 的监听，并将其存入路由的 vuex 内，存储页面的 <code>to</code> 与 <code>from</code>。</li>
<li>子页面删除 <code>mount</code> 钩子，监听对应的 <code>from</code> 的路由，并设置 <code>immediate: true</code>，为需要赋值缓存的页面做单独赋值处理，否则不做操作（如有默认查询则设置默认查询）</li>
<li>在触发查询操作之前，缓存查询条件至对应的 sessionStorage</li>
</ol>
<p>当然，这种方法并不是说缺点很少，其实它也有一些痛点没有解决：</p>
<ul>
<li>难以抽象出通用的处理逻辑，仅能对路由层级做一层简单的抽象和存储</li>
<li>默认值赋值操作比较麻烦，特别是组件拆分比较细的情况</li>
<li>需要控制好 nextTick</li>
</ul>
<h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><h4 id="inject-和-provide"><a href="#inject-和-provide" class="headerlink" title="inject 和 provide"></a>inject 和 provide</h4><p>在使用 vuex 对监听的路由参数做缓存之前，首先考虑的是 inject 和 provide 来做动态传递，毕竟业务组件都在同一个 router-view 之下，这样做参数透传原则上是可行的。</p>
<p>但是问题是，不知道为何，对于 <code>from</code> 的路由总是监听不到，inject 获取的值一直为 undefined（即使能打印出来结果）。由于使用 JSON.stringfy 分析 from 时会报错，暂时也没法处理该问题，因此采用了 vuex 的备选方案。</p>
<blockquote>
<p>class 风格的 ProvideReactive 还没有做过尝试，之后看能否可行</p>
</blockquote>
<h4 id="分页问题"><a href="#分页问题" class="headerlink" title="分页问题"></a>分页问题</h4><p>在赋值默认值时，由于分页参数会存储在传参之中，但是总数值不会。虽然做初始化赋值之后查询内容与预期的结果一致，但是唯独分页组件的当前页数不正确（element UI 的 el-pagination），无论 currentPage 值为多少，其最终显示的结果仍然为 1。</p>
<p><strong>原因：</strong></p>
<p><code>el-pagination</code> 处理分页逻辑时，在 <code>total / pageSize &lt; currentPage</code> 的情况，其会使用默认的 <code>internalCurrentPage</code> 值，而此属性的默认值为 1。在查询完结果后在为对应的 <code>total</code> 和 <code>currentPage</code> 赋值时，因为 <code>currentPage</code> 和查询返回值是一致的，对于相同值的情况，其 <code>internalPageCount</code> 的新旧值就判断一致了，因此 pager 的显示就会一直为 1。</p>
<p><strong>解决：</strong><br>解决思路是在初始化时将 count 值设置大一些，或者缓存上一次的 count 值，然后初始化赋值。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题大全</title>
    <url>/2020/01/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>临近春节，很多人又考虑换工作了，考虑到还有一年多的工作的时间，提前总结总结也是不错的，这里就记录一下最近翻到了以及先前自己总结的一些问题，为之后的复习做准备。</p>
<a id="more"></a>
<h3 id="HTML-篇"><a href="#HTML-篇" class="headerlink" title="HTML 篇"></a>HTML 篇</h3><h4 id="H5-有哪些新特性"><a href="#H5-有哪些新特性" class="headerlink" title="H5 有哪些新特性"></a>H5 有哪些新特性</h4><ul>
<li>语义化标签（header、footer、nav、aside、article、section 等）</li>
<li>增强表单（<a href="https://www.jianshu.com/p/d8b4c4055adc" target="_blank" rel="noopener">传送门</a>）</li>
<li>本地存储</li>
<li>多媒体元素标签： vedio 与 audio</li>
<li>新增地理定位方法</li>
<li>canvas 画布</li>
<li>拖放事件</li>
<li>webWorker</li>
<li>webSocket</li>
</ul>
<h4 id="webStorage-和-Cookie-的区别以及各自的优缺点"><a href="#webStorage-和-Cookie-的区别以及各自的优缺点" class="headerlink" title="webStorage 和 Cookie 的区别以及各自的优缺点"></a>webStorage 和 Cookie 的区别以及各自的优缺点</h4><table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据生命周期</td>
<td>一般由服务器生成，可以设置过期时间</td>
<td>除非被清理，否则一直存在</td>
<td>页面关闭就清理</td>
</tr>
<tr>
<td>数据存储大小</td>
<td>4K</td>
<td>5M</td>
<td>5M</td>
</tr>
<tr>
<td>与服务端通信</td>
<td>每次都会携带在 header 中，对于请求性能影响</td>
<td>不参与</td>
<td>不参与</td>
</tr>
</tbody>
</table>
<blockquote>
<p>从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。</p>
</blockquote>
<h4 id="svg-与-canvas"><a href="#svg-与-canvas" class="headerlink" title="svg 与 canvas"></a>svg 与 canvas</h4><table>
<thead>
<tr>
<th>svg</th>
<th>canvas</th>
</tr>
</thead>
<tbody>
<tr>
<td>svg 是一种使用 xml 描述 2D 图形的语言，<strong>矢量图</strong></td>
<td>canvas 通过 javascript 来绘制 2D 图形，<strong>标量图</strong></td>
</tr>
<tr>
<td>svg 基于 xml，这意味着 svg DOM  中的每个元素都是可用的，您可以为某个元素附加 javascript 事件处理器</td>
<td>canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象</td>
</tr>
</tbody>
</table>
<h4 id="移动端页面适配方案"><a href="#移动端页面适配方案" class="headerlink" title="移动端页面适配方案"></a>移动端页面适配方案</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 获取缩放大小</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> scale = <span class="number">1</span> / <span class="built_in">window</span>.devicePixelRatio;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// content 配置默认缩放大小，不允许缩放</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> content = <span class="string">'width=device-width,initial-scale='</span> + scale + <span class="string">', maximum-scale='</span> + scale + <span class="string">', minimum-scale='</span> + scale + <span class="string">', user-scalable=no'</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 动态 meta 标签适配</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.querySelector(<span class="string">'meta[name="viewport"]'</span>).setAttribute(<span class="string">'content'</span>, content);</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 基准 font-size 设置</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.documentElement.style.fontSize = <span class="built_in">document</span>.documentElement.clientWidth / <span class="number">75</span> + <span class="string">'px'</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="CSS-篇"><a href="#CSS-篇" class="headerlink" title="CSS 篇"></a>CSS 篇</h3><h4 id="CSS3-的新特性"><a href="#CSS3-的新特性" class="headerlink" title="CSS3 的新特性"></a>CSS3 的新特性</h4><ul>
<li>transition（过渡动画）、animation（贞动画）、transform（形状变化）</li>
<li>新增选择器（伪类选择器、相邻选择器等）</li>
<li>边框、阴影、滤镜等</li>
<li>弹性布局、栅格布局</li>
</ul>
<blockquote>
<p><a href="https://juejin.im/post/5a0c184c51882531926e4294" target="_blank" rel="noopener">推荐阅读</a></p>
</blockquote>
<h4 id="position-默认值以及默认基于什么定位"><a href="#position-默认值以及默认基于什么定位" class="headerlink" title="position 默认值以及默认基于什么定位"></a>position 默认值以及默认基于什么定位</h4><p>默认值为：static；</p>
<p>定位是基于最近的且 position 值为非 static 的父元素；</p>
<h4 id="水平垂直居中有哪些方法。（至少-3-种）"><a href="#水平垂直居中有哪些方法。（至少-3-种）" class="headerlink" title="水平垂直居中有哪些方法。（至少 3 种）"></a>水平垂直居中有哪些方法。（至少 3 种）</h4><ul>
<li>translate 方法</li>
<li>position + margin 定位</li>
<li>flex 布局</li>
<li>table-ceil 方法</li>
<li>padding 实现</li>
</ul>
<h4 id="清除浮动有哪些方式。"><a href="#清除浮动有哪些方式。" class="headerlink" title="清除浮动有哪些方式。"></a>清除浮动有哪些方式。</h4><ul>
<li>after 伪类（IE 需要设置 zoom: 1）</li>
<li>空 div 元素，设置 css ： <code>clear: both</code></li>
<li>父级形成 BFC 结构，如: <code>overflow: hidden</code></li>
</ul>
<h4 id="BFC-的相关知识考察"><a href="#BFC-的相关知识考察" class="headerlink" title="BFC 的相关知识考察"></a>BFC 的相关知识考察</h4><blockquote>
<p>BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。</p>
</blockquote>
<p><strong>常见问题：</strong></p>
<ul>
<li>高度塌陷</li>
<li>外边距折叠</li>
</ul>
<p><strong>实现方式：</strong></p>
<ul>
<li>浮动元素，float 除 none 以外的值</li>
<li>绝对定位元素，position（absolute，fixed）</li>
<li>display 为以下其中之一的值 inline-block，table-cells，table-captions</li>
<li>overflow 除了 visible 以外的值（hidden，auto，scroll）</li>
<li>……</li>
</ul>
<blockquote>
<p>参考文章： <a href="/2019/05/03/浅谈-BFC/" title="浅谈 BFC">浅谈 BFC</a></p>
</blockquote>
<h4 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h4><p>实现以下字体样式效果</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="comment">&lt;!-- 红 --&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="comment">&lt;!-- 白 --&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="comment">&lt;!-- 红 --&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="comment">&lt;!-- 白 --&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... n 个 p --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span><span class="comment">&lt;!-- 黄 --&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="comment">&lt;!-- 蓝 --&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="comment">&lt;!-- 蓝 --&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="comment">&lt;!-- 蓝 --&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... n 个 p --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="comment">&lt;!-- 绿 --&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:nth-child(2n)</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:nth-child(2n+1)</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此处得考虑优先级问题</span></span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-class">.center</span> ~ <span class="selector-tag">p</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:last-child)</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JavaScript-篇"><a href="#JavaScript-篇" class="headerlink" title="JavaScript 篇"></a>JavaScript 篇</h3><h4 id="ES6-有哪些新特性"><a href="#ES6-有哪些新特性" class="headerlink" title="ES6+ 有哪些新特性"></a>ES6+ 有哪些新特性</h4><ul>
<li>let, const 变量</li>
<li>模板字符串 “`”</li>
<li>解构赋值 与 扩展运算符（<code>...</code> 运算符）</li>
<li>Promise 与 async</li>
<li>Map、Set</li>
<li>class</li>
<li>Array 的一些原生方法</li>
<li>箭头函数、默认值</li>
<li>…</li>
</ul>
<blockquote>
<p>let 与闭包、解构 undefined 和 null 的值时的默认值问题、class 与原型链、Set 与 除重方法等等</p>
</blockquote>
<h4 id="Promise-all-的实现"><a href="#Promise-all-的实现" class="headerlink" title="Promise.all() 的实现"></a>Promise.all() 的实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseAll</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(promiseArr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You must pass an array'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> arrayLen = promiseArr.length;</span><br><span class="line">  <span class="keyword">const</span> resolvedArr = [];</span><br><span class="line">  <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(item)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolvedArr.push(res);</span><br><span class="line">        pos++;</span><br><span class="line">        <span class="keyword">if</span> (pos === arrayLen) &#123;</span><br><span class="line">          resolve(resolvedArr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组去括号并去重"><a href="#数组去括号并去重" class="headerlink" title="数组去括号并去重"></a>数组去括号并去重</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 试题</span></span><br><span class="line"><span class="keyword">let</span> originArr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">3</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">0</span>]], <span class="number">4</span>, [[[<span class="number">5</span>]]]]</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现的方法:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatArr</span>(<span class="params">originArr</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">flattenDeep</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> resArr = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">      resArr = arr.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>[...a, ...flattenDeep(b)], resArr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resArr.push(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resArr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> flatArr = flattenDeep(originArr);</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(flatArr)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testArr = [<span class="number">1</span>, [[<span class="number">2</span>], [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]], <span class="number">5</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(formatArr(testArr));</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatArr</span>(<span class="params">originArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> flatArr = originArr.toString().split(<span class="string">','</span>);</span><br><span class="line">  <span class="keyword">const</span> filteredArr = [...new <span class="built_in">Set</span>(flatArr)];</span><br><span class="line">  <span class="keyword">return</span> filteredArr.map(<span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">Number</span>(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="This-指向问题"><a href="#This-指向问题" class="headerlink" title="This 指向问题"></a>This 指向问题</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  a: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.a()</span><br><span class="line"><span class="comment">// 输出 undefined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考文章： <a href="/2019/05/19/深入了解-this/" title="深入了解 this">深入了解 this</a></p>
</blockquote>
<h4 id="以下代码依次输出的结果"><a href="#以下代码依次输出的结果" class="headerlink" title="以下代码依次输出的结果"></a>以下代码依次输出的结果</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'as1'</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end as1'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'as2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line"></span><br><span class="line">async1(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">rs, rj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">  rs()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'then'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">as1</span><br><span class="line">as2</span><br><span class="line">promise</span><br><span class="line">end</span><br><span class="line">end as1</span><br><span class="line">then</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>
<h3 id="HTTP-篇"><a href="#HTTP-篇" class="headerlink" title="HTTP 篇"></a>HTTP 篇</h3><h4 id="常用的-HTTP-方法有哪些"><a href="#常用的-HTTP-方法有哪些" class="headerlink" title="常用的 HTTP 方法有哪些"></a>常用的 HTTP 方法有哪些</h4><ul>
<li>GET：用于请求访问已经被 URI 识别的资源，可以通过 URL 传参给服务器</li>
<li>POST：用于传输信息给服务器,主要功能 GET 类似，但一般推荐使用 POST 方式</li>
<li>PUT：传输文件，报文主体中包含文件内容，保存到对应的 URI 位置</li>
<li>HEAD：获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效</li>
<li>DELETE：删除文件，与 PUT 方法相反，删除对应 URI 位置的文件</li>
<li>OPTIONS：查询对应 URI 支持的 HTTP 方法</li>
</ul>
<h4 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h4><ul>
<li>GET 重点从服务器上获取资源，POST 重点向服务器发送数据</li>
<li>GET 传输的数据量小，因为受 URL 长度限制，但效率较高；POST 可以传输大量数据，所以上传文件时只能用 POST 方式；</li>
<li>GET 是不安全的，因为 URL 是可见的，可能会泄露私密信息，如密码等；<br>POST 较 GET 安全性较高；</li>
</ul>
<h4 id="请求报文和响应报文"><a href="#请求报文和响应报文" class="headerlink" title="请求报文和响应报文"></a>请求报文和响应报文</h4><p><strong>a. 请求报文包含三部分：</strong></p>
<ul>
<li>请求行：包含请求方法、URI、HTTP版本信息</li>
<li>请求首部字段</li>
<li>请求内容实体</li>
</ul>
<p><strong>b. 响应报文包含三部分：</strong></p>
<ul>
<li>状态行：包含HTTP版本、状态码、状态码的原因短语</li>
<li>响应首部字段</li>
<li>响应内容实体</li>
</ul>
<h4 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h4><ul>
<li>200：表示请求已成功，请求所希望的响应头或数据体将随此响应返回。</li>
<li>301：永久重定向，资源已永久分配新 URI。</li>
<li>302：临时重定向，资源已临时分配新 URI。</li>
<li>304：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</li>
<li>307：临时重定向，POST 不会变成 GET。</li>
<li>401：需要通过 HTTP 认证，或认证失败。</li>
<li>403：表示对请求资源的访问被服务器拒绝了。</li>
<li>404：表示服务器找不到你请求的资源。</li>
<li>500：表示服务器执行请求的时候出错了。</li>
<li>503：表示服务器超负载或正停机维护，无法处理请求。</li>
</ul>
<h4 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h4><p><strong>a. 强缓存相关的字段：</strong></p>
<ul>
<li>expires</li>
<li>cache-control：max-age=number</li>
</ul>
<p><strong>b. 协商缓存相关的字段：</strong></p>
<ul>
<li>Last-Modified/If-Modified-Since</li>
<li>Etag/If-None-Match</li>
</ul>
<p><img data-src="/images/http-cache.png" alt></p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><ul>
<li>不要使用空 src 的 <code>image</code> 标签</li>
<li>减少 iframe 的数量，其开销高，会阻塞 onload 事件，同域会抢资源</li>
<li>减少不必要的 DOM 元素</li>
<li>图片懒加载</li>
<li>使用 CDN 的资源</li>
<li>css 样式放在顶部 header，js 放在 body 最后面</li>
</ul>
<h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><ul>
<li>能使用 base64 的尽量使用 base64</li>
<li>背景图加载</li>
<li>尽量不使用 @import 语法</li>
</ul>
<h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><ul>
<li>减少 DOM 访问</li>
<li>多次修改统一节点时使用 documentFragment 文档片段来做中间拼接处理</li>
<li>减少获取 clientHeight 等信息的次数，会造成反复重绘</li>
<li>合理添加事件监听函数</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="短链接的生成思路"><a href="#短链接的生成思路" class="headerlink" title="短链接的生成思路"></a>短链接的生成思路</h4><p>一般链接的特点：不考虑 query 字段，一般就只有 26 个英文字母，而短链接的特点是含有 ([a-z][A-Z][0-9])，因此一个粗略的想法就是将 26 进制转化成 62 进制，因此将对应算法写出来基本上就算是答道点子上了。</p>
<p>算法的大致思路为： 26进制 -&gt; 10 进制 -&gt; 62 进制</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://www.cnblogs.com/FunkyEric/p/8979227.html" target="_blank" rel="noopener">前端面试问题</a></li>
</ul>
]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>skill</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建</title>
    <url>/2019/03/31/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近想着使用 github.io 来存放个人博客，因此参考一些博客搭建的文章，我也照着搭建了一个，这里记录一些搭建的配置，以便于主题替换升级时的参考。</p>
<a id="more"></a>
<h3 id="需要的环境"><a href="#需要的环境" class="headerlink" title="需要的环境"></a>需要的环境</h3><ol>
<li>个人的 github 账号</li>
<li>系统环境<ul>
<li>git（需要 sshkey 绑定关联 github）</li>
<li>node &amp; npm（需全局安装 hexo-cli）</li>
<li>vscode</li>
</ul>
</li>
</ol>
<blockquote>
<p>生成 ssh 命令： <code>ssh-keygen -t rsa -C &quot;邮箱地址&quot;</code></p>
</blockquote>
<h3 id="博客配置"><a href="#博客配置" class="headerlink" title="博客配置"></a>博客配置</h3><blockquote>
<p>这里分为两部分的配置，一部分为 <code>hexo init</code> 生成项目时的根目录里的 <code>config.yml</code>，这里描述为“用户信息”；另外一个是安装了 <code>hexo</code> 主题时，theme/next 文件夹内的 <code>config.yml</code>，这里描述为“主题信息”。</p>
</blockquote>
<h4 id="用户信息配置"><a href="#用户信息配置" class="headerlink" title="用户信息配置"></a>用户信息配置</h4><h5 id="网站配置"><a href="#网站配置" class="headerlink" title="网站配置"></a>网站配置</h5><p>配置中文和中国时区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure>
<h5 id="关联-Github"><a href="#关联-Github" class="headerlink" title="关联 Github"></a>关联 Github</h5><p>发布地址关联，需要在 github 中创建 github.io 仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:githubName/githubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<h5 id="主题选用"><a href="#主题选用" class="headerlink" title="主题选用"></a>主题选用</h5><p>这里选用的是 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">hexo-theme-next</a> 主题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入博客项目创建 theme 文件</span></span><br><span class="line">mkdir themes</span><br><span class="line"><span class="comment"># 拷贝主题</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>之后修改主题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">所有主题仓库传送门</a></p>
</blockquote>
<h5 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h5><p>安装插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add hexo-symbols-count-time</span><br></pre></td></tr></table></figure>
<p>用户信息添加如下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：需要清空缓存重启：<code>hexo clean &amp; hexo g &amp; hexo s</code></p>
</blockquote>
<h4 id="主题信息配置"><a href="#主题信息配置" class="headerlink" title="主题信息配置"></a>主题信息配置</h4><h5 id="页面样式"><a href="#页面样式" class="headerlink" title="页面样式"></a>页面样式</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># schema 更改选中值</span></span><br><span class="line">scheme: Gemini</span><br><span class="line"></span><br><span class="line"><span class="comment">## next 插件扩展</span></span><br><span class="line">vendors:</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># Some contents...</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： plugin 得自己添加，theme-config 中的插件添加参考 <a href="https://theme-next.org/docs/getting-started/" target="_blank" rel="noopener">https://theme-next.org/docs/getting-started/</a></p>
</blockquote>
<h5 id="菜单扩展"><a href="#菜单扩展" class="headerlink" title="菜单扩展"></a>菜单扩展</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  schedule: /schedule/ || calendar</span><br><span class="line">  sitemap: /sitemap.xml || sitemap</span><br><span class="line">  <span class="comment"># commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>将未启用的启用需要先创建对应的文件夹，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">"about"</span></span><br><span class="line"><span class="comment">## 此会在 source 文件夹内创建一个 about 文件夹，默认有一个 index.md</span></span><br><span class="line"><span class="comment">## 修改此 index.md，在顶部的 data 下面新增一行 type: "about"</span></span><br><span class="line"><span class="comment">## 其余的可类比</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：type 与文件夹保持一致，about、categories、tags 需要 type</p>
</blockquote>
<h5 id="tag-云添加背景色"><a href="#tag-云添加背景色" class="headerlink" title="tag 云添加背景色"></a>tag 云添加背景色</h5><p>更改 tag 云配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TagCloud settings for tags page.</span></span><br><span class="line"><span class="attr">tagcloud:</span></span><br><span class="line">  <span class="comment"># All values below are same as default, change them by yourself.</span></span><br><span class="line">  <span class="attr">min:</span> <span class="number">14</span> <span class="comment"># Minimun font size in px</span></span><br><span class="line">  <span class="attr">max:</span> <span class="number">14</span> <span class="comment"># Maxium font size in px</span></span><br><span class="line">  <span class="attr">start:</span> <span class="string">"#fff"</span> <span class="comment"># Start color (hex, rgba, hsla or color keywords)</span></span><br><span class="line">  <span class="attr">end:</span> <span class="string">"#fff"</span> <span class="comment"># End color (hex, rgba, hsla or color keywords)</span></span><br><span class="line">  <span class="attr">amount:</span> <span class="number">200</span> <span class="comment"># Amount of tags, change it if you have more than 200 tags</span></span><br></pre></td></tr></table></figure>
<p>在 <code>theme/next/layout</code> 文件夹中添加文件 <code>tag-color.swig</code>，并输入一下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> alltags = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'tag-cloud-tags'</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> tags = alltags[<span class="number">0</span>].getElementsByTagName(<span class="string">'a'</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> lastPos = tags.length - <span class="number">1</span>;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">for</span> (<span class="keyword">var</span> i = lastPos; i &gt;= <span class="number">0</span>; i--) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">75</span>+<span class="number">130</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> g = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">75</span>+<span class="number">100</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> b = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">75</span>+<span class="number">80</span>);</span></span><br><span class="line"><span class="actionscript">    tags[i].style.background = <span class="string">"rgb("</span>+r+<span class="string">","</span>+g+<span class="string">","</span>+b+<span class="string">")"</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.tag-cloud-tags</span> &#123;</span></span><br><span class="line">    font-family: Helvetica, Tahoma, Arial;</span><br><span class="line">    text-align: center;</span><br><span class="line">    counter-reset: tags;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.tag-cloud-tags</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    margin: 8px 5px 0px 0px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-class">.tag-cloud-tags</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line">    border: none;</span><br><span class="line"><span class="css">    <span class="selector-tag">box-shadow</span>: 0<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 15<span class="selector-tag">px</span> 0<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0,0,0,<span class="selector-class">.4</span>);</span></span><br><span class="line"><span class="css">    <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(1<span class="selector-class">.1</span>);</span></span><br><span class="line"><span class="css">    <span class="comment">/*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">transition-duration</span>: 0<span class="selector-class">.15s</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后修改同级文件 <code>page.swig</code>，找到 <code>class=&quot;tag-cloud&quot;</code>，将该部分底部引入改配置文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"tag-cloud"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"tag-cloud-title"</span>&gt;</span><br><span class="line">    &#123;&#123; _p(<span class="string">'counter.tag_cloud'</span>, site.tags.length) &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"tag-cloud-tags"</span>&gt;</span><br><span class="line">    &#123;&#123; tagcloud(&#123;</span><br><span class="line">      min_font   : theme.tagcloud.min,</span><br><span class="line">      max_font   : theme.tagcloud.max,</span><br><span class="line">      amount     : theme.tagcloud.amount,</span><br><span class="line">      color      : <span class="keyword">true</span>,</span><br><span class="line">      start_color: theme.tagcloud.start,</span><br><span class="line">      end_color  : theme.tagcloud.end&#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &#123;% include <span class="string">'tag-color.swig'</span> %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h5 id="其它扩展"><a href="#其它扩展" class="headerlink" title="其它扩展"></a>其它扩展</h5><p>官网以有详细的配置，详见 next-theme 官网配置，<a href="https://theme-next.org/docs/theme-settings/" target="_blank" rel="noopener">传送门</a></p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo 官网</a></li>
<li><a href="https://theme-next.org/docs/" target="_blank" rel="noopener">next-theme</a></li>
<li><a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md" target="_blank" rel="noopener">Counter 配置</a></li>
<li><a href="https://blog.csdn.net/as480133937/article/details/100138838/" target="_blank" rel="noopener">Hexo-Next 主题博客个性化配置超详细，超全面(两万字)</a></li>
<li><a href="https://segmentfault.com/a/1190000014085547" target="_blank" rel="noopener">为Hexo添加Gitalk评论插件</a></li>
<li><a href="https://blog.csdn.net/w47_csdn/article/details/88858343" target="_blank" rel="noopener">解决配置gitalk插件后初始化登录时跳转回首页</a></li>
</ul>
]]></content>
      <categories>
        <category>Env</category>
      </categories>
      <tags>
        <tag>Env</tag>
      </tags>
  </entry>
  <entry>
    <title>发布一个 vue 包</title>
    <url>/2019/04/14/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA-vue-%E5%8C%85/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>文章用来纪录我如何从零开始，通过 webpack4 发布一个 vue 的 npm 包，同时使用的是 es6 语法。涉及到的知识点包括：</p>
<ul>
<li>webpack4</li>
<li>npm 包的发布</li>
<li>babel 配置</li>
<li>vue 配置</li>
</ul>
<a id="more"></a>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="了解相关知识"><a href="#了解相关知识" class="headerlink" title="了解相关知识"></a>了解相关知识</h4><p>首先需要了解相关基础知识，由简单到难，依次列举如下：</p>
<ol>
<li>如何发布一个 npm 包，需要准备些什么？</li>
<li>webpack 简单的打包配置需要哪些</li>
<li>如何配置 babel 的 es6 支持</li>
<li>如何配置 vue 的支持</li>
<li>如何配置 vue 的 @、@src 等引用</li>
<li>包内的 vue 的组件该如何编写</li>
<li>如何优化打包的体积</li>
</ol>
<h4 id="发包前的准备"><a href="#发包前的准备" class="headerlink" title="发包前的准备"></a>发包前的准备</h4><h5 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h5><p>发布 npm 包首先需要一个 npm 账号。npm 添加账号的方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm adduser</span><br><span class="line"><span class="comment">## 之后会提示你输入 userName 和 password</span></span><br><span class="line"><span class="comment">## ...</span></span><br><span class="line"><span class="comment">## 保存后登陆</span></span><br><span class="line">npm login</span><br></pre></td></tr></table></figure>
<h5 id="创建待发布的包"><a href="#创建待发布的包" class="headerlink" title="创建待发布的包"></a>创建待发布的包</h5><p>创建包的方法也十分简单，此处用 yarn 来创建一个 npm 包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先进入对应文件夹，然后</span></span><br><span class="line">yarn init</span><br><span class="line"><span class="comment"># 之后根据提示输入项目名称、版本等内容即可</span></span><br></pre></td></tr></table></figure>
<h5 id="规范化-package-json-内容"><a href="#规范化-package-json-内容" class="headerlink" title="规范化 package.json 内容"></a>规范化 <code>package.json</code> 内容</h5><p>当然，要发布一个比较规范的包，仅默认的一些配置还是不够的，<code>package.json</code> 的详细配置可见<a href="http://javascript.ruanyifeng.com/nodejs/packagejson.html" target="_blank" rel="noopener">「中文文档」</a>，总结过后，我们可以配置这么一些字段：</p>
<ul>
<li><code>name</code>:         项目名称</li>
<li><code>version</code>:      当前包的版本</li>
<li><code>keywords</code>:     关键词，方便搜索</li>
<li><code>description</code>:  项目描述</li>
<li><code>repository</code>:   项目地址</li>
<li><code>author</code>:       作者</li>
<li><code>contributors</code>: 项目开发人员</li>
<li><code>files</code>:        项目包括的文件</li>
<li><code>scripts</code>:      webpack 打包会用到</li>
<li><code>style</code>:        项目样式所存放的地址</li>
<li><code>license</code>:      许可证（一般 MIT 即可）</li>
</ul>
<p>安装时常用的有此三种依赖：</p>
<ul>
<li>dependencies: 必须依赖的包，会在用户安装此包时，将该部分的包一并装上，会更新版本（如果版本过低）</li>
<li>peerDependencies: 会在用户安装此包时，如果该模块内的包没有或者用户安装的对应包版本过低，会用 warning 提示用户安装（不会自动安装）</li>
<li>devDependencies: 开发时会用到的包，打包至项目的或者 webpack 配置需要的等等，不会帮用户安装或者给予提示</li>
</ul>
<p>它们<strong>依次</strong>对应的指令是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dependencies</span></span><br><span class="line">yarn add xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># peerDependencies</span></span><br><span class="line">yarn add xxx -P</span><br><span class="line"></span><br><span class="line"><span class="comment"># devDependencies</span></span><br><span class="line">yarn add xxx -D</span><br></pre></td></tr></table></figure>
<h3 id="初始化包的配置"><a href="#初始化包的配置" class="headerlink" title="初始化包的配置"></a>初始化包的配置</h3><p>两种安装方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局安装</span></span><br><span class="line">npm i -g webpack webpack-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目安装</span></span><br><span class="line">yarn add webpack webpack-cli -D</span><br></pre></td></tr></table></figure>
<p>在先前创建的项目内新建一个 <code>webpack.config.js</code> 文件，并写入以下基础内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：webpack4 版本这两个是分开的，都得装</p>
</blockquote>
<h4 id="配置-webpack"><a href="#配置-webpack" class="headerlink" title="配置 webpack"></a>配置 webpack</h4><h5 id="出入口文件配置"><a href="#出入口文件配置" class="headerlink" title="出入口文件配置"></a>出入口文件配置</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 module.exports 文件内添加 entry 和 output 两字段</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    &lt;自定义名&gt;: &lt;文件地址&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: &lt;输出地址&gt;,</span><br><span class="line">    publicPath: &lt;虚拟路径，server 路径有关&gt;,</span><br><span class="line">    filename: &lt;输出的文件名&gt;,</span><br><span class="line">    library: &lt;包名&gt;,</span><br><span class="line">    libraryTarget: &lt;库的支持，一般用 umd 即可&gt;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 例子</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'test'</span>: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: resolve(<span class="string">'lib'</span>),</span><br><span class="line">    publicPath: <span class="string">'/lib/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    library: <span class="string">'test'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'umd'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="loader-配置"><a href="#loader-配置" class="headerlink" title="loader 配置"></a>loader 配置</h5><h6 id="vue-loader"><a href="#vue-loader" class="headerlink" title="vue-loader"></a>vue-loader</h6><p>由于项目是关于 vue 的，因此可参考<a href="https://vue-loader.vuejs.org/zh/" target="_blank" rel="noopener">「vue-loader 官网」</a>，跟着对应内容配置即可，解析 vue 的 loader 配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rules 部分</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">  loader: <span class="string">'vue-loader'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// plugins 部分</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> VueLoaderPlugin()</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve 部分</span></span><br><span class="line">resolve: &#123;</span><br><span class="line">  <span class="comment">// 设置别名</span></span><br><span class="line">  alias: &#123;</span><br><span class="line">    vue$: <span class="string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">     <span class="string">'@'</span>: resolve(<span class="string">'./src'</span>),</span><br><span class="line">    <span class="string">'@mixins'</span>: resolve(<span class="string">'./src/mixins'</span>),</span><br><span class="line">    <span class="string">'@base'</span>: resolve(<span class="string">'./src/base'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 文件后缀扩展识别（导入时自动加后缀）</span></span><br><span class="line">  extensions: [<span class="string">'*'</span>, <span class="string">'.js'</span>, <span class="string">'.vue'</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h6 id="es6-支持"><a href="#es6-支持" class="headerlink" title="es6 支持"></a>es6 支持</h6><p>首先在 <code>webpack</code> 配置文件的 <code>rules</code> 部分(<code>vue-loader</code> 配置的部分)添加 <code>js</code> 的语法转译</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">    include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">    exclude: [resolve(<span class="string">'node_modules'</span>)]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后在项目内添加 <code>.babelrc</code> 文件，并在内部添加 <code>es</code> 支持</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"@babel/plugin-transform-runtime"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处使用的是最新版本的 babel 配置，官网有详细的讲解</p>
<ul>
<li><a href="https://babeljs.io/docs/en/babel-preset-env" target="_blank" rel="noopener">@babel/preset-env</a></li>
<li><a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime" target="_blank" rel="noopener">@babel/plugin-transform-runtime</a></li>
</ul>
<p>需要安装的一些依赖：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// devDependencies 部分</span></span><br><span class="line"><span class="string">"@babel/core"</span>: <span class="string">"^7.4.3"</span>,</span><br><span class="line"><span class="string">"@babel/plugin-transform-runtime"</span>: <span class="string">"^7.4.3"</span>,</span><br><span class="line"><span class="string">"@babel/preset-env"</span>: <span class="string">"^7.4.3"</span>,</span><br><span class="line"><span class="string">"babel-core"</span>: <span class="string">"^7.0.0-bridge.0"</span>,</span><br><span class="line"><span class="string">"babel-loader"</span>: <span class="string">"^7.1.2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dependencies 部分</span></span><br><span class="line"><span class="string">"@babel/runtime"</span>: <span class="string">"^7.4.3"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： babel-core 默认安装的是 6.x 版本，装 7 版本的命令是： <code>yarn add babel-core@^7.0.0-bridge.0 -D</code></p>
</blockquote>
<h6 id="css-样式支持"><a href="#css-样式支持" class="headerlink" title="css 样式支持"></a>css 样式支持</h6><p>由于 vue 项目中用的较多的是 less 或者是 sass，因此打包时需要对样式进行转译，此时需要样式相关的 loader。webpack 的配置例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rules 部分</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(le|sc|sa|c)ss$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    MiniCssExtractPlugin.loader,</span><br><span class="line">    <span class="string">'css-loader'</span>,</span><br><span class="line">    <span class="string">'postcss-loader'</span>,</span><br><span class="line">    <span class="string">'less-loader'</span></span><br><span class="line">  ],</span><br><span class="line">  include: [ resolve(<span class="string">'src'</span>) ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// plugins 部分</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="comment">// 提取 CSS 至单一文件夹</span></span><br><span class="line">  <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'css/[name].[hash].css'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'[id].[hash].css'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这里注意到最顶部配置的不是 <code>style-loader/vue-style-loader</code>，当我们使用的是开发环境即：<code>&quot;mode&quot;: &quot;development&quot;</code> 时，使用 <code>style-loader/vue-style-loader</code>，当使用生产环境即：<code>&quot;mode&quot;: &quot;production&quot;</code> 时，我们使用此处的配置，以达到最小化压缩</p>
<h6 id="其余资源支持"><a href="#其余资源支持" class="headerlink" title="其余资源支持"></a>其余资源支持</h6><p>参考官方文档总结的配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(png|jpeg|jpg|gif|svg)$/i</span>,</span><br><span class="line">  loader: <span class="string">'url-loader'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    limit: <span class="number">8192</span>,</span><br><span class="line">    fallback: <span class="string">'file-loader'</span>,</span><br><span class="line">    name: <span class="string">'[name].[ext]?[hash]'</span>,</span><br><span class="line">    outputPath: <span class="string">'images/'</span>,</span><br><span class="line">    publicPath: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>url-loader 转为 base64 格式，对于小文件类型用这种方法处理更优，但是大文件最好还是用 file-loader 处理，因此对此 loader 设定一个限制，大于阈值 8K 的自动用 file-loader 处理</p>
<blockquote>
<p><a href="https://webpack.docschina.org/loaders/url-loader/#getting-started" target="_blank" rel="noopener">文档传送门</a></p>
</blockquote>
<h5 id="optimization-配置"><a href="#optimization-配置" class="headerlink" title="optimization 配置"></a>optimization 配置</h5><p>此部分是最后对文件进行压缩优化一下体积，webpack4 中生产环节相对较好的 <code>devtool</code> 模式是 <code>cheap-module-source-map</code>，但是压缩出的文件内会包含 <code>source-map</code>，如果想将其去掉需要额外的一些配置。webpack 配置例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">      uglifyOptions: &#123;</span><br><span class="line">        <span class="comment">// 最快压缩模式</span></span><br><span class="line">        compress: <span class="literal">false</span>,</span><br><span class="line">        mangle: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处使用的是 UglifyJsPlugin 压缩 js 代码，删除 map 部分的内容， OptimizeCssAssetsPlugin 则是压缩 CSS 部分的内容，具体配置可参考对应的 npm 插件文档</p>
<ul>
<li><a href="https://www.npmjs.com/package/uglifyjs-webpack-plugin" target="_blank" rel="noopener">uglify 部分</a></li>
<li><a href="https://www.npmjs.com/package/optimize-css-assets-webpack-plugin" target="_blank" rel="noopener">css 部分</a></li>
</ul>
<blockquote>
<p>注：css 部分有推荐配合使用 <code>cssnano</code>，因为本项目 css 内容就 2 属性，因此不做过多的配置了，有需要的可查阅相关知识配置即可</p>
</blockquote>
<h6 id="附带的配置"><a href="#附带的配置" class="headerlink" title="附带的配置"></a>附带的配置</h6><ul>
<li>clean-webpack-plugin: 放在 plugins 的最后面，可每次自动清除对应的生成文件</li>
<li>webpack-bundle-analyzer: 对压缩的文件的依赖树的可视化分析，方便分析是否有多余依赖</li>
</ul>
<h4 id="vue-的配置"><a href="#vue-的配置" class="headerlink" title="vue 的配置"></a>vue 的配置</h4><p>发布一个 vue 组件时需要为组件添加 install 方法，每个组件的文件目录树大致为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fileName</span><br><span class="line">  |-- index.js</span><br><span class="line">  |-- src</span><br><span class="line">       | -- component</span><br></pre></td></tr></table></figure>
<p>这是一个组件的文件结构，其中的 <code>component</code> 就是我们的 vue 组件，<code>index.js</code> 为向外侧暴露该组件的一个入口文件，其内容基本格式一致，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> myComponent <span class="keyword">from</span> <span class="string">'./src/component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加单独引用的 install 方法</span></span><br><span class="line">myComponent.install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  Vue.component(myComponent.name, myComponent);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myComponent;</span><br></pre></td></tr></table></figure>
<p>整体的配置可以参考 <a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">elementUI</a> 的组件写法，原理一样，本质是如何添加 install 方法</p>
<h3 id="开发时的一些疑问"><a href="#开发时的一些疑问" class="headerlink" title="开发时的一些疑问"></a>开发时的一些疑问</h3><h4 id="关于-devtool-的选用"><a href="#关于-devtool-的选用" class="headerlink" title="关于 devtool 的选用"></a>关于 <code>devtool</code> 的选用</h4><p>开发环境推荐： <code>cheap-module-eval-source-map</code></p>
<p>生产环境推荐：<code>cheap-module-source-map</code></p>
<p>理由：</p>
<ul>
<li>大部分情况我们调试并不关心列信息，而且就算 sourcemap 没有列，有些浏览器引擎（例如 v8） 也会给出列信息，所以我们使用 cheap 模式可以大幅提高 souremap 生成的效率</li>
<li>使用 module 可支持 babel 这种预编译工具（在 webpack 里做为 loader 使用）</li>
<li>使用 eval 方式可大幅提高持续构建效率，参考 <a href="https://www.webpackjs.com/configuration/devtool/#devtool" target="_blank" rel="noopener">webapck devtool</a> 速度对比列表，这对经常需要边改边调的前端开发而言非常重要</li>
<li>直接将 sourceMap 放入打包后的文件，会明显增大文件的大小，不利于静态文件的快速加载；而外联 .map 时，.map 文件只会在 F12 开启时进行下载（ sourceMap 主要服务于调试），故推荐使用外联 .map 的形式</li>
</ul>
<h4 id="升级-babel-的问题"><a href="#升级-babel-的问题" class="headerlink" title="升级 babel 的问题"></a>升级 babel 的问题</h4><p>依照官方文档的介绍，安装了 <code>@babel/core</code> 等插件，并更新了 <code>.babelrc</code> 的配置，但是 build 的时候报错表示 babel-core 版本过低（直接 <code>yarn add babel-core</code> 装的是 6.x 版本），需要 7.0.0.0 版本，因此需要更新 <code>babel-core</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add babel-core@^7.0.0-bridge.0 -D</span><br></pre></td></tr></table></figure>
<h4 id="本地调试包"><a href="#本地调试包" class="headerlink" title="本地调试包"></a>本地调试包</h4><p>一般通过 <code>yarn link</code> 来调试编写的包，但是除此之外还有另外一个方法，通过相对路径来安装对应的包</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"target-file": "file:&lt;relative-path&gt;"</span><br></pre></td></tr></table></figure>
<p>但是缺点是，每次更新后都需要删除后重新安装此包，或者将包升级一下版本，然后再次安装才能调试，比较麻烦。</p>
<p>最好的配置方法还是通过 <code>yarn link</code> 来调试。</p>
<h4 id="按需引入比解构引入打包的体积要大？"><a href="#按需引入比解构引入打包的体积要大？" class="headerlink" title="按需引入比解构引入打包的体积要大？"></a>按需引入比解构引入打包的体积要大？</h4><p>分析了一下打包后的代码，就用以下的例子来解释</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按需</span></span><br><span class="line"><span class="keyword">import</span> debouce <span class="keyword">from</span> <span class="string">'lodash/debounce'</span></span><br><span class="line"><span class="comment">// 解构</span></span><br><span class="line"><span class="keyword">import</span> &#123; debounce &#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure>
<p>通过 webpack-bundle-analyzer 分析打包后的内容，发现前者有 lodash 的模块，后者没有，后者没有的原因时在压缩的代码内有 <code>require(&#39;lodash&#39;)</code> 即，我们需要配置 <code>package.json</code> 的 <code>lodash</code> 的 <code>dependencies</code> 依赖，需要引用此包的项目有对 <code>lodash</code> 的依赖，也就是说，解构获取的 <code>debouce</code> 不会将对应的内容连同代码一起打包，而是需要用户安装对应的包的依赖，因此体积相对会变小。</p>
<h4 id="为什么要用-library？"><a href="#为什么要用-library？" class="headerlink" title="为什么要用 library？"></a>为什么要用 library？</h4><p>使用 umd 是为了兼容 commonjs 和 amd 的方式，一般发包用 umd 可保证不会出啥问题，兼容性也很棒，而使用 umd 则需要配置 library。</p>
<h4 id="path-和-publicPath"><a href="#path-和-publicPath" class="headerlink" title="path 和 publicPath"></a>path 和 publicPath</h4><p>一般我们配置好 path 其实就能万事大吉了，那 publicPath 究竟有什么用呢？其实简单理解， path 至当前的项目的根目录（本地），publicPath 指的是服务器的根目录（服务器）,比如：将资源放在 CDN 上时，把 publicPath 设置为 CDN 的值就行了。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://www.cnblogs.com/hhhyaaon/p/5657469.html" target="_blank" rel="noopener">webpack devtool配置对比</a></li>
<li><a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">webpack 文档</a></li>
<li><a href="https://webpack.docschina.org/configuration/#%E9%80%89%E9%A1%B9" target="_blank" rel="noopener">webpack 配置详情文档</a></li>
<li><a href="https://www.tangshuang.net/3343.html" target="_blank" rel="noopener">webpack externals详解</a></li>
<li><a href="https://www.cnblogs.com/SamWeb/p/8353367.html" target="_blank" rel="noopener">webpack 配置 publicPath的理解</a></li>
<li><a href="https://www.babeljs.cn/docs/" target="_blank" rel="noopener">babel 文档</a></li>
<li><a href="https://github.com/babel/babel-bridge" target="_blank" rel="noopener">babel-bridge</a></li>
<li><a href="https://vue-loader.vuejs.org/zh/" target="_blank" rel="noopener">vue-loader</a></li>
</ul>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p><a href="https://github.com/kazehaiya/vue-component" target="_blank" rel="noopener">完整样例</a></p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>层叠上下文</title>
    <url>/2019/06/18/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在做项目布局回顾时，思考到了一个当初比较犹豫的问题「flex 布局能否产生层叠/堆叠上下文」。在网上也参考了国内外很多有价值的文章，此处小结一下，算是对<strong>层叠上下文</strong>这一部分做一次较为全面的总结。</p>
<a id="more"></a>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="层叠上下文是什么"><a href="#层叠上下文是什么" class="headerlink" title="层叠上下文是什么"></a>层叠上下文是什么</h4><p>这里先引用 MDN 上的一段对<strong>层叠上下文</strong>的介绍：</p>
<div class="note default">
            <p><strong>层叠上下文</strong>是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的 z 轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。</p>
          </div>
<p>简单来说，电脑屏幕给我们展现的是一个平面，此对应直角坐标系的 X、Y 轴，而垂直与电脑屏幕的这个不可见的轴（相当于直角坐标系的 Z 轴），其上面遍布着不同的堆叠层，而此堆叠层的层叠顺序就是我们所谓的层叠上下文了。</p>
<blockquote>
<p>如果有设计经验的，那么这个堆叠层可以理解为 PS 中的画布，默认只有最初的一层（页面中的 html 元素）</p>
</blockquote>
<h4 id="层叠上下文的堆叠顺序"><a href="#层叠上下文的堆叠顺序" class="headerlink" title="层叠上下文的堆叠顺序"></a>层叠上下文的堆叠顺序</h4><p>这边借用一张图来描述一下堆叠顺序：</p>
<p><img data-src="/images/stacking-order.png" alt="堆叠顺序"></p>
<p>此处对图做简单说明：</p>
<ol>
<li>层叠上下文部分：相当于该层叠区域的装饰，优先级最低，处于最底层</li>
<li>block 块状水平盒子：层叠区最为基础的布局方式，主要目的是为了控制呈现的样式</li>
<li>float 浮动盒子：float 默认的 <code>display</code> 属性就是 block ，只是脱离了文档流，其也是一种布局方式</li>
<li>inline/inline-block 水平盒子：层叠区默认的内容呈现部分，承载页面大多数内容部分（涉及到页面内容的标签基本上是 inline ，或者是隐式行内盒）</li>
<li>z-index + position（和部分 CSS3 属性）：控制元素在其所在的层叠区 Z 轴上的顺序（默认 auto，相当于 0），有正负值</li>
</ol>
<p>其中比较有趣的一点是，<strong><code>inline/inline-block</code> 的层级顺序要高于 <code>block</code> 元素</strong>，具体的体现就在“文字环绕”式布局了。</p>
<p>其实这么排序也有其理由，我们知道，页面其主要目的是为了呈现内容的，而块级元素偏向于布局（设置宽高、内外边距、边框、行内元素的大多数配置等等），行内元素偏向于内容（与其它内容的间隔、字体大小等等），因此不难理解行内元素应该高于块级元素的层叠级别了。</p>
<p>此外，对于默认情况（什么都没有设置），后面的元素默认堆叠顺序会高于前面的元素，具体的体现为两个 button 按钮，如果将后者的 <code>margin</code> 值设为负值，其会覆盖掉先前的按钮。</p>
<blockquote>
<p>注：在层叠上下文中，其子元素同样也按照上面解释的规则进行层叠。 特别值得一提的是，其子元素的 z-index 值只在父级层叠上下文中有意义。子级层叠上下文被自动视为父级层叠上下文的一个独立单元。</p>
</blockquote>
<h4 id="如何产生层叠上下文"><a href="#如何产生层叠上下文" class="headerlink" title="如何产生层叠上下文"></a>如何产生层叠上下文</h4><p>此处还是引用 MDN 上的介绍，文档中的层叠上下文由满足以下任意一个条件的元素形成（未做说明的会影响子元素的 fix 布局）：</p>
<ul>
<li>根元素 (HTML)</li>
<li><code>z-index</code> 值不为 “auto” 的 绝对/相对定位（不影响子元素的 fix 布局）</li>
<li><code>z-index</code> 值不为 “auto” 的 flex 项目 (flex item)，即：父元素 <code>display: flex|inline-flex</code></li>
<li><code>opacity</code> 属性值小于 1 的元素（参考 the specification for opacity）（不影响子元素的 fix 布局）</li>
<li><code>transform</code> 属性值不为 “none” 的元素</li>
<li><code>mix-blend-mode</code> 属性值不为 “normal” 的元素（不影响子元素的 fix 布局）</li>
<li><code>filter</code> 值不为 “none” 的元素</li>
<li><code>perspective</code> 值不为 “none” 的元素</li>
<li><code>isolation</code> 属性被设置为 “isolate” 的元素（不影响子元素的 fix 布局）</li>
<li><code>position: fixed</code>（不影响子元素的 fix 布局）</li>
<li><code>will-change</code> 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值(参考<a href="https://www.w3.org/TR/css-color-3/#transparency）" target="_blank" rel="noopener">这篇文章</a></li>
<li><code>-webkit-overflow-scrolling</code> 属性被设置 “touch” 的元素（不影响子元素的 fix 布局）</li>
<li>（补充）<code>transform-style</code> 为 preserve-3d 的元素</li>
</ul>
<p>当然，这里仅仅只是列举了能够形成层叠上下文的一些情况，而其中也有部分翻译的的不是很准确（参考<a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener">张鑫旭</a>的文章，后面做了一些要点描述）</p>
<div class="note warning">
            <p>层叠上下文的层级是 HTML 元素层级的一个层级，因为只有某些元素才会创建层叠上下文。可以这样说，没有创建自己的层叠上下文的元素 将被父层叠上下文包含。 —— MDN</p>
          </div>
<h3 id="详解层叠上下文的形成"><a href="#详解层叠上下文的形成" class="headerlink" title="详解层叠上下文的形成"></a>详解层叠上下文的形成</h3><h4 id="z-index-不为-auto-的-flex-项目"><a href="#z-index-不为-auto-的-flex-项目" class="headerlink" title="z-index 不为 auto 的 flex 项目"></a><code>z-index</code> 不为 auto 的 flex 项目</h4><p>此指的是父元素的 <code>display</code> 属性为 flex/inline-flex ，其子元素的 z-index 值不为 auto，此时该<strong>子元素</strong>会形成堆叠区。</p>
<iframe id="cp_embed_qzNKaW" src="//codepen.io/kazehaiya/embed/qzNKaW?height=300&theme-id=dark&slug-hash=qzNKaW&default-tab=css,result" scrolling="no" frameborder="no" height="300" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe>
<h4 id="transform-属性值不为-“none”-的元素"><a href="#transform-属性值不为-“none”-的元素" class="headerlink" title="transform 属性值不为 “none” 的元素"></a><code>transform</code> 属性值不为 “none” 的元素</h4><p>在做 <code>position: fixed</code> 定位时，其默认是基于页面窗口创建堆叠区（根元素有个最基础的堆叠区），然而父级元素的 <code>transform</code> 属性值非 none 时，其会生成一个堆叠层，使得内部的 fixed 布局不是以窗口为基本的堆叠层，而是此父级本身，从而产生很“酸爽”的 bug 体验。</p>
<iframe id="cp_embed_gNMjMK" src="//codepen.io/kazehaiya/embed/gNMjMK?height=300&theme-id=dark&slug-hash=gNMjMK&default-tab=css,result" scrolling="no" frameborder="no" height="300" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe>
<h4 id="不会影响-fix-布局的会生成自身层叠的例子"><a href="#不会影响-fix-布局的会生成自身层叠的例子" class="headerlink" title="不会影响 fix 布局的会生成自身层叠的例子"></a>不会影响 fix 布局的会生成自身层叠的例子</h4><p>此部分对于 <code>-webkit-overflow-scrolling</code> 属性未能尝试成功，可能只能手机端显现（未测试）</p>
<iframe id="cp_embed_MMyMjw" src="//codepen.io/kazehaiya/embed/MMyMjw?height=360&theme-id=dark&slug-hash=MMyMjw&default-tab=css,result" scrolling="no" frameborder="no" height="360" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe>
<h4 id="会影响-fix-布局的层叠的例子"><a href="#会影响-fix-布局的层叠的例子" class="headerlink" title="会影响 fix 布局的层叠的例子"></a>会影响 fix 布局的层叠的例子</h4><p>有人做了比较全的 demo，我 fork 了一份，删除了错误的 flex 布局例子，去掉不受影响的部分。</p>
<iframe id="cp_embed_qzNypX" src="//codepen.io/kazehaiya/embed/qzNypX?height=300&theme-id=dark&slug-hash=qzNypX&default-tab=css,result" scrolling="no" frameborder="no" height="300" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe>
<blockquote>
<p>源码地址：<a href="https://codepen.io/Chokcoco/pen/wqXZXd" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于层叠上下文，当发生层叠的时候，其覆盖关系遵循两条黄金准则：</p>
<ol>
<li><strong>谁大谁上</strong>：当具有明显的层叠水平标示的时候，如具体的 z-index 值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。</li>
<li><strong>后来居上</strong>：当元素的层叠水平一致、层叠顺序相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。</li>
</ol>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">The stacking context</a></li>
<li><a href="https://www.cnblogs.com/coco1s/p/5899089.html" target="_blank" rel="noopener">层叠顺序与堆栈上下文知多少</a></li>
<li><a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener">深入理解CSS中的层叠上下文和层叠顺序</a></li>
<li><a href="https://juejin.im/post/5b53e4f751882519f6476a44" target="_blank" rel="noopener">你不知道的CSS层叠上下文</a></li>
<li><a href="https://www.cnblogs.com/xiahj/p/8036419.html" target="_blank" rel="noopener">深入研究 -webkit-overflow-scrolling: touch 及 ios 滚动</a></li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>在 typescript 中添加 webworker</title>
    <url>/2020/04/28/%E5%9C%A8-typescript-%E4%B8%AD%E6%B7%BB%E5%8A%A0-webworker/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在做 Vue 项目时遇到一个读取 xlsx 文件的需求，考虑到文件可能比较大的情况，为了不让页面卡死，因此引入了 webworker，本来想着应该是很容易的事情，结果却并不是很简单，主要难在配置上，这里就记录一下配置时遇到的困难。</p>
<a id="more"></a>
<h3 id="配置-loader"><a href="#配置-loader" class="headerlink" title="配置 loader"></a>配置 loader</h3><p>因为是 ts 写的项目，因此查阅了一下引入 webworker 需要那些插件，因此首先需要配置的是 loader 文件了。</p>
<ol>
<li>安装 worker-loader</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add worker-loader -D</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在 vue.config.js 内添加如下内容：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 添加 worker-loader 支持</span></span><br><span class="line">    config.module</span><br><span class="line">      .rule(<span class="string">'webWorker'</span>)</span><br><span class="line">      .post()</span><br><span class="line">      .test(<span class="regexp">/\.worker\.(j|t)s$/</span>)</span><br><span class="line">      .use(<span class="string">'worker-loader'</span>)</span><br><span class="line">      .loader(<span class="string">'worker-loader'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>重启项目</li>
</ol>
<h3 id="worker-文件的写法"><a href="#worker-文件的写法" class="headerlink" title="worker 文件的写法"></a>worker 文件的写法</h3><p>在 ts 项目中，类型声明是很重要的一点，对于 worker 文件因为没有导出，在主进程中引入会很棘手，参考网上的例子，一般 worker 文件需要这么配置</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件命名： xxx.worker.ts</span></span><br><span class="line"><span class="comment">// 创建 this 指针，或者配置 webpack 的 output 的 globalObject 属性</span></span><br><span class="line"><span class="keyword">const</span> _self: Worker = self <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 message 事件</span></span><br><span class="line">_self.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听错误事件</span></span><br><span class="line">_self.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(e.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">Web Worker 使用教程</a></li>
<li><a href="https://www.cnblogs.com/liuxianan/p/js-excel.html" target="_blank" rel="noopener">如何使用 JavaScript 实现纯前端读取和导出 excel 文件</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/83138304" target="_blank" rel="noopener">webpack + typescript 环境下配置</a></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>提升项目的构建速度</title>
    <url>/2019/05/08/%E6%8F%90%E5%8D%87%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着项目的增大，越来越多的插件引入项目，使得项目的构建时间越来越长，而这很影响开发的效率。因此有没有一种方法能够优化构建的内容，提前构建好不怎么改动的插件依赖，而仅仅构建我们所写的业务代码呢？webpack 早已为我们考虑到了这个问题。</p>
<a id="more"></a>
<h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>DllPlugin 的主要思想在于将项目内的一些不经常更改的依赖（比如 lodash）提前打包，使得项目构建时忽略这些打包文件，从而减少构建时间，提升构建速度。</p>
<h4 id="参数与使用"><a href="#参数与使用" class="headerlink" title="参数与使用"></a>参数与使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DllPlugin(options);</span><br></pre></td></tr></table></figure>
<p>其中 options 含有如下参数：</p>
<ul>
<li>context (optional): manifest 文件中请求的上下文(context)(默认值为 webpack 的上下文(context))</li>
<li>name: 暴露出的 DLL 的函数名 (TemplatePaths: [hash] &amp; [name] )</li>
<li>path: manifest json 文件的绝对路径 (输出文件)</li>
</ul>
<h3 id="DllReferencePlugin"><a href="#DllReferencePlugin" class="headerlink" title="DllReferencePlugin"></a>DllReferencePlugin</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>简而言之，DllReferencePlugin 就是将 DllPlugin 打包的文件获取，在主 webpack 文件配置后，会让其在构建包时忽略掉 DllPlugin 内配置打包的文件，其依赖 DllPlugin 打包出的 manifest 文件。</p>
<h4 id="参数与使用-1"><a href="#参数与使用-1" class="headerlink" title="参数与使用"></a>参数与使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DllReferencePlugin(options);</span><br></pre></td></tr></table></figure>
<p>其中 options 含有如下参数：</p>
<ul>
<li>context: (绝对路径) manifest (或者是内容属性)中请求的上下文</li>
<li>manifest: 包含 content 和 name 的对象，或者在编译时(compilation)的一个用于加载的 JSON manifest 绝对路径</li>
<li>content (optional): 请求到模块 id 的映射 (默认值为 manifest.content)</li>
<li>name (optional): dll 暴露的地方的名称 (默认值为 manifest.name) (可参考 externals)</li>
<li>scope (optional): dll 中内容的前缀</li>
<li>sourceType (optional): dll 是如何暴露的 (libraryTarget)</li>
</ul>
<blockquote>
<p>注：与 <code>output.library</code> 保持 <code>name</code> 的一致性。</p>
</blockquote>
<h3 id="AddAssetHtmlPlugin"><a href="#AddAssetHtmlPlugin" class="headerlink" title="AddAssetHtmlPlugin"></a>AddAssetHtmlPlugin</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>将 dll 拆分的两个 plugin 配置好后，每次构建项目，推送远端之前都需要将我们的 dll 文件的引用动态添加到生成的 html 文件内，此插件就是实现该手动插入的过程</p>
<h4 id="参数与使用-2"><a href="#参数与使用-2" class="headerlink" title="参数与使用"></a>参数与使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AddAssetHtmlPlugin = <span class="built_in">require</span>(<span class="string">'add-asset-html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> AddAssetHtmlPlugin(options)</span><br></pre></td></tr></table></figure>
<p>我们所关注的 options 配置：</p>
<ul>
<li>filepath: 文件所在的地址，此处配置 dll 构建出的 .js 文件</li>
<li>outputPath: 在构建时，引用的文件最终打包至的位置</li>
<li>publicPath: <code>script</code> 脚本引用该文件时的绝对位置</li>
</ul>
<blockquote>
<p>注：此插件依赖 <code>html-webpack-plugin</code>，由于预构建项目内并不需要生成中间 html 文件，因此我们可以不用像示例那样配置 HtmlWebpackPlugin 来生成 .html 文件</p>
</blockquote>
<h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>初配置好或者依赖的内容有变动（比如：版本升级）使用此命令更新预打包的依赖，否则即使升级了包，最终打包后也不会有任何变化。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn dll</span><br></pre></td></tr></table></figure></p>
<h4 id="dllPlugins-部分配置"><a href="#dllPlugins-部分配置" class="headerlink" title="dllPlugins 部分配置"></a>dllPlugins 部分配置</h4><p>创建一个 webpack.dll.config.js 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置公共请求路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dll文件存放的目录</span></span><br><span class="line"><span class="keyword">const</span> dllPath = <span class="string">'&lt;target-file&gt;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  <span class="comment">// 需要提取的依赖</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">'lodash'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: resolve(dllPath),</span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">    <span class="comment">// vendor.dll.js 中暴露出的全局变量名</span></span><br><span class="line">    <span class="comment">// 保持与 webpack.DllPlugin 中名称一致</span></span><br><span class="line">    library: <span class="string">'[name]_[hash]'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// manifest.json 描述动态链接库包含了哪些内容</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      path: path.join(__dirname, dllPath, <span class="string">'manifest.json'</span>),</span><br><span class="line">      <span class="comment">// 保持与 output.library 中名称一致</span></span><br><span class="line">      name: <span class="string">'[name]_[hash]'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 清除之前打包的 dll 文件</span></span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="主-webpack-打包文件配置"><a href="#主-webpack-打包文件配置" class="headerlink" title="主 webpack 打包文件配置"></a>主 webpack 打包文件配置</h4><p>此处以 vue-cli3 来说明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AddAssetHtmlPlugin = <span class="built_in">require</span>(<span class="string">'add-asset-html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置忽略打包的 vender 文件，添加已打包文件</span></span><br><span class="line">    config.plugin(<span class="string">'dll'</span>).use(<span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">'./vendor/manifest.json'</span>)</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="comment">// 将 dll 生成的 vender 自动注入到 html 文件中</span></span><br><span class="line">    config.plugin(<span class="string">'insert'</span>).use(<span class="keyword">new</span> AddAssetHtmlPlugin(&#123;</span><br><span class="line">      <span class="comment">// dll文件位置</span></span><br><span class="line">      filepath: path.resolve(__dirname, <span class="string">'./vendor/*.js'</span>),</span><br><span class="line">      <span class="comment">// dll 引用 dist 路径</span></span><br><span class="line">      publicPath: <span class="string">'js'</span>,</span><br><span class="line">      <span class="comment">// dll最终打包到的 dist 目录位置</span></span><br><span class="line">      outputPath: <span class="string">'js'</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="package-json-配置"><a href="#package-json-配置" class="headerlink" title="package.json 配置"></a>package.json 配置</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "dll": "webpack --progress --config webpack.dll.config.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://webpack.docschina.org/plugins/dll-plugin/" target="_blank" rel="noopener">DllPlugin</a></li>
<li><a href="https://www.cnblogs.com/lifefriend/p/10479341.html" target="_blank" rel="noopener">vue-cli3 DllPlugin 提取公用库</a></li>
<li><a href="https://blog.csdn.net/u011413061/article/details/51872412" target="_blank" rel="noopener">如何十倍提高你的webpack构建效率</a></li>
</ul>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建私人 git 仓库</title>
    <url>/2019/08/04/%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA-git-%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文原来维护在 segmentfault 上，由于本周时间不是很充足，因此将原来的文章维护至本博客，之后时间充裕的时候再补充一篇。本文简单介绍一下如何在自己服务器上搭建死人的 git 仓库，毕竟近期的 github 也不算是十分安全~还是有必要了解一下私人 git 仓库的搭建之法的。</p>
<a id="more"></a>
<h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><h4 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h4><p>官方下载 git 安装包，根据提示安装即可，<a href="https://git-scm.com/" target="_blank" rel="noopener">Git 官网</a>。</p>
<p>安装完成后配置个人的 git 信息，在 git bash 中输入以下信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"your name"</span></span><br><span class="line">git config --global user.email <span class="string">"your email"</span></span><br></pre></td></tr></table></figure>
<h4 id="创建-sshkey"><a href="#创建-sshkey" class="headerlink" title="创建 sshkey"></a>创建 sshkey</h4><p>在 bash 中输入以下信息，看有没有配置 ssh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="comment"># 如果没有报错则打印下 pub 信息，之后会用到。</span></span><br><span class="line">cat .\id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>下面为创建 ssh-key 的方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认生成 SSH-2 的 RSA 密钥，密码部分直接回车即可</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"mailaddress@example.com"</span></span><br></pre></td></tr></table></figure>
<h3 id="远程配置（ubuntu-16）"><a href="#远程配置（ubuntu-16）" class="headerlink" title="远程配置（ubuntu 16）"></a>远程配置（ubuntu 16）</h3><h4 id="创建-git-用户"><a href="#创建-git-用户" class="headerlink" title="创建 git 用户"></a>创建 git 用户</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检验用户是否已经存在</span></span><br><span class="line">id git</span><br><span class="line"><span class="comment"># 不存在则创建一个 git 用户(会有提示创密码)</span></span><br><span class="line">adduser git</span><br><span class="line"><span class="comment"># 给 git 配置 sudo 权限</span></span><br><span class="line">usermod -aG sudo git</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注：</strong> 非 root 权限需要加 sudo</p>
</blockquote>
<h4 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h4><p>安装/更新 git</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install git</span><br><span class="line"><span class="comment"># 初始化个人信息</span></span><br><span class="line">git config --global user.name <span class="string">"your name"</span></span><br><span class="line">git config --global user.email <span class="string">"your email"</span></span><br></pre></td></tr></table></figure>
<h4 id="配置仓库"><a href="#配置仓库" class="headerlink" title="配置仓库"></a>配置仓库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选取合适的位置，创建 xxx.git 文件夹（必须 .git 结尾）</span></span><br><span class="line">mkdir /data/git/yourname.git</span><br><span class="line"><span class="comment"># 创建空远程仓库</span></span><br><span class="line">git init --bare data/git/yourname.git</span><br><span class="line"><span class="comment"># 将仓库拥有着改为 git 用户</span></span><br><span class="line">chown -R git:git yourname.git</span><br><span class="line"><span class="comment"># 切换用户(切不切都无所谓，不切注意后面得改拥有者)</span></span><br><span class="line">su git</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注：</strong> 更改用户拥有者这一步，如果你是在 root 用户下建立文件的话需要更改，如果先切换成 git 用户了，那么就不需要改，可用 ll 或 ll -a 命令查看</p>
</blockquote>
<h4 id="配置认证用户信息"><a href="#配置认证用户信息" class="headerlink" title="配置认证用户信息"></a>配置认证用户信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 ssh_config</span></span><br><span class="line"><span class="built_in">cd</span> /etc/ssh</span><br><span class="line">sudo vi sshd_config</span><br><span class="line"><span class="comment"># 解开注释，如果注释了的话</span></span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile      %h/.ssh/authorized_keys</span><br><span class="line"><span class="comment"># 重启服务（ubuntu 的 sshd 位置和其他博客写的不一样……），cd /etc/init.d，你可以在这里看到 ssh</span></span><br><span class="line">sudo service ssh restart</span><br><span class="line"><span class="comment"># 进入 git 用户目录下，创建认证文件。注：此 .ssh 文件夹权限必须为 git</span></span><br><span class="line"><span class="built_in">cd</span> home/git</span><br><span class="line">sudo mkdir .ssh</span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line">sudo vi authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后此处粘贴客户端先前打印的的 rsa 的 pub 文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改仓库权限</span></span><br><span class="line"><span class="built_in">cd</span> /home/git</span><br><span class="line">sudo chmod 700 .ssh</span><br><span class="line">sudo chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p>在此仓库就配完了。</p>
<blockquote>
<p><strong>注：</strong> 很多博客没有 %h 这个东西，查了下 askubuntu ，这个貌似就是指 home</p>
</blockquote>
<h3 id="服务器自动部署配置"><a href="#服务器自动部署配置" class="headerlink" title="服务器自动部署配置"></a>服务器自动部署配置</h3><h4 id="添加-hook"><a href="#添加-hook" class="headerlink" title="添加 hook"></a>添加 hook</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进入所创仓库的 hooks 文件目录</span></span><br><span class="line">cd /data/git/server.git/hooks/</span><br><span class="line">sudo vi post-receive</span><br><span class="line"><span class="comment">// 写入如下内容</span></span><br><span class="line">#/bin/sh</span><br><span class="line">GIT_WORK_TREE=yourFileAddress git checkout -f</span><br><span class="line"><span class="comment">// 保存后改下权限即可</span></span><br><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注：</strong> yourFileAddress 的拥有者应该是 git 用户</p>
</blockquote>
<h3 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h3><h4 id="如何测试账户的连接情况"><a href="#如何测试账户的连接情况" class="headerlink" title="如何测试账户的连接情况"></a>如何测试账户的连接情况</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T user@host</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<p>user：远程分支的通过 adduser 创建的用户，一般创建 git 用户管理 git 相关内容</p>
<p>host：服务器地址，可以直接用 ip 地址，有域名的可以写域名</p>
<blockquote>
<p>例：ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p>
</blockquote>
<h4 id="关于关闭-bash-登陆系统问题。"><a href="#关于关闭-bash-登陆系统问题。" class="headerlink" title="关于关闭 bash 登陆系统问题。"></a>关于关闭 bash 登陆系统问题。</h4><p>此主要配置禁止通过 git 来登陆服务器，为了服务器安全性建议配置一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/passwd</span><br><span class="line"><span class="comment"># 然后将 git 用户的那行的 /bin/bash 改成 /usr/bin/git-shell</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：如果出现错误，请自行查找该系统下的 git-shell 在哪个文件路径，默认应该是 /usr/bin 内</p>
</blockquote>
<h4 id="关于-600-和-700-权限问题。"><a href="#关于-600-和-700-权限问题。" class="headerlink" title="关于 600 和 700 权限问题。"></a>关于 600 和 700 权限问题。</h4><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod abc file</span><br></pre></td></tr></table></figure>
<p>其中 a, b, c 各为一个数字，分别表示 User， Group 及 Other 的权限。因为：</p>
<p>读取    写入   执行<br>r = 4, w = 2, x = 1</p>
<p>故而：</p>
<p>rwx : 4 + 2 + 1 =&gt; 7</p>
<p>rw  : 4 + 2 =&gt; 6</p>
<p>我们这边仅弄 User 权限，因此略。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file-on-ubuntu-and-centos" target="_blank" rel="noopener">ubuntu 权限配置</a><br><a href="https://stackoverflow.com/questions/6377009/adding-public-key-to-ssh-authorized-keys-does-not-log-me-in-automatically" target="_blank" rel="noopener">仓库权限</a><br><a href="https://askubuntu.com/questions/605479/what-does-h-mean-in-sshd-configuration" target="_blank" rel="noopener">%h mean</a><br><a href="https://www.jianshu.com/p/5c7ce1b02100" target="_blank" rel="noopener">hooks 配置</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>水平垂直居中</title>
    <url>/2019/04/27/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在面试中，面试官考察 CSS 方面的内容时，比较常见的一个问题就是<strong>水平垂直居中</strong>问题。其实不仅仅是面是，在工作中也常常会遇到这样的布局，因此对于一些常见的水平垂直居中的方法，在此做了一番总结，以作备忘。</p>
<a id="more"></a>
<h3 id="块级元素的水平垂直居中定位"><a href="#块级元素的水平垂直居中定位" class="headerlink" title="块级元素的水平垂直居中定位"></a>块级元素的水平垂直居中定位</h3><p>对于块级元素的垂直居中定位，我们处理的方法有很多，就以下公共模板做讨论：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent parent-special"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child child-common"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.parent-special</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child-common</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="position-margin"><a href="#position-margin" class="headerlink" title="position + margin"></a>position + margin</h4><p>定位配合 margin 来实现的方法比较简单粗暴，由于子元素有定宽定高的限制，因此适用于一些简单的布局，比如弹框之类的（这里仅讨论绝对定位）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: -<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="position-transform"><a href="#position-transform" class="headerlink" title="position + transform"></a>position + transform</h4><p>前面的方法对于子元素大小固定的情况可以适用，但是对于子元素大小不固定的情况却没法处理，好在 CSS3 的新属性 <code>transform</code> 能帮我们解决这个问题</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：虽然 transform 能解决问题，但是当 width 和 height 百分比计算后的值为非偶数时，通过 translate 补正会造成页面字体模糊以及抖动问题（抖动可用 3d 校正，模糊无解），因此这个得视情况使用。</p>
</blockquote>
<h4 id="table-cell"><a href="#table-cell" class="headerlink" title="table-cell"></a>table-cell</h4><p>回顾比较”久远”的解决方法那就是传统的 <code>table-cell</code> 布局了，父级的 <code>display</code> 属性为 table，子元素设置为 table-cell，配合 <code>vertical-align</code>，就能实现垂直居中，不过此处的居中偏向于行内元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent-special</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="comment">/* 为了表现得更鲜明一点 */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： 这种情况比较适合于子元素内容呈现形式为为行内的情况，子元素此时会占满整个父元素。</p>
</blockquote>
<h4 id="margin-auto"><a href="#margin-auto" class="headerlink" title="margin: auto"></a>margin: auto</h4><p>我们知道 <code>margin: auto</code> 会自动补充左右两侧的内容，如果能够实现自动补充上下两端的内容那不就能够实现垂直居中了么！因此我们通过定位来“提示”自动补全。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而这种写法会让子元素撑满整个父级，适用于仅包含一个元素的情况；如果只想要垂直居中（子元素的上下 <code>margin</code> 会被填满），那么可以这么修改：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="comment">/* 取其一 */</span></span><br><span class="line">  left/right: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p><code>flex</code> 属性就不做过多说明，这个很好理解，阮一峰的博客有很详细的实例，我就不赘述了（<code>grid</code> 可类比）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent-special</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="行内元素的垂直居中定位"><a href="#行内元素的垂直居中定位" class="headerlink" title="行内元素的垂直居中定位"></a>行内元素的垂直居中定位</h3><p>行内元素的垂直居中面试中不是特别常见（水平居中谁都会，此处 pass），但工作中还是遇到不少，先前的<a href="https://kazehaiya.github.io/2019/04/18/%E6%B5%85%E8%B0%88%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/">《浅谈行内元素》</a>一文中也有简单介绍，此处以以下公共模板做讨论：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"inline"</span>&gt;</span>行内元素内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="line-height-font-size-vertical-align"><a href="#line-height-font-size-vertical-align" class="headerlink" title="line-height + font-size + vertical-align"></a>line-height + font-size + vertical-align</h4><p>此为在不改变行内元素属性的情况下，通用的居中方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.inline</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注，当该行内元素有同级的行内元素位于其左右时， <code>vertical-align</code> 需统一一下，因为默认的值为 <code>baseline</code></p>
</blockquote>
<h4 id="inline-block-伪元素"><a href="#inline-block-伪元素" class="headerlink" title="inline-block + 伪元素"></a>inline-block + 伪元素</h4><p>另外比较“骚气”的处理方法就是改变盒子的 display 状态，然后给予一个定位的中心点（默认没有的），以此中心点来影响其余的匿名行盒子的定位。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.inline</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inline</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：此方法可行是可行，但是浏览器在渲染空节点时，仍然会占一个空格，也就是说，水平居中总会差那么一点点，如果不是特别挑剔那么就没什么大问题。</p>
</blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局语法篇</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">Flex 布局实例篇</a></li>
<li><a href="https://segmentfault.com/a/1190000010614270" target="_blank" rel="noopener">一些面试时关于 CSS 的问题</a></li>
</ul>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>本篇为我的 segmentfault 中的文章的一部分，因为刚好温故 CSS 时又看到了布局这部分内容，因此再总结一次，记录下一些新的收获，同时修改一下当时学习记录的一些错误点。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 BFC</title>
    <url>/2019/05/03/%E6%B5%85%E8%B0%88-BFC/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>CSS 中除了垂直居中之外，另外一个常见的问题就是 BFC 问题。BFC 全称为 Block Fromatting Context，即“块级格式化上下文”，对于前端开发来说，了解这个还是非常必要的，因为对于 To C 类的产品对于前端 CSS 要求还是挺高的，了解这个能够更为方便的把握住页面的结构层次以及会产生的问题。</p>
<a id="more"></a>
<h3 id="创建-BFC"><a href="#创建-BFC" class="headerlink" title="创建 BFC"></a>创建 BFC</h3><p>下列方式会创建块格式化上下文（此部分由 MDN 总结）：</p>
<ul>
<li>根元素或包含根元素的元素</li>
<li>浮动元素（元素的 float 不是 none）</li>
<li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li>
<li>行内块元素（元素的 display 为 inline-block）</li>
<li>表格单元格（元素的 display为 table-cell，HTML 表格单元格默认为该值）</li>
<li>表格标题（元素的 display 为 table-caption，HTML 表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、row、tbody、thead、tfoot 的默认属性或 inline-table）<br>overflow 值不为 visible 的块元素</li>
<li>display 值为 flow-root 的元素</li>
<li>contain 值为 layout、content或 strict 的元素</li>
<li>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</li>
<li>网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</li>
<li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li>
<li>column-span 为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</li>
</ul>
<p>很多博客对于 BFC 这部分的知识有很详细的讲解了，但是好记性不如烂笔头对吧，我自己也试着研究了下，BFC 无外乎两个问题：高度塌陷和外边距重叠。</p>
<h3 id="高度塌陷"><a href="#高度塌陷" class="headerlink" title="高度塌陷"></a>高度塌陷</h3><p>这个现象在使用浮动布局时会时常遇到，用一下代码来说明：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"float-content"</span>&gt;</span>This is a float element<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: bisque;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.float-content</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>: antiquewhite;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于子元素为浮动元素，脱离了文档流，因此父元素的内容为“空”，因此父元素的高度最终计算为 0。</p>
<p><img data-src="/images/bfc_problem_1.png" alt="高度塌陷"></p>
<p>解决这个的方法也有很多，这里就不做全量总结了，最为推荐的方法为添加伪元素法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a>外边距折叠</h3><p>外边距折叠问题用图不是很好描述，这里先简单的用字符画来描述一下（两种情形）。</p>
<p>第一种情形是，当你在一个 div 元素内插入一个<strong>块级</strong>子元素，然后设置其 <code>margin-top</code> 值，这是你会发现并不是子元素在父元素内撑开了一段距离，而是父元素向上撑开了一段距离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原以为：                            实际上：</span><br><span class="line">------- body -------               ------- body -------</span><br><span class="line">                                            *</span><br><span class="line">   --- parent ---                           | 50px</span><br><span class="line">         *                                  *</span><br><span class="line">         | 50px                       --- parent ---</span><br><span class="line">         *</span><br><span class="line">       child                              child</span><br><span class="line"></span><br><span class="line">   --- parent ---                     --- parent ---</span><br><span class="line"></span><br><span class="line">------- body -------               ------- body -------</span><br></pre></td></tr></table></figure>
<p>另一种情况是，当你在 div 元素内插入多个<strong>块级</strong>元素，你给其中相邻的两个设置 <code>margin-top</code> 和 <code>margin-bottom</code> ，你会发现，他们之间的距离为相对应的 <code>margin-top</code> 和 <code>margin-bottom</code> 中的最大值，当设置第一个块级元素的 <code>margin-top</code> 属性则会像第一种情形那样，父级框移动了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原以为：</span><br><span class="line"></span><br><span class="line">-------- parent -----------</span><br><span class="line">          | 10px</span><br><span class="line">        childA</span><br><span class="line">    10px  |</span><br><span class="line">          | ===&gt; 30px</span><br><span class="line">    20px  |</span><br><span class="line">        childB</span><br><span class="line">          | 20px</span><br><span class="line">          |</span><br><span class="line">-------- parent ----------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实际上：</span><br><span class="line">-------- body ---------</span><br><span class="line">          | 10px</span><br><span class="line">   ---- parent ----</span><br><span class="line">        childA</span><br><span class="line">          |</span><br><span class="line">          | max(10px, 20px) ==&gt; 20px</span><br><span class="line">        childB</span><br><span class="line">   ---- parent ----</span><br><span class="line">          |</span><br><span class="line">          | 20px</span><br><span class="line">-------- body ---------</span><br></pre></td></tr></table></figure>
<p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p>
<p>这里有个比较通俗易懂的例子：</p>
<h4 id="第一种情形"><a href="#第一种情形" class="headerlink" title="第一种情形"></a>第一种情形</h4><p>A 与 B 并排站，A 说：我站在距离前方 1m 的地方，接下来该你站位子了。<br>由于 A 与 B 之间没有明显的分割线，B 想了想没有动，说到：我现在和你在一条线上，那么我也应该站在距离前方 1m 的地方吧！</p>
<h4 id="第二种情形"><a href="#第二种情形" class="headerlink" title="第二种情形"></a>第二种情形</h4><p>A 与 B 相对站，A 说：我站在距离你 1m 的地方，该你了。<br>B 说：我应该站在距离你 2m 的地方，通过相对原理，我们应该间隔 2m 吧~</p>
<blockquote>
<p>从例子可以分析出，只要给予一个界限，即两者不是互相比对，基于某一个定点来决定位置，也就是我们说的形成 BFC 了</p>
</blockquote>
<h3 id="奇怪的布局"><a href="#奇怪的布局" class="headerlink" title="奇怪的布局"></a>奇怪的布局</h3><p>当在 div 元素内插入多个<strong>行内块级</strong>元素，你给其中<strong>任意一个</strong>或者<strong>多个</strong>设置 <code>margin-top</code> 想要使得它/它们表现得与众不同，可是，到头来所有元素都会移动，而且唯一准确的只有所设值最大的那个子元素，其他子元素则混淆。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（注：所有子元素高度为 height: 100px）</span><br><span class="line">原以为：</span><br><span class="line">                      parent</span><br><span class="line">----------------------------------------------------</span><br><span class="line">        | 50px        childB               | 25px</span><br><span class="line">      childA                            childC</span><br><span class="line">----------------------------------------------------</span><br><span class="line">                      parent</span><br><span class="line"></span><br><span class="line">实际上：</span><br><span class="line">                      parent</span><br><span class="line">----------------------------------------------------</span><br><span class="line">        | 50px          | 50px + 25px      | 50px - 25px</span><br><span class="line">      childA          childB            childC</span><br><span class="line">----------------------------------------------------</span><br><span class="line">                      parent</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS外边距塌陷<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">    background-color: black;</span><br><span class="line">    height: 500px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    width: 500px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;  <span class="comment">/*包含了 wrapper */</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.childA</span> &#123;</span></span><br><span class="line">    background-color: greenyellow;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 50px 0;</span><br><span class="line">    width: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.childB</span> &#123;</span></span><br><span class="line">    background-color: aliceblue;</span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.childC</span> &#123;</span></span><br><span class="line">    background-color: orangered;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 25px 0;</span><br><span class="line">    width: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="comment">/* 此为解决办法 */</span></span></span><br><span class="line">  /* .wrapper &#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">  &#125; */</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"childA"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"childB"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"childC"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>提示点：</p>
<ul>
<li><ol>
<li>默认对齐方式：基线对齐</li>
</ol>
</li>
<li><ol start="2">
<li>空元素的基线位置：底部</li>
</ol>
</li>
<li><ol start="3">
<li>block 元素的 inline 内容默认位置：block 元素的顶部</li>
</ol>
</li>
<li><ol start="4">
<li>盒子的默认类型： content-box</li>
</ol>
</li>
</ul>
<blockquote>
<p>可基于此 4 点，结合代码看页面呈现效果，应该提示的很清晰了，脑补一下即可~</p>
</blockquote>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://www.w3.org/TR/CSS21/visuren.html#block-formatting" target="_blank" rel="noopener">W3C</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">MDN</a></li>
<li><a href="http://www.ayqy.net/doc/css2-1/box.html" target="_blank" rel="noopener">盒模型</a></li>
<li><a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="noopener">BFC 神奇背后的原理</a></li>
<li><a href="http://www.cnblogs.com/zyl-Tara/p/7079708.html" target="_blank" rel="noopener">什么是BFC、IFC、GFC和FFC</a></li>
<li><a href="https://www.cnblogs.com/xuyatao/p/7525052.html" target="_blank" rel="noopener">从概念到业务来看 To B 和 To C 产品区别在哪</a></li>
</ul>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>此篇同样为原写的文章的一次改版，更新原有的错误，记录新的体会！</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 Proxy</title>
    <url>/2019/09/21/%E6%B5%85%E8%B0%88-proxy/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近阅读的 《你所不知道的 JavaScript 下篇》 基本上讲的都是 ES6 的一些知识，先前跟着阮一峰老师的 《ES6 入门》 一书，将大多数工作中常用的知识都过了一遍，但是少数稍微复杂的却都是“点到为止”，<code>Proxy</code> 代理正属于这一类。现在正好又学到了这一块，为了加深印象，还是写一篇博文以作记录。</p>
<blockquote>
<p>此篇仅记录一些基础内容，方便理解，更为深层次的内容之后有时间进行补充。</p>
</blockquote>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Proxy</code> 是什么，其有什么作用？简单来说，其主要是拦截对目标对象进行的一些操作，方便定义一些基本的操作以及配置自定义的用户行为。</p>
<p><code>Proxy</code> 的语法很简单，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxyObject = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>
<p>其中 <code>target</code> 为需要进行“代理”的对象，<code>handler</code> 则是对该对象进行拦截的一些配置了。</p>
<blockquote>
<p>引： <code>Proxy</code> 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
</blockquote>
<h4 id="handler-方法"><a href="#handler-方法" class="headerlink" title="handler 方法"></a>handler 方法</h4><p>handler 总共有 13 种可代理的方法，每一种方法都有与之对应的 Reflect 函数，具体的我就不全部列举出来了，这里今介绍一些可能会常用的：</p>
<h5 id="getOwnPropertyDescriptor-与-defineProperty"><a href="#getOwnPropertyDescriptor-与-defineProperty" class="headerlink" title="getOwnPropertyDescriptor 与 defineProperty"></a><code>getOwnPropertyDescriptor</code> 与 <code>defineProperty</code></h5><p>此两操作可以算是一种配套的操作，一个读取对象的属性描述符，另一个配置对象，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,&#123;</span><br><span class="line">    getOwnPropertyDescriptor(target, prop) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'called'</span> + prop);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(target, prop);</span><br><span class="line">    &#125;,</span><br><span class="line">    defineProperty(target, prop, descriptor) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'defined'</span>, prop);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(target, prop, descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.age = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// called age</span></span><br><span class="line"><span class="comment">// defined age</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： 当 handler 中有设置 get/set 方法时，此两 trap 会被覆盖掉。</p>
</blockquote>
<h5 id="get-与-set"><a href="#get-与-set" class="headerlink" title="get 与 set"></a><code>get</code> 与 <code>set</code></h5><p>此两方法一眼便知是拦截对象的读写操作，与上面的不同的是，此仅仅涉及到读与写的配置，更为详细的配置还是得依靠 <code>defineProperty</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,&#123;</span><br><span class="line">    <span class="keyword">get</span>(target, prop)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'get'</span>, prop)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop) || <span class="string">'-'</span>;</span><br><span class="line">        <span class="comment">// 直接 target[prop] 结果也一致</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, prop, value, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'set'</span>, prop, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, value, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.a = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set a 123</span></span><br><span class="line"><span class="comment">// get a</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<h5 id="apply-与-construct"><a href="#apply-与-construct" class="headerlink" title="apply 与 construct"></a><code>apply</code> 与 <code>construct</code></h5><p>此两方法主要用于扩展构造函数，例如 MDN 上的 extend 的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">sup, base</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 base 的 constructor 描述（不是原型链描述，而是构造函数描述）</span></span><br><span class="line">  <span class="comment">// base === base.prototype.constructor</span></span><br><span class="line">  <span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(</span><br><span class="line">    base.prototype, <span class="string">"constructor"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// base 的 prototype 继承 sup 的 prototype</span></span><br><span class="line">  base.prototype = <span class="built_in">Object</span>.create(sup.prototype);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加 base 构造函数的代理</span></span><br><span class="line">  <span class="keyword">var</span> handler = &#123;</span><br><span class="line">    <span class="comment">// new 对象时为目标对象绑定 __proto__ 链（就是手动实现 new 的过程）</span></span><br><span class="line">    construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 创建目标函数</span></span><br><span class="line">      <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(base.prototype);</span><br><span class="line">      <span class="comment">// 注：this 为 handler 对象，触发 apply 方法，绑定示例属性</span></span><br><span class="line">      <span class="keyword">this</span>.apply(target, obj, args);</span><br><span class="line">      <span class="comment">// 返回目标函数</span></span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 调用目标函数时，将 sup 的 base 的作用域绑定至实例对象</span></span><br><span class="line">    <span class="comment">// 也就是原来构造函数的那种 apply/call 写法</span></span><br><span class="line">    apply: <span class="function"><span class="keyword">function</span>(<span class="params">target, that, args</span>) </span>&#123;</span><br><span class="line">      sup.apply(that, args);</span><br><span class="line">      base.apply(that, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(base, handler);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数添加代理拦截</span></span><br><span class="line">  descriptor.value = proxy;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(base.prototype, <span class="string">"constructor"</span>, descriptor);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回配置后的代理</span></span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 name 需写在 age 前面，与父类保持一致</span></span><br><span class="line"><span class="comment">// 内部不在需要 apply/call 方法，已经通过代理处理了</span></span><br><span class="line"><span class="keyword">var</span> Boy = extend(Person, <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Boy.prototype.sex = <span class="string">"M"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此才会出发 handler</span></span><br><span class="line"><span class="keyword">var</span> Peter = <span class="keyword">new</span> Boy(<span class="string">"Peter"</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Peter.sex);  <span class="comment">// "M"</span></span><br><span class="line"><span class="built_in">console</span>.log(Peter.name); <span class="comment">// "Peter"</span></span><br><span class="line"><span class="built_in">console</span>.log(Peter.age);  <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">Proxy ES6</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">Proxy MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler" target="_blank" rel="noopener">handler MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈行内元素</title>
    <url>/2019/04/18/%E6%B5%85%E8%B0%88%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在工作中遇到很多奇怪的样式错位问题，解决问题之余，有重新温习了一下样式方面的知识。一般块级元素的问题都比较好解决，而行内元素的问题还总是得试试，可能是理解的不够透彻，因此此篇算是我对行内元素做的一个简短的笔记吧。</p>
<a id="more"></a>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="什么是行内元素"><a href="#什么是行内元素" class="headerlink" title="什么是行内元素"></a>什么是行内元素</h4><p>行内元素，顾名思义，就是指在在一行内不换行的元素。通俗来讲，行内元素相当于“句子”，其内可以包含数据与其它行内元素。</p>
<blockquote>
<p>一个行内元素只占据它对应标签的边框所包含的空间。<br><strong><em>MDN</em></strong> —— 行内元素</p>
</blockquote>
<h4 id="常见的行内元素"><a href="#常见的行内元素" class="headerlink" title="常见的行内元素"></a>常见的行内元素</h4><ul>
<li>b, big, i, small, tt</li>
<li>abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var</li>
<li>a, bdo, br, img, map, object, q, script, span, sub, sup</li>
<li>button, input, label, select, textarea</li>
</ul>
<h3 id="行盒子与浮动"><a href="#行盒子与浮动" class="headerlink" title="行盒子与浮动"></a>行盒子与浮动</h3><h4 id="文字环绕特效"><a href="#文字环绕特效" class="headerlink" title="文字环绕特效"></a>文字环绕特效</h4><p>word 文档内有“文字环绕”一表格属性，能够实现图片周围环绕文字，例如：</p>
<p><img data-src="/images/text-wrapping.png" alt="文字环绕效果"></p>
<p>当然，上图是 html 实现的，实现方法也很简单，代码如下（例 1-1）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span> <span class="attr">class</span>=<span class="string">"test-figure"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"test-img"</span> <span class="attr">src</span>=<span class="string">"./cat.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Alias, dolore qui obcaecati fuga ratione nobis dolor veniam soluta sequi rem voluptatem quo similique quis doloribus fugit autem! Quas, ipsum reiciendis?<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.test-figure</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.test-img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文字环绕原理"><a href="#文字环绕原理" class="headerlink" title="文字环绕原理"></a>文字环绕原理</h4><p>代码很简单，实现难度也不大，但是为什么这么写能够实现呢？它实现的原理又是什么呢？</p>
<p>其实，在我们所知的盒子模型中，除了基础的块级盒子和行内盒子，我们还有一个比较隐秘的匿名盒子。参考一个例子（例 1-2）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  我在块级盒子的匿名行内盒中</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>我在行内盒子的匿名行内盒中<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>回忆一下 CSS 选择器，其中有两个用的不是很多的<strong>伪元素选择器</strong>：<code>::first-letter</code>、<code>::first-line</code>，在此例中，它们选中的其实就是盒子模型中的匿名盒子的内容。那这个和我们所说的“文字环绕”又有什么关系呢？</p>
<p>我们知道，浮动会让元素脱离文档流，因此它不会再向非浮动元素影响其它元素的布局，因此在例 1-1 中，我们的 img 标签已经脱离了文档流，<strong>span 标签</strong> 此时在层级上会置于其下，如图：</p>
<p><img data-src="/images/anonymous-inline-box.png" alt="匿名行内盒"></p>
<p>但是！float 元素内的内容，也就是 <code>img</code> 的内容，它并不会跟随 <code>img</code> 标签一起浮动，而是仍然会存在于正常的文档流中，同时也会记住 <code>img</code> 标签的大小，因此在后面的匿名行盒子（<code>span</code> 中的）在计算其应该所在的位置时，会给 float 元素留出它所需要的空间，也就出现了“文字环绕”的样式。</p>
<blockquote>
<p>常用伪元素： ::before、::after</p>
</blockquote>
<h4 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a>知识拓展</h4><p>因为浮动并不算是完全脱离文档流，因此在开发中还会出现不少 <code>bug</code>，比如：“高度塌陷”，在处理这类问题时，我们经常用到的方法是 <code>clear: both;</code> ，例如（例 1-3）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里就用类名表示相应效果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clear-both"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是浏览器在对这做处理时，会为浮动元素留下足够大的空间，也就是给我们的元素加隐性的 <code>padding</code>，从而实现换行的效果（注意： span 标签不生效，<code>display: block</code> 才生效）。</p>
<h3 id="行内元素的排版"><a href="#行内元素的排版" class="headerlink" title="行内元素的排版"></a>行内元素的排版</h3><h4 id="行盒子的构造"><a href="#行盒子的构造" class="headerlink" title="行盒子的构造"></a>行盒子的构造</h4><p>处理行内元素时，比较令人头疼的就是它们的对齐方式了。虽然对应的知识都比较了解，在项目中遇到多个行内元素没有对齐时，稍微多几次尝试基本上也能够搞定对齐，万一实在弄不定，一个 <code>flex</code> 布局基本能解决所有的痛苦。但是，仅仅这样也就止步于此了，不明白的点最终也弄不明白，因此，我稍微花了些时间去了解了一下行盒子到底是什么东西。</p>
<p>此处引用《精通 CSS，高级 Web 解决方案》里面的一张图：</p>
<p><img data-src="/images/inline-box.jpeg" alt="行内格式化模型"></p>
<p>这里将行内格式化模型描述很清晰。由于行内盒子不能显示的设置高度，因此决定行内元素的高度那就剩下：<strong>内容高度</strong>。而影响内容高度的有两属性，分别是： <code>line-height</code> 与 <code>font-size</code>（当然 font-family 也会有一定影响）。</p>
<p>行盒子的行高计算方法是：<strong>行盒子的整体高度</strong>减去<strong><code>font-size</code></strong>，剩余的值再平均分成两份，也就是图内的“半铅空”。例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.inline-box</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">28px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么“半铅空”为 8px。加入 <code>line-height</code> 值为数字，如： <code>line-height: 1.5</code>，则表明当前 <code>line-height</code> 为当前 <code>font-size</code> 的 1.5 倍，计算方法不变。</p>
<p>因此在编写样式时，如果发现和设计稿不一致的情况时，若是行内元素，那么就可以考虑下是否是<strong>行高</strong>造成的问题了。</p>
<h4 id="行内元素的对齐方式"><a href="#行内元素的对齐方式" class="headerlink" title="行内元素的对齐方式"></a>行内元素的对齐方式</h4><p>除了 <code>line-height</code> 之外，影响行内元素对齐的属性那就是 <code>vertical-align</code> 了。它的默认对齐属性值为 <code>baseline</code>。除了 <code>baseline</code> 之外，其实还有很多对齐方式，如： <code>middle</code>, <code>text-top</code>, <code>bottom</code> 等等（更多的可参阅 MDN），举个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  span &#123;</span><br><span class="line">    vertical-align: "middle"</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>This is a paragraph, and this is a <span class="tag">&lt;<span class="name">em</span>&gt;</span>special<span class="tag">&lt;/<span class="name">em</span>&gt;</span> word.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>行内元素对齐比较常见的问题在于<em>图片</em>的对齐，一般的行内元素对齐要么令其行高一致，要么 <code>vertical-align</code> 统一配置同一值即可，但是图片比较特殊，对齐大概分为这么几种：</p>
<ol>
<li>top、text-top</li>
<li>middle</li>
<li>baseline</li>
<li>bottom、text-bottom、sub</li>
</ol>
<p>除了 <code>middle</code> 之外，其余的对齐方式会以图片的顶部或者底部来与其余行内元素对齐，因此设置图片对齐方式一般用 <code>vertical-align: middle</code>；又因为默认的行内元素对齐方式为 <code>vertical-align: baseline</code>，因此会出现图片与行内元素无法对齐的情况，了解清楚了这一点那么问题就很好解决了，即：统一行内元素的 <code>vertical-align</code> 的对齐方式为 <code>middle</code> 即可。</p>
<blockquote>
<p>注：<code>line-height</code> 设置后会影响 top、bottom 位置，全部保留原来的不变则效果一样，详见 MDN</p>
</blockquote>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elemente#See_also" target="_blank" rel="noopener">MDN 行内元素</a></li>
<li><a href="http://www.ayqy.net/doc/css2-1/visuren.html#anonymous" target="_blank" rel="noopener">匿名行内盒</a></li>
<li><a href="http://www.ayqy.net/doc/css2-1/visuren.html#float-position" target="_blank" rel="noopener">浮动定位: float 属性</a></li>
<li><a href="https://segmentfault.com/a/1190000012156828?utm_source=tag-newest" target="_blank" rel="noopener">伪类与伪元素</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" target="_blank" rel="noopener">MDN vertical-align</a></li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解 this</title>
    <url>/2019/05/19/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-this/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 JavaScript 学习过程中，除了作用域与闭包之外，困扰我们的难点还有 this，甚至可以说是前端 JS 学习的噩梦。实际上 this 并没有想象中的那么复杂，只是开发者往往会将理解过程复杂化，在缺乏清楚认识的情况下，this 对我们来说就完全是一种魔法了。而此篇就来揭开 this 神秘的面纱。</p>
<blockquote>
<p>注：此篇为学习《你所不知道的 JS》时的心得总结</p>
</blockquote>
<a id="more"></a>
<h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><p>工作中我们常常遇到 this 指向问题，看个简单的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`foo: <span class="subst">$&#123;num&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// case 1:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    foo(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.count); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case 2:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    foo.call(foo, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.count); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>了解比较深入的会一眼看出为什么加一个 call 就没问题（强绑定指向），了解的一般的就会通过声明一个全局变量来缓存对应的值来绕过 this，虽然用这种其它变量替代 this 能够绕过这个问题，但是这样永远也了解不到 this 的真谛。回过头来思考，为什么必须强绑定才能正确指向？如果不进行强绑定，this 默认又指向什么呢？要深入了解到 this 的原理，首先我们得认识到自己的理解误区。</p>
<h3 id="理解误区"><a href="#理解误区" class="headerlink" title="理解误区"></a>理解误区</h3><p>学习 this 时常见的错误理解大致有两种：</p>
<ul>
<li>this 指向函数自身</li>
<li>this 指向函数作用域</li>
</ul>
<p>可能因为我们最早接触的语言是 C 语言，而 C 语言的编译顺序大致为：</p>
<ol>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
<li>中间代码生成</li>
<li>代码优化（可不要）</li>
<li>目的代码生成</li>
</ol>
<p>因此在学习 JS 是会自然而然的套用此方法来理解函数。我们可以试想一下，如果 JS 也走这么一套流程来处理，那么网页的加载得多慢啊。因此在编译这部分我们得抛弃 C 语言的那一套逻辑，这样才方便理解 this 的指向。</p>
<p>与 C 语言编译不同，JS 的编译为运行时编译，其会先从头到尾“过”一遍待解析的文件，粗略的提取其中的变量声明，然后逐行解析编译（解释了为什么会变量提升），因此 this 的状态就并非那种能够生成中间代码的<strong>存储态</strong>，而是<strong>动态</strong>的。也就是说，当函数执行时，this 才会真正的进行绑定，而并不是在最开始（遍历 JS 语法）时绑定，毕竟没有听说过什么“ this 提升”对吧？</p>
<p>简而言之，因为 this 是在函数调用时才进行绑定，所以 this 并不是指向其所在的函数自身，也不指向函数所在的词法作用域，它的指向完全取决于函数在哪里被调用的。</p>
<h3 id="this-全面解析"><a href="#this-全面解析" class="headerlink" title="this 全面解析"></a>this 全面解析</h3><h4 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h4><p>前面有提到 this 指向取决于函数是在哪里调用的，即找到函数的调用位置，相当于我们就定位了 this。而寻找函数的<strong>调用位置</strong>，首先得找到函数所在的<strong>栈的位置</strong>，该栈所在的环境即 this 的指向。举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前所在的栈为 foo</span></span><br><span class="line">  <span class="comment">// 因此，当前调用位置是 全局作用域（this = window）</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">  bar(); <span class="comment">// bar 调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前所在的栈为 foo -&gt; bar</span></span><br><span class="line">  <span class="comment">// 因此当前的调用位置是在 foo 中 (this = this(foo) = window)</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// foo 调用的位置</span></span><br></pre></td></tr></table></figure>
<p>既然我们已经找到了 this 调用位置，那么 this 的值此时到底是什么，它所绑定的内容又是什么呢，而这就涉及到 this 的绑定规则。</p>
<h4 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h4><p>找到 this 的调用位置之后，我们可以按照以下四条规则来判断 this 绑定的对象。</p>
<ol>
<li>如果由 new 调用，那么 this 绑定到新创建的对象。</li>
<li>如果由 call 或者 applay（或者 bind）调用，那么绑定到其指定的对象。</li>
<li>如果由上下文对象调用，则绑定到该上下文对象。</li>
<li>默认：严格模式下绑定至 undefined，否则绑定至 window。</li>
</ol>
<p>接下来就让我们自下而上，由面到点的了解这些绑定规则以及其排序来由。</p>
<blockquote>
<p>注：上下文对象绑定即所谓的隐式绑定</p>
</blockquote>
<h5 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h5><p>举个很简单的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>调用 this 的调用栈在 foo 中，当前所处的位置是全局作用域，因此 this 指向全局的 window。</p>
<p>回头看先前<a href="#调用位置">调用位置</a>时列举的例子，通过默认绑定规则，再加上引用传递，因此各部分的 this 指向都指向全局的 window 对象。</p>
<h5 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h5><p>隐式绑定，即规则的调用位置是否拥有其上下文（默认为全局的 window 对象）。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"test"</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// test</span></span><br></pre></td></tr></table></figure>
<p>在非严格模式下，全局环境的 this.name === window.name，此时所处的上下文环境为全局环境，而此例的 foo 调用是通过 obj.foo 来调用的，this 的调用位置为 foo，但是 foo 的引用落脚点此时不是 window 了，而是 obj 了，因此通过隐式绑定，this 此时之乡的是 obj，即此时的 this.name === obj.name。</p>
<p>此处需注意的一点是 obj.foo 的 this 绑定的是 obj（隐士绑定），这是因为，对象属性的引用链只有<strong>最顶层</strong>会影响调用位置（或者是说最后一层），例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">"test1"</span>,</span><br><span class="line">  obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">"test2"</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); <span class="comment">// test2</span></span><br></pre></td></tr></table></figure>
<p>而在隐式调用的情况下，最容易<strong>出现的问题</strong>是隐式丢失，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"test"</span>,</span><br><span class="line">  getName: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 1: 解构</span></span><br><span class="line"><span class="keyword">const</span> &#123; getName &#125; = obj;</span><br><span class="line">getName(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 2: 直接取引用（类比解构）</span></span><br><span class="line"><span class="keyword">const</span> linkFunc = obj.getName;</span><br><span class="line">linkFunc(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 3: 引用传递（类比 setTimeout)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linkPassFunc</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line">linkPassFunc(obj.getName)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：参数传递就是一种隐式传递，其取得是对象的引用</p>
</blockquote>
<h5 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h5><p>JS 提供一种显示更改 this 绑定的函数：apply、call，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'test'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(obj); <span class="comment">// test</span></span><br></pre></td></tr></table></figure>
<p>通过 foo.call 可以显示的将 this 绑定在 obj 上，显示绑定无法解决隐式绑定中的引用传递问题（上面的 Case 3），而通过一种变形“硬绑定”可以解决。</p>
<h6 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h6><p>与显示绑定不同的是，硬绑定会提前将 this 的指向在<strong>过渡函数</strong>内提前绑定上，这样当传入这个过渡函数时，this 就不会被隐式修改了，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'test'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过渡函数，内部提前显示绑定 this</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo.call(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// test</span></span><br><span class="line"></span><br><span class="line">setTimeout(bar, <span class="number">100</span>); <span class="comment">// test</span></span><br></pre></td></tr></table></figure>
<p>其实这种方式特别常见（如大多数源码中），将上例稍微变化一下，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">otherContent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.prefix&#125;</span>-<span class="subst">$&#123;otherContent&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此处的 arguments 为此无名函数的 arguments，硬绑定函数 this 指向</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  prefix: <span class="string">'my'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prefixFunc = bar(foo, obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prefixStr = prefixFunc(<span class="string">'age'</span>);</span><br></pre></td></tr></table></figure>
<p>绕是绕了点，根据函数式编程的带入思想，其实就相当于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> prefixStr = foo.apply(obj, [<span class="string">'age'</span>]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： 硬绑定会大大降低函数的灵活性，使用硬绑定后就无法使用隐式绑定或者显示绑定来改变 this 了。</p>
</blockquote>
<h5 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h5><p>JavaScript 中所谓的“构造函数”其实与其它语言的类的构造函数不同，它并不属于某一个类，也不会去实例化一个类。在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。使用 new 来调用函数时，会执行以下操作：</p>
<ol>
<li>创建（或者说构造）一个全新的对象</li>
<li>这个新对象会被执行 [[原型]] 连接</li>
<li>这个新对象会绑定到函数调用的 this</li>
<li>如果函数没有返回其它对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>
</ol>
<p>面试题中可能会遇到这么一个题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f1 = <span class="keyword">new</span> foo1(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> f2 = <span class="keyword">new</span> foo2(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1.a === f2.a);</span><br></pre></td></tr></table></figure>
<p>知道这个 new 返回对象的“魔术”之后，我们就很清楚答案是 false 了，因为 foo2 有返回对象。而 foo1 因为没有函数返回值，因此会构造一个新对象并将 this 绑定至该新对象上。</p>
<p>new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。</p>
<blockquote>
<p>提示： f1.a 为 1; f2.a 为 2</p>
</blockquote>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>现在规则我们已经比较清楚了，那么剩下的就是找到函数的调用位置，然后该使用那种规则去匹配。“默认绑定”毫无疑问是四条规则中优先级最低的，那么另外三条规则的优先级又该如何排序呢？那么我们一一来分析～</p>
<blockquote>
<p>先给出结论： new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
</blockquote>
<h5 id="隐式绑定和显示绑定"><a href="#隐式绑定和显示绑定" class="headerlink" title="隐式绑定和显示绑定"></a>隐式绑定和显示绑定</h5><p>举个很简单的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line">obj1.foo(); <span class="comment">// 2</span></span><br><span class="line">obj2.foo(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示绑定尝试更改</span></span><br><span class="line">obj1.foo.call(obj2); <span class="comment">// 3</span></span><br><span class="line">obj2.foo.call(obj1); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>通过对比可以看到，显示绑定优先级更高。那么隐式绑定和 new 绑定的优先级顺序呢？</p>
<h5 id="隐式绑定和-new-绑定"><a href="#隐式绑定和-new-绑定" class="headerlink" title="隐式绑定和 new 绑定"></a>隐式绑定和 new 绑定</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定为 obj1 绑定 a 属性</span></span><br><span class="line">obj1.foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new 绑定尝试更改返回对象中的 this 指向（隐式原理应该 this 指向链尾的 obj1）</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> obj1.foo(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.a); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>可以看到 new 绑定比隐式绑定优先级高，接下来就只剩 new 绑定和显示绑定的优先级了。</p>
<h5 id="new-绑定和显示绑定"><a href="#new-绑定和显示绑定" class="headerlink" title="new 绑定和显示绑定"></a>new 绑定和显示绑定</h5><p>由于 new 和 call/apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接进行测试。但是我们可以用硬绑定来测试它们的优先级。举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 显示绑定 this 为 obj1</span></span><br><span class="line"><span class="keyword">const</span> bar = foo.bind(obj1);</span><br><span class="line">bar(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new 尝试修改返回对象的 this 指向</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(baz.a); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>在 new 中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用 new 进行初始化时就可以只传入其余的参数。bind(…)的功能之一就是可以把除了第一个参数（第一个参数用于绑定 this）之外的其他参数都传递给下层的函数（这种技术称为“部分应用”，是“柯里化”的一种）。举例来说：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之所以使用 null 是因为在本例中我们并不关心硬绑定的 this 是什么</span></span><br><span class="line"><span class="comment">// 反正使用 new 时 this 会被修改</span></span><br><span class="line"><span class="keyword">const</span> bar = foo.bind(<span class="literal">null</span>, <span class="string">'p1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="keyword">new</span> bar(<span class="string">'p2'</span>);</span><br><span class="line"></span><br><span class="line">baz.val; <span class="comment">// p1p2</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>注意，这种通过 null 的绑定其实会使用“默认绑定”规则，将 this 绑定至全局对象，这在使用第三方库时会存在风险，更为稳妥的方法是创建一个真正意义上的空对象，如： let ø = object.create(null)，然后将此 ø 作为绑定的作用域（const bar = foo.bind(ø, ‘p1’);）</p>
          </div>
<h4 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h4><h5 id="被忽略的-this"><a href="#被忽略的-this" class="headerlink" title="被忽略的 this"></a>被忽略的 this</h5><p>call、apply、bind 接受绑定的对象为 undefined、null 时，在调用时会被忽略，使用的是默认绑定规则，严格来说最好使用一个真正的 ø 元素来作为绑定对象（前面已经提到）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实绑定的还是 window，可能造成全局污染</span></span><br><span class="line">foo.call(<span class="literal">null</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h5 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h5><p>这个就不难说明了，间接引用会使得隐式绑定最顶端的对象改变，造成 this 的指向非我们所想象的对象，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test 已经不是绑定顶端的对象，变成了 window 了</span></span><br><span class="line"><span class="keyword">const</span> func = test.foo;</span><br><span class="line">func(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据外层作用域来决定 this。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 此处的 this 在词法上继承自 foo</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们在使用这种 ES6 的“胖箭头”时，就可以抛弃 ES5 中的 <code>var self = this</code> 的“词法作用域”式的代码了。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>由 shims-vue.d.ts 引发的思考</title>
    <url>/2019/07/07/%E7%94%B1-shims-vue-d-ts-%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于项目近期进行 ts 迁移，作为第一个吃螃蟹的人，踩过了不少坑。迁移过程中遇到的大大小小的问题基本上都解决了，但是对于 shims-vue.d.ts 文件的命名以及其内的模块声明始终找不到比较贴切的解释。沉下心来读了些外网资料，总算是有点“豁开云雾见青天”的感觉了。此处就记录我对于 ts 全局模块声明的一些思考以及一些 ts 项目迁移遇到的坑。</p>
<a id="more"></a>
<h3 id="Vue-ts-声明文件"><a href="#Vue-ts-声明文件" class="headerlink" title="Vue ts 声明文件"></a>Vue ts 声明文件</h3><p>在安装 @vue/typescript 之后，项目会生成两个新文件，分别是 <code>shims-vue.d.ts</code> 和 <code>shims-jsx.d.ts</code>，其内容分别是：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shims-vue.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*.vue' &#123;</span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue, &#123; VNode &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> global &#123;</span><br><span class="line">  <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">    <span class="comment">// tslint:disable no-empty-interface</span></span><br><span class="line">    <span class="keyword">interface</span> Element <span class="keyword">extends</span> VNode &#123; &#125;</span><br><span class="line">    <span class="comment">// tslint:disable no-empty-interface</span></span><br><span class="line">    <span class="keyword">interface</span> ElementClass <span class="keyword">extends</span> Vue &#123; &#125;</span><br><span class="line">    <span class="keyword">interface</span> IntrinsicElements &#123;</span><br><span class="line">      [elem: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这两个文档有什么作用呢？</p>
<h4 id="shims-vue-d-ts"><a href="#shims-vue-d-ts" class="headerlink" title="shims-vue.d.ts"></a>shims-vue.d.ts</h4><p>前者为 Ambient Declarations(通称：外部模块定义) ,主要为项目内所有的 vue 文件做模块声明，毕竟 ts 默认只识别 .d.ts、.ts、.tsx 后缀的文件；（即使补充了 Vue 得模块声明，IDE 还是没法识别 .vue 结尾的文件，这就是为什么引入 vue 文件时必须添加后缀的原因，不添加编译也不会报错）</p>
<h4 id="shims-jsx-d-ts"><a href="#shims-jsx-d-ts" class="headerlink" title="shims-jsx.d.ts"></a>shims-jsx.d.ts</h4><p>后者为 JSX 语法的全局命名空间，这是因为<strong>基于值的元素</strong>会简单的在它所在的作用域里按标识符查找（此处使用的是<strong>无状态函数组件 (SFC)</strong>的方法来定义），当在 tsconfig 内开启了 jsx 语法支持后，其会自动识别对应的 .tsx 结尾的文件，可参考<a href="https://www.tslang.cn/docs/handbook/jsx.html" target="_blank" rel="noopener">官网 jsx</a>。</p>
<h4 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a>产生的问题</h4><p>首先，官方文档的上并没有将 shims-xxx.d.ts 做为通用的模板，其仅仅给我们列举了以下模板样例：</p>
<ul>
<li>global-modifying-module.d.ts</li>
<li>global-plugin.d.ts</li>
<li>global.d.ts</li>
<li>module-class.d.ts</li>
<li>module-function.d.ts</li>
<li>module-plugin.d.ts</li>
<li>module.d.ts</li>
</ul>
<p>那么该如何理解这两个文件？</p>
<p>是否能够更改在统一规范的文件内？</p>
<p>全局接口、命名空间、模块等声明又有那些写法来定义？该如何写？</p>
<p>… 对于产生的这么些问题，下面依次分析。</p>
<h3 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h3><h4 id="理解并改造-shims-xxx-d-ts"><a href="#理解并改造-shims-xxx-d-ts" class="headerlink" title="理解并改造 shims-xxx.d.ts"></a>理解并改造 shims-xxx.d.ts</h4><p>我们知道，xxx.d.ts 的文件表明，其内部的一些声明都为全局的声明，能够在项目各组件内都能获取到。因此 Vue 生成的两个 shims-xxx.d.ts 其实是为了表明，该两文件为 Vue 相关的全局声明文件。</p>
<p>但是从项目管理来说，随着引入的 npm 模块增多（比如公司内部 npm 源上的不带 types 的包），那么模仿 Vue 的声明文件写法，外部声明的文件也会越来越多，文件夹看起来就不是很舒服了。因此有没有一种比较好的方法来解决文件过多的问题呢？</p>
<p>对于我来说，我更偏向将这些简单的声明维护在一个 .d.ts 文件内，正好官网也推荐维护在一个大的 module 内，因此我们可以维护一个 module.d.ts 来总体声明所有的外部模块。基于官方的例子，我做了两个文件来管理外部模块的声明，分别是 <code>module.d.ts</code> 和 <code>declarations.d.ts</code>。前者主要维护需要写的比较详细的外部模块，后者主要维护简写模式的模块（包括内部需要声明的 .js 文件，兼容历史遗留问题）。例如：</p>
<p>改造后的 module/index.d.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This `declare module` is called ambient module, which is used to describe modules written in JavaScript.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 vue-clipboard2 的 Vue 插件声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'vue-clipboard2' &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; PluginFunction &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">  <span class="keyword">const</span> clipboard: PluginFunction&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">  <span class="comment">// 定义默认导出的类型</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> clipboard;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 fe-monitor-sdk 的 Vue 插件声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'fe-monitor-sdk' &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; PluginObject &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">  <span class="comment">// 定义解构的变量类型</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> monitorVue: PluginObject&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加所有 .vue 文件的声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*.vue' &#123;</span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造后的 module/declarations.d.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Shorthand ambient modules, All imports from this shorthand module will have the any type.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '@/cookie-set';</span><br></pre></td></tr></table></figure>
<blockquote>
<p>附加：对于 global 声明可视情况分类，比如通用的放在 <code>global.d.ts</code>，其余可视情况（如果该类型比较多的话）按照对应类型分类，比如 table 的可全部放在 <code>global-table.d.ts</code>。</p>
</blockquote>
<h4 id="全局声明的写法"><a href="#全局声明的写法" class="headerlink" title="全局声明的写法"></a>全局声明的写法</h4><p>另一个一直比较疑惑的问题是全局声明的写法，比如模块的“单文件单模块声明”的写法“单文件多模块合并声明”的写法不太一样，“无导入的全局声明文件”和“带导入声明的全局声明文件”的写法又有些不同，这里我一一列出其可行的写法以及其不同的原因。</p>
<blockquote>
<p>注：这里的一些定义都是个人总结的便于记忆的说法，为非标准定义。</p>
</blockquote>
<h5 id="单文件单模块声明"><a href="#单文件单模块声明" class="headerlink" title="单文件单模块声明"></a>单文件单模块声明</h5><p>该文件支持两种写法，分别如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*.vue' &#123;</span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*.vue' &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： 前者（写法一）主要为无 ts 声明的模块添加声明，后者（写法二）主要为已有 types 声明的模块进行声明扩展（可以参考 <a href="https://github.com/vuejs/vue-router/blob/dev/types/vue.d.ts" target="_blank" rel="noopener">vue-router 源码部分</a>）</p>
</blockquote>
<h5 id="单文件多模块合并声明"><a href="#单文件多模块合并声明" class="headerlink" title="单文件多模块合并声明"></a>单文件多模块合并声明</h5><p>仅有一种写法（需要关闭对应的多次引入重复模块的 lint 规则或者忽略此 types 文件夹内的所有内容）</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*.vue' &#123;</span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="无导入的全局声明文件"><a href="#无导入的全局声明文件" class="headerlink" title="无导入的全局声明文件"></a>无导入的全局声明文件</h5><p>无导入即没有 import 声明，直接定义全局接口、函数等</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> TableRenderParam <span class="keyword">extends</span> BasicObject &#123;</span><br><span class="line">  row: BasicObject,</span><br><span class="line">  key: <span class="built_in">string</span>,</span><br><span class="line">  index?: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="带导入声明的全局声明文件"><a href="#带导入声明的全局声明文件" class="headerlink" title="带导入声明的全局声明文件"></a>带导入声明的全局声明文件</h5><p>带有 import 导入插件声明的必须显示定义 global，例如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CreateElement &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function 部分</span></span><br><span class="line"><span class="keyword">declare</span> global &#123;</span><br><span class="line">  <span class="keyword">interface</span> TableRenderFunc &#123;</span><br><span class="line">    (h: CreateElement, &#123; row, key, index &#125;: TableRenderParam): JSX.Element,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// namespace 部分</span></span><br><span class="line"><span class="keyword">declare</span> global &#123;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="不同的原因"><a href="#不同的原因" class="headerlink" title="不同的原因"></a>不同的原因</h5><p>如果在“单文件多模块合并声明”将 import 提出至最顶层时，会发现 ts 报错，说模块无法进一步扩大，为什么将 import 提出后会报错提示模块无法扩大？</p>
<p>个人研究得出的结论是，当将 import 提出至模块外时，就已经表明该文件内的其它 declare 的模块已经是存在 ts 声明的模块，此时再对其进行 declare 声明即对其原本的声明上进行扩展（可参考 vue-router 对于 vue 的扩展），但是对于没有 ts 声明的模块，我们拿不到它的 ts 声明，因此也就没发进行模块扩展，所以就会报错。</p>
<p>而将 import 放至模块内时，因为 module 本来就表明自己为一个模块，其就可以作为模块的声明，为没有对应声明的模块添加声明了。</p>
<p>此外，对于多个 declare global 的写法，此是采用了<strong><a href="(https://www.tslang.cn/docs/handbook/declaration-merging.html">声明合并</a>)</strong>的方式，使得所有的模块声明都合并至同一个 global 全局声明中，因此，在对于将 import 提至外层的“带导入声明的全局声明文件”来说，分文件全局维护或者单文件声明合并式维护都是可行的。</p>
<div class="note info">
            <p>TypeScript与ECMAScript 2015一样，任何包含顶级import或者export的文件都被当成一个模块。相反地，如果一个文件不带有顶级的import或者export声明，那么它的内容被视为全局可见的（因此对模块也是可见的）。</p>
          </div>
<h3 id="ts-踩坑记录"><a href="#ts-踩坑记录" class="headerlink" title="ts 踩坑记录"></a>ts 踩坑记录</h3><p>已经维护至博文<a href="/2019/07/14/项目-ts-迁移的踩坑记录/" title="项目 ts 迁移的踩坑记录">项目 ts 迁移的踩坑记录</a>中了</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://www.tslang.cn/docs/handbook/namespaces-and-modules.html" target="_blank" rel="noopener">命名空间和模块</a></li>
<li><a href="https://github.com/Microsoft/TypeScript-Handbook/issues/180" target="_blank" rel="noopener">Clarify what “ambient” means</a></li>
<li><a href="https://basarat.gitbooks.io/typescript/docs/types/ambient/intro.html" target="_blank" rel="noopener">Ambient Declarations</a></li>
<li><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">TypeScript 入门教程</a></li>
<li><a href="https://github.com/vuejs/vue-cli/issues/1198" target="_blank" rel="noopener">Typescript: IDE reports TS2307</a></li>
<li><a href="https://stackoverflow.com/questions/44058101/typescript-declare-third-party-modules" target="_blank" rel="noopener">typescript declare third party modules</a></li>
<li><a href="https://my.oschina.net/fenying/blog/747184" target="_blank" rel="noopener">TypeScript 的两种声明文件写法的区别和根本意义</a></li>
<li><a href="https://idom.me/articles/838.html" target="_blank" rel="noopener">区分 TS 中的 namespace 和 module</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>背景水印与 MutationObserver</title>
    <url>/2020/08/05/%E8%83%8C%E6%99%AF%E6%B0%B4%E5%8D%B0%E4%B8%8E-MutationObserver/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为项目需要配置背景水印，仅呈现背景水印这并没有什么难度，但是问题是当背景水印部分的代码通过什么原因被干掉了（例如：打开控制台，给背景水印部分代码加上 <code>display: none</code>），需要检测这个变化重新将水印更新会原状，emmmm，这就有的折腾了。于是乎就发现了 <code>MutationObserver</code> 方法，在此简单笔记一下。</p>
<a id="more"></a>
<h3 id="MutationObserver-作用"><a href="#MutationObserver-作用" class="headerlink" title="MutationObserver 作用"></a>MutationObserver 作用</h3><p>简单来说，该方法就是用来监听 Dom 变化的，Dom 的任何微小变动它都能接受得到。引用一下阮老师对 <code>Mutation Observer</code> 的特点的描述：</p>
<blockquote>
<ul>
<li>它等待所有脚本任务完成后，才会运行（即异步触发方式）</li>
<li>它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。</li>
<li>它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。</li>
</ul>
</blockquote>
<p>因此在父级元素上挂在一个 MutationObserver 事件监听方法，不就可以做到对背景水印元素变动的监听了么！</p>
<h3 id="背景水印的解决思路"><a href="#背景水印的解决思路" class="headerlink" title="背景水印的解决思路"></a>背景水印的解决思路</h3><p>由于是公司内部代码，这里就不做粘贴了，仅说明一下水印的解决思路。</p>
<ul>
<li>检测 DOM 上是否存在水印节点，不存在则新增水印节点</li>
<li>为水印节点新增 Mutation Observer 方法，观察其对应属性变化，更新监听</li>
</ul>
<p>配合 Vue 的逻辑则是编写一个 vue 的全局指令，做到动态更新即可。</p>
<h3 id="MutationObserver-示例"><a href="#MutationObserver-示例" class="headerlink" title="MutationObserver 示例"></a>MutationObserver 示例</h3><p>该例子只是对 <code>Mutation Observer API</code> 的学习例子，仅供参考。</p>
<blockquote>
<p><a href="https://github.com/kazehaiya/mutation-observer-demo" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MDN MutationObserver</a></li>
<li><a href="https://javascript.ruanyifeng.com/dom/mutationobserver.html#toc0" target="_blank" rel="noopener">Mutation Observer API</a></li>
<li><a href="https://juejin.im/post/6844904065059536909" target="_blank" rel="noopener">MutationObserver 与 ResizeObserver</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>记 JS 对象属性顺序</title>
    <url>/2019/10/09/%E8%AE%B0-JS-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>早期与后台对接接口时，让后台区分开数组与对象的传递参数，对于为什么也仅仅只是知道对象遍历顺序无法像数组一样得到保证，具体是怎么个规则还是不太了解。最近在学习了解 <code>Reflect</code> 部分知识时，正好又看到了对象属性排序部分的内容，因此做个笔记记录下来，用作备忘。</p>
<blockquote>
<p>该部分基本上来自书本内容，夹带一些个人理解</p>
</blockquote>
<a id="more"></a>
<h3 id="ES6-属性顺序"><a href="#ES6-属性顺序" class="headerlink" title="ES6 属性顺序"></a>ES6 属性顺序</h3><p>对于 ES6 之前，一个对象的属性列出的顺序是依赖于具体实现，并未在规范中定义。虽然多数引擎按照创建的顺序进行枚举，但是开发者们一直强烈建议不要依赖这个顺序。</p>
<p>而对于 ES6 来说，拥有属性的列出顺序则是又 <code>[[OwnPropertyKeys]]</code> 算法定义的（ES6 规范 <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys" target="_blank" rel="noopener">9.1.12</a> 节），其顺序为：</p>
<ol>
<li>首先，按照数字上升排序，枚举所有的整数索引拥有的属性；</li>
<li>然后，按照创建顺序枚举其余的拥有的字符串属性名；</li>
<li>最后，按照创建顺序枚举拥有的符号属性。</li>
</ol>
<blockquote>
<p>此顺序只对 <code>Reflect.ownKeys(...)</code> （以及扩展的 <code>Object.getWonPropertyNames(...)</code> 和 <code>Object.getOwnPropertySymbols(...)</code> ）有保证，为 <code>[[OwnPropertyKeys]]</code> 算法。</p>
</blockquote>
<div class="note warning">
            <p>此算法不会遍历原型链上的属性</p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>(<span class="string">'a'</span>)] = <span class="string">'symbol property'</span>;</span><br><span class="line">obj[<span class="number">1</span>] = <span class="string">'number property'</span>;</span><br><span class="line">obj.str = <span class="string">'string property'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj);  <span class="comment">// ["1", "str", Symbol(a)]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj);  <span class="comment">// ["1", "str"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj);  <span class="comment">// [Symbol(a)]</span></span><br></pre></td></tr></table></figure>
<h3 id="枚举算法"><a href="#枚举算法" class="headerlink" title="枚举算法"></a>枚举算法</h3><p>ES6 规范中还有另外一种 <code>[[Enumerate]]</code> 算法（ES6 规范 <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-ordinary-object-internal-methods-and-internal-slots-enumerate" target="_blank" rel="noopener">9.1.11</a> 节），其只从目标对象和 prototype 原型链产生可枚举属性。其可以观察到的顺序与具体实现有关，不由规范控制。</p>
<p>对于日常工作中常用的 <code>Object.keys(...)</code>、<code>for ... in</code> 和 <code>JSON.stringify(...)</code>（还有 <code>Reflect.enumerate(...)</code>）基本上属于 <code>[[Enumerate]]</code> 算法。此四种方法虽然严格上是通过不同路径实现排序的，但将其与 <code>[[OwnPropertyKeys]]</code> 的排序相匹配的具体实现还是允许的，但些许又些差别：</p>
<blockquote>
<p>附：本质上 <code>Reflect.enumerate(...)</code> 和 <code>for ... in</code> 的实现方式是一样的</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Parent.prototype = &#123;</span><br><span class="line">  age: <span class="number">123</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">234</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'b'</span>)]: <span class="number">345</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>(<span class="string">'a'</span>)] = <span class="string">'symbol property'</span>;</span><br><span class="line">obj[<span class="number">1</span>] = <span class="string">'number property'</span>;</span><br><span class="line">obj.str = <span class="string">'string property'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// ['1', 'str']</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// &#123;"1":"number property","str":"string property"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象 -&gt; 原型链，每一层的显示方式同上面的规范，整体上的排序则是和具体实现相关</span></span><br><span class="line"><span class="comment">// 此处的具体实现则是先对象这一层，然后原型链层</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop); <span class="comment">// 1 str 2 age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于 ES6 来说，<code>Reflect.ownKeys(...)</code>、<code>Object.getWonPropertyNames(...)</code> 和 <code>Object.getOwnPropertySymbols(...)</code> 的顺序都是可预测且可靠的，这由规范保证。所以依赖这个顺序的代码是安全的。</p>
<p><code>Reflect.enumerate(...)</code>、Object.keys(…)<code>和</code>for … in<code>（以及扩展的</code>JSON.stringify(…)<code>）还像过去一样，可观察到顺序是相同的。但是这个顺序不再必须与</code>Reflect.ownKeys(…)` 相同。<em>在使用它们依赖于具体实现的顺序时要小心</em>。</p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ul>
<li><a href="http://w3help.org/zh-cn/causes/SJ9011" target="_blank" rel="noopener">Chrome Opera 中 for-in 语句遍历出对象属性的顺序与定义的不同</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>记 JS 的类型转换</title>
    <url>/2019/07/16/%E8%AE%B0-JS-%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JS 内最为诟病的便是其隐式类型转换问题，对于初学者来说，其复杂的规则以及诡异的结果很容易一头雾水。这难道表明 JS 不是很好吗？其实不然，隐式的转换带给我们的是代码的简介度，在合适的时机使用，同样会带来优质的 coding 体验。本文就来梳理一下 JS 类型转化规则，方便大家理解。</p>
<blockquote>
<p>本篇参考文章 《你所不知道的 JavaScript 中篇》 第四章</p>
</blockquote>
<a id="more"></a>
<h3 id="总体转换规则"><a href="#总体转换规则" class="headerlink" title="总体转换规则"></a>总体转换规则</h3><p>文档内介绍的比较清除，此处为了更好的展示效果，仅引用一下截取自 Alex Dorey 的 GithubIO 的一张图：</p>
<p><img data-src="/images/type-equal.png" alt="JavaScript 中的相等比较"></p>
<p>仔细理解一下，对于 JS 中很多相等比较的奇妙结果便都能解释了。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"0"</span> == <span class="literal">false</span>;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>当 string 与 boolean 类型比较时，会优先将 boolean 转化为 number，因此我们得到中间步骤为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 1</span></span><br><span class="line"><span class="string">"0"</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后 string 比较 number 时，此时会优先将 string 转化为 number，因此我们得到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 2</span></span><br><span class="line"><span class="number">0</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>最终的结果显而易见，那就是 true 了。</p>
<h3 id="极端情况"><a href="#极端情况" class="headerlink" title="极端情况"></a>极端情况</h3><p>当然我们不排除有些难以理解的极端情况，以下列举一个 Case：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] == ![]  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>分析一下，由于 <code>!</code> 的存在，我们优先进行显示转换，于是有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 1</span></span><br><span class="line">[] == !<span class="built_in">Boolean</span>([])</span><br><span class="line"><span class="comment">// Step 2</span></span><br><span class="line">[] == !<span class="literal">true</span></span><br><span class="line"><span class="comment">// Step 3</span></span><br><span class="line">[] == <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>然后对象与 boolean 类型比较时，我们需要调用对象的 [[DefaultValue]] 方法（toString/valueOf），因此我们得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Step 4</span><br><span class="line">[].toString() == false</span><br><span class="line">// Step 5</span><br><span class="line">&apos;&apos; == false</span><br></pre></td></tr></table></figure>
<p>这一步又回到了 string 与 boolean 的比较了，很明显最终的结果为 true。</p>
<p>此外，还有部分比较难以理解的，这里就稍微列举一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组单个值的解析</span></span><br><span class="line"><span class="string">''</span> == [<span class="literal">null</span>]</span><br><span class="line"><span class="string">''</span> == [<span class="literal">null</span>].toString()</span><br><span class="line"><span class="string">''</span> == <span class="string">''</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象的解析</span></span><br><span class="line"><span class="number">0</span> == &#123;&#125;</span><br><span class="line"><span class="number">0</span> == ToString(&#123;&#125;) <span class="comment">// 调用自身 __proto__ 上的 toString 方法</span></span><br><span class="line"><span class="number">0</span> == <span class="string">'[Object object]'</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>隐式类型转换相关的还有逻辑运算符，但是 JS 中的逻辑运算符又和其它强类型语言（如 C）的逻辑运算符不同，其返回值并非 boolean 类型。我们看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">a || b  <span class="comment">// 4</span></span><br><span class="line">a &amp;&amp; b  <span class="comment">// "a"</span></span><br><span class="line"></span><br><span class="line">c || b  <span class="comment">// "a"</span></span><br><span class="line">c &amp;&amp; b  <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>可见，|| 和 &amp;&amp; 首先会对<strong>第一个操作数（a 和 c）</strong>执行条件判断，如果其不是布尔值就进行 <code>toBoolean</code> 强制类型转换，然后再执行条件判断。</p>
<p><strong>其规律为：</strong></p>
<p>对于 || 来说，如果条件判断的结果为 true 就返回第一个操作数（a 和 c）的值，否则返回第二个操作数（b）的值。</p>
<p>对于 &amp;&amp; 来说，如果条件判断的结果为 true 就返回第二个操作数（b）的值，否则返回第一个操作数（a 和 c）的值。</p>
<blockquote>
<p>换个角度来看，它们很像三元运算符，但是它不会有副作用即：其不会执行两次。如 a ? a : c，如果 a 为比较复杂的运算，那么 a 会执行两次，但是 a || c，其 a 只会执行一次。</p>
</blockquote>
<p>此“逻辑运算符”在 JavaScript 中可能更为贴切的叫法为“操作数选择器”吧，在大多数的代码压缩后的内容中我们常常能见到其影子，工作中不妨也可以一试 ☆*:.｡. o(≧▽≦)o .｡.:*☆</p>
<div class="note info">
            <p>&amp;&amp; 和 || 运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。 —— ES5 规范 11.11 节</p>
          </div>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>我们知道，在 JS 中 { /<em> … </em>/ } 表明这是一个对象，但是我们常常忘了它还能表示为代码块，比如 while / if 后面的大括号。然而这和 JS 类型转换有什么关系呢，我们看看下例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] + &#123;&#125;  <span class="comment">// [object Object]</span></span><br><span class="line">&#123;&#125; + []  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>那么问题来了，仅仅调换了一个位置，为什么结果会相差这么多？</p>
<p>分析一下，在第一个例子中，{} 是在 + 运算符表达式中，词法分析将 {} 解析为第二个参数，因此经过隐式转换，{} 会被转换成 ‘[object Object]’，空数组就不用多解释了，所对应的结果也就如上了。</p>
<p>然而第二个却有些不同。我们知道 {} 作为空代码块是不执行任何操作的，且不用带 ; 结尾，所以在此处是不存在语法问题的。因此自左向右来看，词法分析将此分解为 {} 与 +[] 两部分，前者作为空代码块执行，无任何副作用，后者强制转换结果就是 0 了。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators" target="_blank" rel="noopener">比较操作符</a></li>
<li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3" target="_blank" rel="noopener">The Abstract Equality Comparison Algorithm</a></li>
<li><a href="https://dorey.github.io/JavaScript-Equality-Table/" target="_blank" rel="noopener">JavaScript 中的相等比较</a></li>
<li><a href="https://yanhaijing.com/es5/#about" target="_blank" rel="noopener">ES5 规范中文文档</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>重习 typescript</title>
    <url>/2020/04/14/%E9%87%8D%E4%B9%A0-typescript/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>俗话说的好：“温故而知新”，以前学习 <code>typescript</code> 只是因为工作需要去了解，然后临时磨刀学了些皮毛，但缺没有对 <code>typescript</code> 有更深入的理解，因此今天趁工作之余，系统了解一下 <code>typescript</code> 的相关知识，为后续的学习做好铺垫。</p>
<blockquote>
<p>注意：文章大部分为引用内容，且多为个人认为重要和难以记住的地方</p>
</blockquote>
<a id="more"></a>
<h3 id="了解-tsconfig-配置"><a href="#了解-tsconfig-配置" class="headerlink" title="了解 tsconfig 配置"></a>了解 tsconfig 配置</h3><p>做 ts 项目的时候，经常会发现项目内有个 tsconfig.json 的配置文件，那么这些配置是从哪里来的呢，它具体有那些配置属性呢，这里就一点点列举：</p>
<h4 id="生成配置属性"><a href="#生成配置属性" class="headerlink" title="生成配置属性"></a>生成配置属性</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自己进入一个空项目</span></span><br><span class="line">yarn add typescript</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 package.json 的 script 内写上：</span></span><br><span class="line"><span class="comment"># "tsinit": "tsc --init"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 tsconfig.json</span></span><br><span class="line">yarn tsinit</span><br></pre></td></tr></table></figure>
<h4 id="配置属性内容"><a href="#配置属性内容" class="headerlink" title="配置属性内容"></a>配置属性内容</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Basic Options</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// "incremental": true,                   /* 是否增量编译 */</span></span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>,                          <span class="comment">/* 指定编译后的 ECMAScript 版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */</span></span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,                     <span class="comment">/* 指定使用的模块标准: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */</span></span><br><span class="line">    <span class="comment">// "lib": [],                             /* 指定编译时包含的库文件 */</span></span><br><span class="line">    <span class="comment">// "allowJs": true,                       /* 指定是否允许编译 js 类型文件 */</span></span><br><span class="line">    <span class="comment">// "checkJs": true,                       /* 指定是否检查和报告 js 文件中的错误，通常与 allowJS 一起使用 */</span></span><br><span class="line">    <span class="comment">// "jsx": "preserve",                     /* 指定 jsx 代码用于的开发环境: 'preserve', 'react-native', or 'react' */</span></span><br><span class="line">    <span class="comment">// "declaration": true,                   /* 是否在编译的时候生成相应的 ".d.ts" 声明文件，但是 declaration 和 allowJs 不能同时设为 true */</span></span><br><span class="line">    <span class="comment">// "declarationMap": true,                /* 是否为声明文件生成 map 文件 */</span></span><br><span class="line">    <span class="comment">// "sourceMap": true,                     /* 编译时是否生成 map 文件 */</span></span><br><span class="line">    <span class="comment">// "outFile": "./",                       /* 指定输出的文件，它的值为一个文件路径名，只有设置 module 的值为 amd 和 system 模块时才支持这个配置 */</span></span><br><span class="line">    <span class="comment">// "outDir": "./",                        /* 指定输出文件夹 */</span></span><br><span class="line">    <span class="comment">// "rootDir": "./",                       /* 指定编译文件的根目录 */</span></span><br><span class="line">    <span class="comment">// "composite": true,                     /* 是否编译构建引用项目 */</span></span><br><span class="line">    <span class="comment">// "tsBuildInfoFile": "./",               /* 增量编译文件的存储位置 */</span></span><br><span class="line">    <span class="comment">// "removeComments": true,                /* 是否将编译后的文件中的注释删掉 */</span></span><br><span class="line">    <span class="comment">// "noEmit": true,                        /* 不生成编译文件 */</span></span><br><span class="line">    <span class="comment">// "importHelpers": true,                 /* 指定是否引入 tslib 里的辅助工具函数 */</span></span><br><span class="line">    <span class="comment">// "downlevelIteration": true,            /* 当 target 为 'ES5' 或 'ES3' 时，为 'for-of', 'spread' 和 'destructuring' 中的迭代器提供完全支持 */</span></span><br><span class="line">    <span class="comment">// "isolatedModules": true,               /* 指定是否将每个文件作为单独的模块（与“ts.transpileModule”类似） */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Strict Type-Checking Options</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,                           <span class="comment">/* 开启所有严格的类型检查 */</span></span><br><span class="line">    <span class="comment">// "noImplicitAny": true,                 /* 禁止隐式的 any 类型 */</span></span><br><span class="line">    <span class="comment">// "strictNullChecks": true,              /* 不允许把 null、undefined 赋值给其他类型变置 */</span></span><br><span class="line">    <span class="comment">// "strictFunctionTypes": true,           /* 指定是否使用函数参数双向协变检查 */</span></span><br><span class="line">    <span class="comment">// "strictBindCallApply": true,           /* 对 bind、call 和 apply 绑定的方法的参数的检测是严格检测的 */</span></span><br><span class="line">    <span class="comment">// "strictPropertyInitialization": true,  /* 检查类的非 undefined 属性是否已经在构造函数里初始化，需要同时开启 strictNullChecks */</span></span><br><span class="line">    <span class="comment">// "noImplicitThis": true,                /* 禁止 this 的类型为 any */</span></span><br><span class="line">    <span class="comment">// "alwaysStrict": true,                  /* 指定始终以严格模式检查每个模块，并且在编译之后的 js 文件中加入 "use strict" 字符串 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Additional Checks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// "noUnusedLocals": true,                /* 用于检查是否有定义了但是没有使用的变量 */</span></span><br><span class="line">    <span class="comment">// "noUnusedParameters": true,            /* 用于检查是否有在函数体中没有使用的参数 */</span></span><br><span class="line">    <span class="comment">// "noImplicitReturns": true,             /* 用于检查函数是否有返回值 */</span></span><br><span class="line">    <span class="comment">// "noFallthroughCasesInSwitch": true,    /* 用于检查 switch 中是否有 case 没有使用 break 跳出 switch */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Module Resolution Options</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// "moduleResolution": "node",            /* 模块解析策略: 'node' (Node.js) 或者 'classic' (TypeScript pre-1.6). */</span></span><br><span class="line">    <span class="comment">// "baseUrl": "./",                       /* 设置解析非相对模块名称的基本目录 */</span></span><br><span class="line">    <span class="comment">// "paths": &#123;&#125;,                           /* 设置模块名称到基于baseUrl的路径映射，类似于 webpack 的 alias 别名 */</span></span><br><span class="line">    <span class="comment">// "rootDirs": [],                        /* 指定一个路径列表，在构建时编译器会将这个路径列表中的路径的内容都放到一个文件夹中 */</span></span><br><span class="line">    <span class="comment">// "typeRoots": [],                       /* 指定声明文件或文件夹的路径列表，如果指定了此项，则只有在这里列出的声明文件才会被加载 */</span></span><br><span class="line">    <span class="comment">// "types": [],                           /* 指定需要包含的模块，只有在这里列出的模块的声明文件才会被加载进来 */</span></span><br><span class="line">    <span class="comment">// "allowSyntheticDefaultImports": true,  /* 允许引入没有默认导出的模块 */</span></span><br><span class="line">    <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span>,                  <span class="comment">/* 通过为导入内容创建命名空间，实现CommonJS和ES模块之间的互操作性。需要配置 'allowSyntheticDefaultImports'. */</span></span><br><span class="line">    <span class="comment">// "preserveSymlinks": true,              /* 不把符号链接解析为其真实路径 */</span></span><br><span class="line">    <span class="comment">// "allowUmdGlobalAccess": true,          /* 允许从模块访问 UMD 全局变量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Source Map Options</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// "sourceRoot": "",                      /* 指定调试器应该找到 TypeScript 文件而不是源文件位置 */</span></span><br><span class="line">    <span class="comment">// "mapRoot": "",                         /* 指定调试器找到映射文件而非生成文件的位置 */</span></span><br><span class="line">    <span class="comment">// "inlineSourceMap": true,               /* 指定是否将 map 文件的内容和 js 文件编译在同一个 js 文件中 */</span></span><br><span class="line">    <span class="comment">// "inlineSources": true,                 /* 用于指定是否进一步将 *.ts 文件的内容也包含到输入文件中; 需要设置 '--inlineSourceMap' 或者 '--sourceMap' */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Experimental Options</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// "experimentalDecorators": true,        /* 指定是否启用实验性的装饰器特性 */</span></span><br><span class="line">    <span class="comment">// "emitDecoratorMetadata": true,         /* 指定是否为装饰器提供元数据支持 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Advanced Options</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">"forceConsistentCasingInFileNames"</span>: <span class="literal">true</span>  <span class="comment">/* 不允许不同变量来代表同一文件 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="### 基础语法"></a>### 基础语法</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组有两张写法，个人推荐第一种，一目了然。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组多用于记录<strong>确定数量和类型</strong>的数组。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>当访问一个越界的元素，会使用联合类型替代：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">'world'</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()); <span class="comment">// OK, 'string' 和 'number' 都有 toString</span></span><br></pre></td></tr></table></figure>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>使用枚举可以定义一些<strong>有名字的数字常量</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;Red, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure>
<h4 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h4><p>处理不确定的内容：比如没有 ts 声明的第三方库/用户自定义库</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">"maybe a string instead"</span>;</span><br><span class="line">notSure = <span class="literal">false</span>; <span class="comment">// okay, definitely a boolean</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：能不用就尽量不用，因为使用此和不用 ts 没什么区别</p>
</blockquote>
<h4 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h4><p>表示没有任何类型，<strong>常用于无返回值</strong>的<strong>函数</strong>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"This is my warning message"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>。</p>
</blockquote>
<h4 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h4><p><code>never</code> 类型表示的是那些永不存在的值的类型。一般用于报错函数或者无终止条件的函数。</p>
<p><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 <code>never</code> 的子类型或可以赋值给 <code>never</code> 类型（除了 <code>never</code> 本身之外）。 即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 never 的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p><code>object</code> 表示非原始类型，也就是除 <code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code> 或 <code>undefined</code> 之外的类型。</p>
<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure>
<p>另一个为 <code>as</code> 语法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的。</p>
</blockquote>
<blockquote>
<p>注：类型断言会影响 ts 的类型校验，对于十分确定的情况可以使用断言来减少一些转换问题，但不要滥用。</p>
</blockquote>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> LabelledValue &#123;</span><br><span class="line">  label: <span class="built_in">string</span>;</span><br><span class="line">  size?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123;size: <span class="number">10</span>, label: <span class="string">"Size 10 Object"</span>&#125;;</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：可选属性如果出现报红提示时，需要考虑传入的变量类型为 undefined 的情况，因为 undefined 和 null 是所有基础类型的子集</p>
</blockquote>
<h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>一些对象属性只能在对象刚刚创建的时候修改其值。你可以在属性名前用 <code>readonly</code> 来指定只读属性:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  readonly x: <span class="built_in">number</span>;</span><br><span class="line">  readonly y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TypeScript 具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p>⚠️：上面代码的最后一行，可以看到就算把整个 ReadonlyArray 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最简单判断该用 <code>readonly</code> 还是 <code>const</code> 的方法是看要把它做为变量使用还是做为一个属性。做为变量使用的话用 <code>const</code>，若做为属性则使用 <code>readonly</code>。</p>
</blockquote>
<h4 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h4><p>对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: 'colour' not expected in type 'SquareConfig'</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; width: <span class="number">100</span>, opacity: <span class="number">0.5</span> &#125; <span class="keyword">as</span> SquareConfig);</span><br></pre></td></tr></table></figure>
<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⚠️ 注意</strong></p>
<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量：因为 squareOptions不会经过额外属性检查，所以编译器不会报错。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> squareOptions = &#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(squareOptions);</span><br></pre></td></tr></table></figure>
<h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配，函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。比如，我们使用下面的代码重写上面的例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不对应变量名</span></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 什么都不加</span></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src, sub</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h4><p>使用接口的方式来为数组进行类型声明</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray;</span><br><span class="line">myArray = [<span class="string">"Bob"</span>, <span class="string">"Fred"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>字符串索引签名能够很好的描述 dictionary 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code> 和 <code>obj[&quot;property&quot;]</code> 两种形式都可以。下面的例子里，<code>name</code> 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberDictionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;    <span class="comment">// 可以，length是number类型</span></span><br><span class="line">  name: <span class="built_in">string</span>       <span class="comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">" "</span> + restOfName.join(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">"Joseph"</span>, <span class="string">"Samuel"</span>, <span class="string">"Lucas"</span>, <span class="string">"MacKinzie"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h3><h4 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h4><p>UMD 模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块。 许多流行的库，比如 Moment.js，就是这样的形式。 比如，在 Node.js 或 RequireJs 里，你可以这样写：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> moment = <span class="built_in">require</span>(<span class="string">"moment"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(moment.format());</span><br></pre></td></tr></table></figure>
<h3 id="namespace-和-module"><a href="#namespace-和-module" class="headerlink" title="namespace 和 module"></a>namespace 和 module</h3><h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><p>TS 里的 <code>namespace</code> 主要是解决命名冲突的问题，会在全局生成一个对象，定义在 <code>namespace</code> 内部的类都要通过这个对象的属性访问。对于内部模块来说，尽量使用 <code>namespace</code> 替代 <code>module</code>，可参考<a href="https://www.tslang.cn/docs/handbook/namespaces.html" target="_blank" rel="noopener">官方文档</a>。例如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> USER_NAME = <span class="string">'test name'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> Polygons &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123; &#125;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> Square &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取别名</span></span><br><span class="line"><span class="keyword">import</span> polygons = Test.Polygons;</span><br><span class="line"><span class="keyword">const</span> username = Test.username</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：import xx = require(‘xx’) 为加载模块的写法，不要与取别名的写法混淆。</p>
</blockquote>
<blockquote>
<p>默认全局环境的 namespace 为 global</p>
</blockquote>
<h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p>模块可理解成 Vue 中的单个 vue 文件，它是以功能为单位进行划分的，一个模块负责一个功能。其与 <code>namespace</code> 的最大区别在于：<strong><code>namespace</code> 是跨文件的，<code>module</code> 是以文件为单位的，一个文件对应一个 <code>module</code></strong>。类比 Java，<code>namespace</code> 就好比 Java 中的包，而 <code>module</code> 则相当于文件。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://www.jianshu.com/p/47c29865b3a4" target="_blank" rel="noopener">tsconfig.json配置详解</a></li>
<li><a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener">官方文档</a></li>
<li><a href="https://idom.me/articles/838.html" target="_blank" rel="noopener">区分 TS 中的 namespace 和 module</a></li>
<li><a href="https://bbs.egret.com/thread-736-1-1.html" target="_blank" rel="noopener">关于 TypeScript 中的 module 和 export 关键词</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>项目 ts 迁移的踩坑记录</title>
    <url>/2019/07/14/%E9%A1%B9%E7%9B%AE-ts-%E8%BF%81%E7%A7%BB%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>先前发过一篇对于 shimes-vue-ts 文件的思考，其中有一节写到项目 ts 迁移所遇到的问题和解决方法。因为项目才刚迁移完一部分 ts（用得到的部分），踩坑的过程还在进行中，为了更好的记录 ts 迁移过程中所遇到的问题，还是单独写一篇来做记录吧。此篇便是改进后的问题记录，以及相对详细的解决方法。该篇会持续跟新哦~</p>
<a id="more"></a>
<h3 id="问题集锦"><a href="#问题集锦" class="headerlink" title="问题集锦"></a>问题集锦</h3><h4 id="动态引入无-ts-声明的文件"><a href="#动态引入无-ts-声明的文件" class="headerlink" title="动态引入无 ts 声明的文件"></a>动态引入无 ts 声明的文件</h4><p>项目内有动态设置 cookie 的文件，因为不同测试环境需要配置不同的 cookie，每天都需要从服务器拿取一次 cookie，目前的做法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cookie-set 文件夹已经移除 git 缓存跟踪</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'@/cookie-set'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于需要迁移 ts，对于原有的 cookie-set.js 需要进行类型声明（或者都改成 cookie-set.ts），为了兼容两种情况，这里还是做了对应类型声明，如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 declarations.d.ts 文件内添加</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '@/cookie-set';</span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>参考文章： <a href="https://www.tslang.cn/docs/handbook/modules.html" target="_blank" rel="noopener">模块</a>】、<a href="https://stackoverflow.com/questions/44058101/typescript-declare-third-party-modules" target="_blank" rel="noopener">typescript-declare-third-party-modules</a></p>
          </div>
<h4 id="引入无-typings-的-npm-包"><a href="#引入无-typings-的-npm-包" class="headerlink" title="引入无 typings 的 npm 包"></a>引入无 typings 的 npm 包</h4><p>比较全的 npm 包会包含对应的 typings 文件来支持 ts 项目，但是对于没有 typings 文件的包来说，我们需要对齐进行外部文件声明。那么为了支持 vue.use 方法，我们可以这么写对应的声明：</p>
<p>针对默认导出的声明写法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此适用于 import vueClipboard from 'vue-clipboard2';</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'vue-clipboard2' &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; PluginFunction &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">  <span class="keyword">const</span> clipboard: PluginFunction&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> clipboard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对解构的写法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此适用于 import &#123; monitorVue &#125; from 'fe-monitor-sdk';</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'fe-monitor-sdk' &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; PluginObject &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> monitorVue: PluginObject&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>export 和 export default 可参考模块部分内容</p>
</blockquote>
<div class="note default">
            <p>参考文章： <a href="https://www.tslang.cn/docs/handbook/modules.html" target="_blank" rel="noopener">模块</a>、<a href="https://cn.vuejs.org/v2/guide/typescript.html#ad" target="_blank" rel="noopener">TypeScript 支持</a></p>
          </div>
<h4 id="vue-router-的组建引用报错"><a href="#vue-router-的组建引用报错" class="headerlink" title="vue-router 的组建引用报错"></a>vue-router 的组建引用报错</h4><p>虽然在 webpack 内我们配置了 alias，但那仅仅只是 webpack 打包时用的，ts 并不认账，它有自己的配置文件。因此，在升级至 ts 项目时，我们还得为 ts 配置一份模块路径，如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  tsconfig.json</span></span><br><span class="line">path: [</span><br><span class="line">  <span class="string">"@/*"</span>: [</span><br><span class="line">    <span class="string">"src/*"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>此外，因为编辑器的原因使得无法识别 .vue 后缀，所以对于 vue 文件的引用必须添加 .vue 后缀，如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> myComponent <span class="keyword">from</span> <span class="string">'./my-component.vue'</span>;</span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>参考文章： <a href="https://github.com/vuejs/vue-cli/issues/1198" target="_blank" rel="noopener">Typescript: IDE reports TS2307</a>、<a href="https://www.tslang.cn/docs/handbook/module-resolution.html" target="_blank" rel="noopener">模块解析</a></p>
          </div>
<h4 id="vue-的-data-部分爆红"><a href="#vue-的-data-部分爆红" class="headerlink" title="vue 的 data 部分爆红"></a>vue 的 data 部分爆红</h4><p>这个问题比较隐蔽，折腾了很久才发现因为 data 为函数(主要是写惯了才难以察觉，官网文档因为类型推断所以没有写)，其内的对象为返回值，因此此部分的声明可以写（个人推荐不要用断言）：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值声明写法</span></span><br><span class="line">data(): Your Interface here &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言写法</span></span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;Your assertions here&gt; &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注: 主要是为 data 内的数组、对象声明对应类型，都为基础类型时不写后面使用也不会报错。</p>
</blockquote>
<h4 id="vue-的-mixins-文件写法"><a href="#vue-的-mixins-文件写法" class="headerlink" title="vue 的 mixins 文件写法"></a>vue 的 mixins 文件写法</h4><p>Vue 的 mixins 写法有两种，一种为普通的 ts 写法，另一种为装饰器的写法</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;<span class="comment">/**/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通 ts 写法</span></span><br><span class="line"><span class="keyword">import</span> Vue form <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue.extend(&#123;<span class="comment">/**/</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器写法</span></span><br><span class="line"><span class="keyword">import</span> &#123; Vue, Component, Prop &#125; <span class="keyword">from</span> <span class="string">"vue-property-decorator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> ComponentName <span class="keyword">extends</span> Vue &#123; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注: 普通 ts 写法的 computed 部分需要添加范围值，可参考 vue 文档 TypeScript 支持部分。</p>
</blockquote>
<div class="note default">
            <p>参考文章： <a href="https://github.com/Microsoft/TypeScript-Vue-Starter#typescript-vue-starter" target="_blank" rel="noopener">TypeScript-Vue-Starter</a>、<a href="https://cn.vuejs.org/v2/guide/typescript.html" target="_blank" rel="noopener">TypeScript 支持</a></p>
          </div>
<h4 id="VS-Code-experimentalDecorators-问题"><a href="#VS-Code-experimentalDecorators-问题" class="headerlink" title="VS Code experimentalDecorators 问题"></a>VS Code experimentalDecorators 问题</h4><p>因为 vue 装饰器写法为实验性特性，可能在未来的发行版中发生变化，因此需要配置此参数来删除警告。直接根据警告来做相应配置，即在 tsconfig.json 内添加属性：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="string">"experimentalDecorators"</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="类的静态方法"><a href="#类的静态方法" class="headerlink" title="类的静态方法"></a>类的静态方法</h4><p>关于类一般会采用 abstruct 抽象类来规范方法和属性等类的细节，但是对于“类”中 static 部分无法进行抽象规范，需要在对应<strong>静态方法</strong>部分进行单独处理，对于此部分是否有更好的处理方法存在疑问🤔（如：提取一个 interface 之类的声明）。目前想到的比较靠谱的写法有两个：</p>
<h5 id="namespace-写法"><a href="#namespace-写法" class="headerlink" title="namespace 写法"></a>namespace 写法</h5><p>官方文档中也有说过，对于业务内的模块来说，推荐使用 namespace 来做全局命名，因此对于业务内比较通用的公共方法来说，可以使用 namespace 来处理。</p>
<div class="note info">
            <p>对于多层命名空间的写法，可用别名写法 <code>import NS = FirstNameSpace.SecondNameSpace</code>，然后直接通过 <code>NS.xxx</code> 来直接取对应属性即可。同时区别加载模块时使用的 <code>import someModule = require(&#39;moduleName&#39;)</code>，此处的别名仅仅只是创建一个别名而已，简化代码量。</p>
          </div>
<h5 id="module-文件"><a href="#module-文件" class="headerlink" title="module 文件"></a>module 文件</h5><p>另一种可用 ES6 的思想，import + export ，因为类中只有 static 方法，因此可以认为该类为一个模块，而一个模块对应一个文件，因此作为一个 ts 文件来存储对应方法，需要时在 import 引入即可。</p>
<h4 id="eslint-迁移至-tslint-时部分校验修复失效问题"><a href="#eslint-迁移至-tslint-时部分校验修复失效问题" class="headerlink" title="eslint 迁移至 tslint 时部分校验修复失效问题"></a>eslint 迁移至 tslint 时部分校验修复失效问题</h4><h5 id="semi-无自动补全"><a href="#semi-无自动补全" class="headerlink" title="semi 无自动补全"></a>semi 无自动补全</h5><p>将原来配置的 eslint 的 semi 校验替换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 原来的配置</span><br><span class="line">semi: [&apos;error&apos;, &apos;always&apos;]</span><br><span class="line"></span><br><span class="line">// 现在的配置</span><br><span class="line">&quot;semi&quot;: &quot;off&quot;,</span><br><span class="line">&quot;@typescript-eslint/semi&quot;: [&quot;error&quot;],</span><br></pre></td></tr></table></figure>
<h5 id="import-引入没有使用的内容不报错"><a href="#import-引入没有使用的内容不报错" class="headerlink" title="import 引入没有使用的内容不报错"></a>import 引入没有使用的内容不报错</h5><p>因为 @vue/eslint-config-typescript 的文件内将 <code>@typescript-eslint/no-unused-vars</code> 给注释掉了，同时 <code>no-unused-vars</code> 设置为 ‘off’，使得对没有使用的变量都不校验。其对应设置的解释为：<br><a href="https://github.com/typescript-eslint/typescript-eslint/issues/46" target="_blank" rel="noopener">传送门</a></p>
<p>解决方法（跟项目 eslint 和 typescript 版本不同而不同）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'@typescript-eslint/no-unused-vars'</span>: [</span><br><span class="line">  <span class="string">'error'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    vars: <span class="string">'local'</span>,</span><br><span class="line">    args: <span class="string">'none'</span>,</span><br><span class="line">    ignoreRestSiblings: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>参考文档：<a href="https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/eslint-plugin" target="_blank" rel="noopener">@typescript-eslint/eslint-plugin</a>、<a href="https://vue.docschina.org/v2/guide/typescript.html" target="_blank" rel="noopener">TypeScript 支持</a>、<a href="https://github.com/typescript-eslint/typescript-eslint/issues/46" target="_blank" rel="noopener">typescript/no-unused-vars</a></p>
          </div>
<h4 id="refs-引用报错问题"><a href="#refs-引用报错问题" class="headerlink" title="$refs 引用报错问题"></a>$refs 引用报错问题</h4><p>由于 Vue 对 refs 的声明为 type Vue | Element | Vue[] | Element[]，在通过 $refs 调用对应组件方法时，因为 Vue 和 Element 上没有对应方法声明，因此我么需要对其进行断言处理，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface MyComponent extends Vue &#123;</span><br><span class="line">  someMethod(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 普通 ts 写法</span><br><span class="line">(this.$refs.myComp as MyComponent).someMethod()</span><br><span class="line"></span><br><span class="line">// 装饰器写法</span><br><span class="line">@Component</span><br><span class="line">export default class A extends Vue &#123;</span><br><span class="line">  $refs: &#123; myComp: MyComponent &#125;</span><br><span class="line"></span><br><span class="line">  this.$refs.myComp.someMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Prop-的类型问题"><a href="#Prop-的类型问题" class="headerlink" title="@Prop 的类型问题"></a>@Prop 的类型问题</h4><p>官方对于 @Prop 装饰器的写法提供了两种思路，分别为：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不带 type</span></span><br><span class="line"><span class="meta">@Prop</span>(&#123; <span class="keyword">default</span>: <span class="string">''</span> &#125;) readonly propB!: <span class="built_in">string</span></span><br><span class="line"><span class="comment">// 带 type</span></span><br><span class="line"><span class="meta">@Prop</span>(&#123; <span class="keyword">type</span>: <span class="built_in">String</span>, <span class="keyword">default</span>: <span class="string">''</span> &#125;) readonly propB!: <span class="built_in">string</span></span><br></pre></td></tr></table></figure>
<p>带 type 的和原来的写法可以说没什么区别，但是不带 type 的会出现两种问题：</p>
<h5 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h5><p>当为 Boolean 类型时，会使得属性官方 boolean 的简写方式无法生效，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不写 type 时此不生效，只能显示绑定 true 值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">is-published</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E5%B8%83%E5%B0%94%E5%80%BC" target="_blank" rel="noopener">官方例子</a></p>
</blockquote>
<h5 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h5><p>此不会触发部分的相应的 ts 类型校验，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 假如对应 props 为： @Prop() likes!: number; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此时 likes 传入类型为 string，但是不报错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">likes</span>=<span class="string">"42"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>个人建议：</strong> 除非非常确定传入的 Prop 的类型，否则尽量都加上对应的 type 声明</p>
</blockquote>
<h4 id="exceljs-引入报错问题"><a href="#exceljs-引入报错问题" class="headerlink" title="exceljs 引入报错问题"></a>exceljs 引入报错问题</h4><p>引入 <code>exceljs</code> 后，ts 一直报错 <code>import(&quot;stream&quot;)</code> 行因为没有找到 stream 包，因此报错。</p>
<p>问题定位了很久，才发现 <code>stream</code> 是 Node 自带的包，而我们的 <code>tsconfig.json</code> 内却并没有将对应的 node 类型引入，因此会报错，解决方法：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">"types"</span>: [</span><br><span class="line">      <span class="string">"webpack-env"</span>,</span><br><span class="line">      <span class="string">"node"</span> <span class="comment">// 将 node 类型加入即可</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，引入 node 后，可能会引发新的 ts 问题，比如自定义的 <code>process.env.XXX</code> 可能为 undefined，这个需要自己做兼容了。</p>
</blockquote>
<blockquote>
<p>参考 <a href="https://github.com/aws-amplify/docs/issues/273" target="_blank" rel="noopener">issue</a></p>
</blockquote>
<h3 id="拓展内容"><a href="#拓展内容" class="headerlink" title="拓展内容"></a>拓展内容</h3><h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><p>TS 里的 namespace 主要是解决命名冲突的问题，会在全局生成一个对象，定义在 namespace 内部的类都要通过这个对象的属性访问。对于内部模块来说，尽量使用 namespace 替代 module，可参考 namespace 一节。例如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> USER_NAME = <span class="string">'test name'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> Polygons &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123; &#125;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> Square &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取别名</span></span><br><span class="line"><span class="keyword">import</span> polygons = Test.Polygons;</span><br><span class="line"><span class="keyword">const</span> username = Test.username</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：import xx = require(‘xx’) 为加载模块的写法，不要与取别名的写法混淆。默认全局环境的 namespace 为 global</p>
</blockquote>
<div class="note default">
            <p>参考文档：<a href="https://www.tslang.cn/docs/handbook/namespaces.html" target="_blank" rel="noopener">namespace</a></p>
          </div>
<h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p>模块可理解成 Vue 中的单个 vue 文件，它是以功能为单位进行划分的，一个模块负责一个功能。其与 namespace 的最大区别在于：<strong>namespace 是跨文件的，module 是以文件为单位的，一个文件对应一个 module</strong>。类比 Java，namespace 就好比 Java 中的包，而 module 则相当于文件。</p>
<blockquote><p>如果你的模块需要将新的名称引入全局命名空间，那么就应该使用全局声明。如果你的模块无需将新的名称引入全局命名空间，那么就应该使用模块导出声明。</p>
<footer><strong>From</strong><cite>DefinitelyTyped</cite></footer></blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>项目布局与 flex</title>
    <url>/2019/06/10/%E9%A1%B9%E7%9B%AE%E5%B8%83%E5%B1%80%E4%B8%8E-flex/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在做项目的整体框架布局时曾用了 3 个版本，由最开始兼容性最好的 position 布局，到中间过渡调整用的 calc 布局，再到目前使用的 flex 布局。因为不考虑兼容性问题，因此用最新的写法来多趟趟水，此篇就是对所写的布局的一些心得。</p>
<a id="more"></a>
<h3 id="整体布局"><a href="#整体布局" class="headerlink" title="整体布局"></a>整体布局</h3><p>项目的整体外框为品字形布局，顶部为 logo 、主题和用户信息（hover 展示 poper 详情）；底部左侧为对应主题的图片，以及其一、二级菜单；底部右侧为内容区。此外最右侧还有一个浮动的快捷栏。</p>
<p>内容区顶部有公告信息（可展示也可隐藏），底部则是自适应内容区。大致结构如下：</p>
<p><img data-src="/images/project-container.jpg" alt="项目结构" style="width: 600px"></p>
<p>下面来说说如何来规划布局以及遇到的问题的处理。</p>
<h3 id="历史版本及其问题"><a href="#历史版本及其问题" class="headerlink" title="历史版本及其问题"></a>历史版本及其问题</h3><h4 id="position-版本"><a href="#position-版本" class="headerlink" title="position 版本"></a>position 版本</h4><p>早期项目并不是很复杂时，使用的是绝对定位的方式。当时顶部无主题、右侧无公告，同时也没有一直悬挂在右侧的浮动框和动画，因此处理比较简单。不过使用 position 来做定位，又一点不是很好的地方是左侧和顶部需要用 <code>margin</code> 撑开（防止内容被挡住），同时超出部分的滚动条展示，以及一部分切换动画的效果呈现最终让我下定决心来更改整体的布局。</p>
<h4 id="calc-版本"><a href="#calc-版本" class="headerlink" title="calc 版本"></a>calc 版本</h4><p>中期因为还在开发项目，因此采取了一个过渡方案 calc，将各部分的宽度计算出来，从而做到页面的布局展现。这个版本倒是没什么问题，在 chrome 上运行的很稳定，由于不清楚 calc 计算会不会影响页面的渲染速度，因此最后还是改成了 flex 布局。</p>
<h3 id="flex-布局分析"><a href="#flex-布局分析" class="headerlink" title="flex 布局分析"></a>flex 布局分析</h3><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p>整体的结构可分为上下结构，而下半部分又拆分为左右结构，因此，在设置完顶层的 <code>html</code> 和 <code>body</code> 之后，给项目的最外层 container 元素设以下属性作为外层容器：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后顶部设置固定高度 60px，底部默认 flex-grow: 1 撑开即可。然而在内容撑满后，这样设置出现了<a href="#固定高度内容收缩问题">顶部固定高度部分被压缩了</a>。</p>
<h4 id="顶部结构"><a href="#顶部结构" class="headerlink" title="顶部结构"></a>顶部结构</h4><p>顶部可分为三个部分：左侧的 logo、中间的主题列表以及右侧的用户头像部分。顶部基本太多问题，因为用户头像部分有多个不同的行内元素，而这块产生了<a href="#行内元素对齐问题">行内元素无法对齐的问题</a>（于是采用了最为方便的 flex 写法）</p>
<h4 id="底部结构"><a href="#底部结构" class="headerlink" title="底部结构"></a>底部结构</h4><p>底部内容区域分为左右结构，左侧菜单展示（用 element-menu 很简单），右侧就是内容区了。这部分左侧收缩有做 transition 动画，对于页面图表渲染较多的情况会比较卡（动画去掉了），基本上没遇到什么麻烦；右侧有一个很头疼的问题，那就是页面顶部的公告，因为是可有可无的，而公告下面的内容区要一直保证能够占满内容区（如果内容超出则显示滚动条）。</p>
<p>有人会说：“（折中方案）这有什么难的，内容区 flex 布局，上侧公告区（flex-shrink: 0），下部分内容区默认添上 <code>flex-grow: 1</code>，然后溢出滚动就可以了～”。如果事情能这么简单就好了。需求却并不是上下结构，而是一个整体，因为滚动条区域包裹了顶部公告，同时还要兼容以前的页面，即：</p>
<div class="note default">
            <p>当 “呈现的内容高度” + “公告高度（得考虑无公告的情况）” &lt; “内容区域高度” 时无滚动条；反之有滚动条。此外还需要做好老代码的兼容处理。</p>
          </div>
<p>emmmmm，果然世界上没有产品所想不出来的主意啊，当然，在“折中方案”上线之后，慢慢的终于摸索出了<a href="#内容区的智能滚动条问题">最佳方案</a>。</p>
<h4 id="右侧悬浮框"><a href="#右侧悬浮框" class="headerlink" title="右侧悬浮框"></a>右侧悬浮框</h4><p>右侧悬浮框虽然并无太多内容，但是需要在 Vue 项目内支持拖拽，大致为：拖拽时颜色变浅，停止拖拽时恢复原样。由于 Vue 提供 drag 方法，因此比较容易想到的方式是在监听拖拽的起止动作，然后动态绑定 class 控制其 <code>Visibility</code> 显隐性，然而基本上每次开始拖拽后立马就结束拖拽了，最终定位的<a href="#诡异的拖拽事件">问题</a>就在 <code>Visibility</code> 上。</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="固定高度内容收缩问题"><a href="#固定高度内容收缩问题" class="headerlink" title="固定高度内容收缩问题"></a>固定高度内容收缩问题</h4><p>在 flex 布局的模式下，子项的默认值为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: 0 1 <span class="selector-tag">auto</span>;</span><br></pre></td></tr></table></figure>
<p>其分别表示 <code>flex-grow</code> 为 0，即不会参与多余部分的分配（不可扩张）；<code>flex-shrink</code> 为 1，即当整体空间无法装下所有的内容时，该部分会按照一定的规则来压缩；<code>flex-basic</code> 为 auto，即默认以内容区高度为基础高度。</p>
<p>那么问题就来了。因为 <code>flex-basic</code> 为 auto，内容区域高度是由内容来决定的，虽然我们通过设置 <code>height: 60px</code> 将高度固定撑开，但是对于 flex 来说，我的 basic 部分并没有这么高（内容没有达到 60px），同时我这部分又是可压缩的，因此我可以匀一点来尽量使得另一部分能够撑满溢出的内容。而结果可想而知（顶部被压缩了）</p>
<p>解决的思路有三种：</p>
<ol>
<li>设置 <code>flex-shrink: 0</code> 来禁止其被压缩</li>
<li>设置 <code>min-height: 60px</code> 从而保证最低的高度</li>
<li>将其包裹的内容区高度设置为 60px</li>
</ol>
<h4 id="行内元素对齐问题"><a href="#行内元素对齐问题" class="headerlink" title="行内元素对齐问题"></a>行内元素对齐问题</h4><p>这部分先前有写过<a href="https://kazehaiya.github.io/2019/04/18/%E6%B5%85%E8%B0%88%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/">浅谈行内元素</a>，因为各部分默认对齐方式不同，此处仅写出两种最为快捷的方法：</p>
<ol>
<li>设置父级为 flex，然后设置 <code>align-items: center</code></li>
<li>修改各子元素的对齐方式为 <code>vertical-align: center</code></li>
</ol>
<h4 id="内容区的智能滚动条问题"><a href="#内容区的智能滚动条问题" class="headerlink" title="内容区的智能滚动条问题"></a>内容区的智能滚动条问题</h4><p>问题简单的抽象为一个有固定宽高的 flex 布局的父容器（column 排序），其包含两个子节点：</p>
<p>第一个节点可有可无，呈现时为定高的状态；</p>
<p>第二个节点当内容不是很高时，其会自动填充剩余部分（剩余部分 + 此节点内容 + 第一个节点内容 = 父容器高度）；当内容有足够高时，父级会出现滚动条来显示溢出的内容。</p>
<p>老版本此部分的实现是：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理想中最完美的升级方案是在原有的基础上添加一个 <code>flex-grow: 1</code> 然后删除 <code>height: 100%</code>，但是由于要不影响原有的代码（仅使用 flex-grow 不知道为什么，某个页面会出现一个只滚动 1px 距离的滚动条，方案 pass），因此做了下改变即添加一项 <code>min-height: calc(100% - 60px)</code> 然后滚动条就没有了。</p>
<p>前后试了一下，发现必须动态计算的 <code>min-height</code> 值与固定值之和为 100% 时才生效，个人感觉应该是因为刚好占满整个屏幕，因此不会触发多余的 flex 的动态计算，因此也就没有额外的滚动条了；当顶部公告消失时， <code>min-height</code> &lt; <code>height</code> 值，使内容能自动充满屏幕。</p>
<blockquote>
<p>如果并非需要兼容历史代码，建议直接 flex-grow: 1，删除 height: 100% 这样应该会好调整一些。</p>
</blockquote>
<h4 id="诡异的拖拽事件"><a href="#诡异的拖拽事件" class="headerlink" title="诡异的拖拽事件"></a>诡异的拖拽事件</h4><p>最开始写拖拽方法时添加的类为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.onDrag</span> &#123;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在拖拽时隐藏元素，松开时显示元素（最开始实验阶段的 vue/cli3 时可以通过此方法实现），后来版本升级后，该方法失效了，会使得隐藏后会立即事情元素焦点，然后立即出发了 dragend 事件，此较好的解决方法目前是将 <code>visibility: hidden</code> 改成了 <code>opacity: 0</code>，但是更新后拖拽过程中设置元素 <code>visibility: hidden;</code> 会使得焦点丢失，这个原因目前不是很明确。</p>
<h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><blockquote>
<p><a href="https://codepen.io/kazehaiya/project/editor/XNbLkL" target="_blank" rel="noopener">参考例子</a></p>
</blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://www.cnblogs.com/chris-oil/p/5430137.html" target="_blank" rel="noopener">flex设置成 1 和 auto 有什么区别</a></li>
<li><a href="https://www.w3.org/html/ig/zh/css-flex-1/" target="_blank" rel="noopener">W3C flex</a></li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
